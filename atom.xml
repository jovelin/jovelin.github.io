<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jovelin&#39;s Blog</title>
  
  <subtitle>Python The old farmer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jovelin.cn/"/>
  <updated>2018-07-31T02:07:53.000Z</updated>
  <id>http://jovelin.cn/</id>
  
  <author>
    <name>曹永林</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS 样式</title>
    <link href="http://jovelin.cn/2018/07/31/JS%20%E8%84%9A%E6%9C%AC/"/>
    <id>http://jovelin.cn/2018/07/31/JS 脚本/</id>
    <published>2018-07-31T01:00:01.000Z</published>
    <updated>2018-07-31T02:07:53.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>JS 用法、注释；</li><li>变量、判断语句、函数；</li><li>输出内容（document.write）；</li><li>对话框（dialog）；</li><li>窗口（window）；</li><li>文档对象模型（DOM）</li><li>事件。</li></ol></blockquote><h3 id="一、用法"><a href="#一、用法" class="headerlink" title="一、用法"></a>一、用法</h3><p>JS内部引用</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="string">"hello"</span>);</span></span><br><span class="line"><span class="actionscript">    alert(<span class="string">"JS代码"</span>)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引用JS外部文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"myscript.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong> javascript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。</p><h3 id="二、注释"><a href="#二、注释" class="headerlink" title="二、注释"></a>二、注释</h3><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">单行注释，在注释内容前加符号<span class="string">"//""</span></span><br><span class="line"></span><br><span class="line">多行注释以<span class="string">"/*"</span>开始，以<span class="string">"*/"</span>结束。</span><br></pre></td></tr></table></figure><h3 id="三、变量"><a href="#三、变量" class="headerlink" title="三、变量"></a>三、变量</h3><p><strong>定义变量使用关键字var,语法如下：</strong><br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> 变量名</span><br></pre></td></tr></table></figure></p><p><strong>变量名可以任意取名，但要遵循命名规则:</strong></p><pre><code>1.变量必须使用字母、下划线(_)或者美元符($)开始。2.然后可以使用任意多个英文字母、数字、下划线(_)或者美元符($)组成。3.不能使用JavaScript关键词与JavaScript保留字。</code></pre><p><strong>变量要先声明再赋值，如下：</strong></p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">var mychar<span class="comment">;</span></span><br><span class="line"><span class="attribute">mychar</span>=<span class="string">"javascript"</span><span class="comment">;</span></span><br><span class="line">var mynum = <span class="number">6</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>变量可以重复赋值，如下：</strong></p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">var mychar<span class="comment">;</span></span><br><span class="line"><span class="attribute">mychar</span>=<span class="string">"javascript"</span><span class="comment">;</span></span><br><span class="line"><span class="attribute">mychar</span>=<span class="string">"hello"</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li><p>在JS中区分大小写，如变量mychar与myChar是不一样的，表示是两个变量。</p></li><li><p>变量虽然也可以不声明，直接使用，但不规范，需要先声明，后使用。</p></li></ol><h3 id="四、判断语句（if…else）"><a href="#四、判断语句（if…else）" class="headerlink" title="四、判断语句（if…else）"></a>四、判断语句（if…else）</h3><p><strong>语法:</strong></p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">(条件)</span></span></span><br><span class="line">&#123; 条件成立时执行的代码 &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; 条件不成立时执行的代码 &#125;</span><br></pre></td></tr></table></figure><h3 id="五、函数"><a href="#五、函数" class="headerlink" title="五、函数"></a>五、函数</h3><p><strong>如何定义一个函数呢？基本语法如下:</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     函数代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li><p>function定义函数的关键字。</p></li><li><p>“函数名”你为函数取的名字。</p></li><li><p>“函数代码”替换为完成特定功能的代码。</p></li></ol><p><strong>函数调用:</strong></p><p>函数定义好后，是不能自动执行的，所以需调用它,只需直接在需要的位置写函数就ok了,<strong>代码如下:</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">contxt</span>(<span class="params"></span>) //定义函数</span></span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"哈哈，调用函数了!"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"点击我"</span> <span class="attr">onclick</span>=<span class="string">"contxt()"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="六、输出内容（document-write）"><a href="#六、输出内容（document-write）" class="headerlink" title="六、输出内容（document.write）"></a>六、输出内容（document.write）</h3><p>document.write() 可用于直接向 HTML 输出流写内容。简单的说就是直接在网页中输出内容。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript"> 第一种:输出内容用<span class="string">""</span>括起，直接输出<span class="string">""</span>号内的内容。</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="string">"I love JavaScript！"</span>); <span class="comment">//内容用""括起来，""里的内容直接输出。</span></span></span><br><span class="line"><span class="undefined">      </span></span><br><span class="line"><span class="undefined"> 第二种:通过变量，输出内容</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> mystr=<span class="string">"hello world!"</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(mystr);  <span class="comment">//直接写变量名，输出变量存储的内容。</span></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="undefined"> 第三种:输出多项内容，内容之间用+号连接。</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> mystr=<span class="string">"hello"</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(mystr+<span class="string">"I love JavaScript"</span>); <span class="comment">//多项内容之间用+号连接</span></span></span><br><span class="line"><span class="undefined">      </span></span><br><span class="line"><span class="actionscript"> 第四种:输出HTML标签，并起作用，标签使用<span class="string">""</span>括起来。</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> mystr=<span class="string">"hello"</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(mystr+<span class="string">"&lt;br&gt;"</span>);<span class="comment">//输出hello后，输出一个换行符</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.write(<span class="string">"JavaScript"</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>如何输出空格, 解决方法:</strong></p><ol><li>使用输出html标签<code></code>来解决</li></ol><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">document.<span class="built_in">write</span>(<span class="string">"  "</span>+<span class="string">"1"</span>+<span class="string">"    "</span>+<span class="string">"23"</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>使用CSS样式来解决</li></ol><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">document.<span class="built_in">write</span>(<span class="string">"&lt;span style='white-space:pre;'&gt;"</span>+<span class="string">"  1        2    3    "</span>+<span class="string">"&lt;/span&gt;"</span>);</span><br></pre></td></tr></table></figure><p>在输出时添加“white-space:pre;”样式属性。这个样式表示”<strong>空白会被浏览器保留</strong>“</p><h3 id="七、对话框"><a href="#七、对话框" class="headerlink" title="七、对话框"></a>七、对话框</h3><h4 id="警告（alert-消息对话框）"><a href="#警告（alert-消息对话框）" class="headerlink" title="警告（alert 消息对话框）"></a>警告（alert 消息对话框）</h4><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">alert(字符串或变量)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li><p>在点击对话框”确定”按钮前，不能进行任何其它操作。</p></li><li><p>消息对话框通常可以用于调试程序。</p></li><li><p>alert输出内容，可以是字符串或变量，与document.write 相似。</p></li></ol><h4 id="确认（confirm-消息对话框）"><a href="#确认（confirm-消息对话框）" class="headerlink" title="确认（confirm 消息对话框）"></a>确认（confirm 消息对话框）</h4><p><strong>语法：</strong></p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">confirm(<span class="name">str</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong><br><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">str</span>：在消息对话框中要显示的文本</span><br></pre></td></tr></table></figure></p><p><strong>返回值</strong><br><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">返回值: <span class="keyword">Boolean</span>值</span><br></pre></td></tr></table></figure></p><p><strong>注: 通过返回值可以判断用户点击了什么按钮</strong></p><p>代码示例：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> mymessage=confirm(<span class="string">"你喜欢JavaScript吗?"</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">if</span>(mymessage==<span class="literal">true</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">"很好,加油!"</span>);</span></span><br><span class="line"><span class="actionscript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">"JS功能强大，要学习噢!"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="提问（prompt-消息对话框）"><a href="#提问（prompt-消息对话框）" class="headerlink" title="提问（prompt 消息对话框）"></a>提问（prompt 消息对话框）</h4><p><strong>语法:</strong></p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">prompt(<span class="name">str1</span>, str2)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">str1：要显示在消息对话框中的文本，不可修改</span></span><br><span class="line"><span class="keyword">str2：文本框中的内容，可以修改</span></span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>点击确定按钮，文本框中的内容将作为函数返回值</span><br><span class="line"><span class="bullet">2. </span>点击取消按钮，将返回null</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myname=prompt(<span class="string">"请输入你的姓名:"</span>);</span><br><span class="line"><span class="keyword">if</span>(myname!=<span class="literal">null</span>) &#123;</span><br><span class="line">    alert(<span class="string">"你好"</span>+myname);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">"你好 my friend."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八、窗口（window）"><a href="#八、窗口（window）" class="headerlink" title="八、窗口（window）"></a>八、窗口（window）</h3><h4 id="打开新窗口（window-open）"><a href="#打开新窗口（window-open）" class="headerlink" title="打开新窗口（window.open）"></a>打开新窗口（window.open）</h4><p><strong>语法</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">window</span><span class="selector-class">.open</span>(<span class="selector-attr">[URL]</span>, <span class="selector-attr">[窗口名称]</span>, <span class="selector-attr">[参数字符串]</span>)</span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">URL：可选参数，在窗口中要显示网页的网址或路径。</span><br><span class="line">如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。</span><br><span class="line">窗口名称：可选参数，被打开窗口的名称。</span><br><span class="line"><span class="number">1</span>.该名称由字母、数字和下划线字符组成。</span><br><span class="line"><span class="number">2</span>.<span class="string">"_top"</span>、<span class="string">"_blank"</span>、<span class="string">"_self"</span>具有特殊意义的名称。</span><br><span class="line">    <span class="variable">_blank</span>：在新窗口显示目标网页</span><br><span class="line">    <span class="variable">_self</span>：在当前窗口显示目标网页</span><br><span class="line">    <span class="variable">_top</span>：框架网页中在上部窗口中显示目标网页</span><br><span class="line"><span class="number">3</span>.相同 <span class="built_in">name</span> 的窗口只能创建一个，要想创建多个窗口则 <span class="built_in">name</span> 不能相同。</span><br><span class="line"><span class="number">4</span>.<span class="built_in">name</span> 不能包含有空格。</span><br><span class="line">参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。</span><br></pre></td></tr></table></figure><p><strong>参数表：</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/3365001-01d46e2961d46c80.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>例如：打开<a href="http://www.imooc.com网站，大小为300px" target="_blank" rel="noopener">http://www.imooc.com网站，大小为300px</a> * 200px，无菜单，无工具栏，无状态栏，有滚动条窗口：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.open(<span class="string">'http://www.imooc.com'</span>,<span class="string">'_blank'</span>,<span class="string">'width=300,height=200,menubar=no,toolbar=no, status=no,scrollbars=yes'</span>)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：运行结果考虑浏览器兼容问题。</p><h4 id="关闭窗口（window-close）"><a href="#关闭窗口（window-close）" class="headerlink" title="关闭窗口（window.close）"></a>关闭窗口（window.close）</h4><p><strong>用法：</strong></p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">widow.<span class="built_in">close</span>(); <span class="comment">// 关闭本窗口</span></span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">&lt;窗口对象&gt;.<span class="built_in">close</span>(); <span class="comment">// 关闭指定的窗口</span></span><br></pre></td></tr></table></figure><h3 id="九、DOM"><a href="#九、DOM" class="headerlink" title="九、DOM"></a>九、DOM</h3><h4 id="认识-DOM"><a href="#认识-DOM" class="headerlink" title="认识 DOM"></a>认识 DOM</h4><p>文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。</p><p><strong>HTML文档可以说由节点构成的集合，三种常见的DOM节点:</strong></p><ol><li><p><strong>元素节点</strong>：<html>、<body>、<p>等都是元素节点，即标签。</p></body></html></p></li><li><p><strong>文本节点</strong>:向用户展示的内容，如<li>…</li>中的JavaScript、DOM、CSS等文本。</p></li><li><p><strong>属性节点</strong>:元素属性，如<a>标签的链接属性href=”<a href="http://www.imooc.com&quot;。" target="_blank" rel="noopener">http://www.imooc.com&quot;。</a></a></p></li></ol><h4 id="通过ID获取元素"><a href="#通过ID获取元素" class="headerlink" title="通过ID获取元素"></a>通过ID获取元素</h4><p>语法：</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">document.getElementById(“<span class="built_in">id</span>”)</span><br></pre></td></tr></table></figure><p><strong>结果：null或[object HTMLParagraphElement]</strong></p><p><strong>注：在获取的元素是一个对象，如想对元素进行操作，我们要通过它的属性或方法。</strong></p><h3 id="innerHTML-属性"><a href="#innerHTML-属性" class="headerlink" title="innerHTML 属性"></a>innerHTML 属性</h3><p>innerHTML 属性用于获取或替换 HTML 元素的内容。</p><p><strong>语法：</strong></p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Object.<span class="attribute">innerHTML</span>=<span class="string">""</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>1.Object是获取的元素对象，如通过document.getElementById(“ID”)获取的元素。</p><p>2.注意书写，innerHTML区分大小写。</p><h3 id="改变-HTML-样式"><a href="#改变-HTML-样式" class="headerlink" title="改变 HTML 样式"></a>改变 HTML 样式</h3><p>HTML DOM 允许 JavaScript 改变 HTML 元素的样式。如何改变 HTML 元素的样式呢？</p><p><strong>语法</strong></p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">Object.<span class="built_in">style</span>.property=<span class="built_in">new</span> <span class="built_in">style</span>;</span><br></pre></td></tr></table></figure><p><strong>基本属性表（property）:</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/3365001-64e7993408d55584.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>代码示例：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"pcon"</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> mychar = <span class="built_in">document</span>.getElementById(<span class="string">"pcon"</span>);</span></span><br><span class="line"><span class="actionscript">   mychar.style.color=<span class="string">"red"</span>;</span></span><br><span class="line"><span class="actionscript">   mychar.style.fontSize=<span class="string">"20"</span>;</span></span><br><span class="line"><span class="actionscript">   mychar.style.backgroundColor =<span class="string">"blue"</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="显示和隐藏（display属性）"><a href="#显示和隐藏（display属性）" class="headerlink" title="显示和隐藏（display属性）"></a>显示和隐藏（display属性）</h3><p>网页中经常会看到显示和隐藏的效果，可通过display属性来设置。</p><p><strong>语法</strong></p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">Object<span class="selector-class">.style</span><span class="selector-class">.display</span> = value</span><br></pre></td></tr></table></figure><p><strong>value取值：</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/3365001-c871fb4088357fce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="控制类名（className-属性）"><a href="#控制类名（className-属性）" class="headerlink" title="控制类名（className 属性）"></a>控制类名（className 属性）</h3><p>className 属性设置或返回元素的class 属性。</p><p><strong>语法：</strong></p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">object</span><span class="selector-class">.className</span> = classname</span><br></pre></td></tr></table></figure><p><strong>作用：</strong></p><ol><li><p>获取元素的 class 属性</p></li><li><p>为网页内的某个元素指定一个css样式来更改该元素的外观</p></li></ol><h3 id="样式全部取消"><a href="#样式全部取消" class="headerlink" title="样式全部取消"></a>样式全部取消</h3><p>removeAttribute(“style”)</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量，存储数据的容器。<br>变量名:容器—-  杯子<br>变量值：数据—杯子里的水</p><p>1.必须以字母、下划线或美元符号开头，后面可以跟字母、下划线、美元符号和数字。如下:</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">正确:           </span><br><span class="line">    mysum            </span><br><span class="line">    <span class="title">_mychar</span>         </span><br><span class="line">    $numa1          </span><br><span class="line">错误:</span><br><span class="line">  <span class="number">6</span><span class="built_in">num</span> <span class="comment"> //开头不能用数字</span></span><br><span class="line">  %<span class="built_in">sum</span><span class="comment"> //开头不能用除(_ $)外特殊符号,如(%  + /等)</span></span><br><span class="line">  <span class="built_in">sum</span>+<span class="built_in">num</span><span class="comment"> //开头中间不能使用除(_ $)外特殊符号，如(%  + /等)</span></span><br></pre></td></tr></table></figure><p>2.变量名区分大小写，如:A与a是两个不同变量。</p><p>3.不允许使用JavaScript关键字和保留字做变量名。</p><p><img src="http://upload-images.jianshu.io/upload_images/3365001-c81e4b7f57775aea.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="什么是事件"><a href="#什么是事件" class="headerlink" title="什么是事件"></a>什么是事件</h3><p>事件是可以被 JavaScript 侦测到的行为。 </p><p><strong>主要事件表:</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/3365001-0a99ec0ed6d6351d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="Date-日期对象"><a href="#Date-日期对象" class="headerlink" title="Date 日期对象"></a>Date 日期对象</h3><p><img src="http://upload-images.jianshu.io/upload_images/3365001-dfdf6d892fee197d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="返回指定的字符串首次出现的位置"><a href="#返回指定的字符串首次出现的位置" class="headerlink" title="返回指定的字符串首次出现的位置"></a>返回指定的字符串首次出现的位置</h3><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">stringObject.indexOf(substring, </span>startpos)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/3365001-a99edd43911f84dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="字符串分割split"><a href="#字符串分割split" class="headerlink" title="字符串分割split()"></a>字符串分割split()</h3><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">stringObject.<span class="built_in">split</span>(separator,<span class="built_in">limit</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/3365001-f7933f4797dd54f0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="提取字符串substring"><a href="#提取字符串substring" class="headerlink" title="提取字符串substring()"></a>提取字符串substring()</h3><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">stringObject.substring(startP<span class="keyword">os</span>,stopP<span class="keyword">os</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/3365001-df5dfc75925ebefb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="提取指定数目的字符substr"><a href="#提取指定数目的字符substr" class="headerlink" title="提取指定数目的字符substr()"></a>提取指定数目的字符substr()</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">stringObject.substr(startPos,<span class="built_in">length</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/3365001-aeefa8a1e39c08cb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="Array-数组对象"><a href="#Array-数组对象" class="headerlink" title="Array 数组对象"></a>Array 数组对象</h3><p><strong>数组定义的方法：</strong></p><ol><li>定义了一个空数组:</li></ol><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  数组名= <span class="keyword">new</span> <span class="type">Array</span>();</span><br></pre></td></tr></table></figure><ol start="2"><li>定义时指定有n个空元素的数组:</li></ol><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 =<span class="keyword">new</span> <span class="type">Array</span>(n);</span><br></pre></td></tr></table></figure><ol start="3"><li>定义数组的时候，直接初始化数据：</li></ol><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">var  数组名 = [&lt;元素<span class="number">1</span>&gt;, &lt;元素<span class="number">2</span>&gt;, &lt;元素<span class="number">3</span>&gt;...];</span><br><span class="line">我们定义myArray数组，并赋值，代码如下：</span><br><span class="line"></span><br><span class="line">var myArray = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">6</span>]; </span><br><span class="line">说明：定义了一个数组 myArray，里边的元素是：myArray[<span class="number">0</span>] = <span class="number">2</span>; myArray[<span class="number">1</span>] = <span class="number">8</span>; myArray[<span class="number">2</span>] = <span class="number">6</span>。</span><br></pre></td></tr></table></figure><h3 id="数组连接concat"><a href="#数组连接concat" class="headerlink" title="数组连接concat()"></a>数组连接concat()</h3><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">arrayObject.concat(array1,array2,...,arrayN)</span><br></pre></td></tr></table></figure><h3 id="计时器setInterval"><a href="#计时器setInterval" class="headerlink" title="计时器setInterval()"></a>计时器setInterval()</h3><p><strong>语法：</strong></p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">setInterval(代码，交互时间)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ol><li><p>代码：要调用的函数或要执行的代码串。</p></li><li><p>交互时间：周期性执行或调用表达式之间的时间间隔，以毫秒计（1s=1000ms）。</p></li></ol><p><strong>返回值：</strong></p><p>一个可以传递给 clearInterval() 从而取消对”代码”的周期性执行的值。</p><p><strong>调用函数格式</strong>(假设有一个clock()函数)：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">setInterval</span><span class="params">(<span class="string">"clock()"</span>,<span class="number">1000</span>)</span></span></span><br><span class="line">或</span><br><span class="line"><span class="function"><span class="title">setInterval</span><span class="params">(clock,<span class="number">1000</span>)</span></span></span><br></pre></td></tr></table></figure><h3 id="取消计时器clearInterval"><a href="#取消计时器clearInterval" class="headerlink" title="取消计时器clearInterval()"></a>取消计时器clearInterval()</h3><p><strong>语法：</strong></p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">clearInterval</span><span class="params">(id_of_setInterval)</span></span></span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><p>id_of_setInterval：由 setInterval() 返回的 ID 值。</p><h3 id="计时器setTimeout"><a href="#计时器setTimeout" class="headerlink" title="计时器setTimeout()"></a>计时器setTimeout()</h3><p>setTimeout()计时器，在载入后延迟指定时间后,去执行一次表达式,仅执行一次。</p><p><strong>语法：</strong></p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(代码,延迟时间);</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ol><li>要调用的函数或要执行的代码串。</li><li>延时时间：在执行代码前需等待的时间，以毫秒为单位（1s=1000ms)。</li></ol><h3 id="取消计时器clearTimeout"><a href="#取消计时器clearTimeout" class="headerlink" title="取消计时器clearTimeout()"></a>取消计时器clearTimeout()</h3><p>setTimeout()和clearTimeout()一起使用，停止计时器。</p><p><strong>语法：</strong></p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">clearTimeout</span><span class="params">(id_of_setTimeout)</span></span></span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><p>id_of_setTimeout：由 setTimeout() 返回的 ID 值。该值标识要取消的延迟执行代码块。</p><h3 id="History-对象"><a href="#History-对象" class="headerlink" title="History 对象"></a>History 对象</h3><p>history对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能。</p><p>注意:<strong>从窗口被打开的那一刻开始记录，每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联</strong>。</p><p><strong>语法：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">window</span><span class="selector-class">.history</span>.<span class="selector-attr">[属性|方法]</span></span><br></pre></td></tr></table></figure><p>注意：window可以省略。</p><p><strong>History 对象属性</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/3365001-3a980a2bc02e3990.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>History 对象方法</strong></p><p> <img src="http://upload-images.jianshu.io/upload_images/3365001-d17364fa1ca90455.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>使用length属性，当前窗口的浏览历史总长度，代码如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> HL = <span class="built_in">window</span>.history.length;</span><br><span class="line">  <span class="built_in">document</span>.write(HL);</span><br></pre></td></tr></table></figure><p><strong>返回前一个浏览的页面</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">window</span><span class="selector-class">.history</span><span class="selector-class">.back</span>();</span><br><span class="line"><span class="selector-tag">window</span><span class="selector-class">.history</span><span class="selector-class">.go</span>(<span class="selector-tag">-1</span>);</span><br></pre></td></tr></table></figure><p><strong>返回下一个浏览的页面</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">window</span><span class="selector-class">.history</span><span class="selector-class">.forward</span>();</span><br><span class="line"><span class="selector-tag">window</span><span class="selector-class">.history</span><span class="selector-class">.go</span>(1);</span><br></pre></td></tr></table></figure><p><strong>返回浏览历史中的其他页面</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">window</span><span class="selector-class">.history</span><span class="selector-class">.go</span>(<span class="selector-tag">number</span>);</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/3365001-444ee4a8461828bd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h3><p>location用于获取或设置窗体的URL，并且可以用于解析URL。</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">location.[属性<span class="string">|方法]</span></span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/3365001-8d945d9632be81db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="location对象属性图示"></p><p><img src="http://upload-images.jianshu.io/upload_images/3365001-baeab9cdf9ea4814.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="location 对象属性"></p><p><img src="http://upload-images.jianshu.io/upload_images/3365001-13a9b25aac10c618.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="location 对象方法"></p><h3 id="Navigator对象"><a href="#Navigator对象" class="headerlink" title="Navigator对象"></a>Navigator对象</h3><p>Navigator 对象包含有关浏览器的信息，通常用于检测浏览器与操作系统的版本。</p><p><img src="http://upload-images.jianshu.io/upload_images/3365001-6852852b27031104.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象属性"></p><p><strong>userAgent</strong></p><p>返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">navigator</span><span class="selector-class">.userAgent</span></span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/3365001-c8f5fa62f0bb24bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="几种浏览的user_agent，像360的兼容模式用的是IE、极速模式用的是chrom的内核"></p><p>使用userAgent判断使用的是什么浏览器(假设使用的是IE8浏览器)，代码如下:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">function validB()&#123; </span><br><span class="line">  var u_agent = navigator.userAgent; </span><br><span class="line">  var <span class="attribute">B_name</span>=<span class="string">"Failed to identify the browser"</span>; </span><br><span class="line">  <span class="keyword">if</span>(u_agent.indexOf(<span class="string">"Firefox"</span>)&gt;-1)&#123; </span><br><span class="line">      <span class="attribute">B_name</span>=<span class="string">"Firefox"</span>; </span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(u_agent.indexOf(<span class="string">"Chrome"</span>)&gt;-1)&#123; </span><br><span class="line">      <span class="attribute">B_name</span>=<span class="string">"Chrome"</span>; </span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(u_agent.indexOf(<span class="string">"MSIE"</span>)&gt;-1&amp;&amp;u_agent.indexOf(<span class="string">"Trident"</span>)&gt;-1)&#123; </span><br><span class="line">      <span class="attribute">B_name</span>=<span class="string">"IE(8-10)"</span>;  </span><br><span class="line">  &#125;</span><br><span class="line">    document.write(<span class="string">"B_name:"</span>+B_name+<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">    document.write(<span class="string">"u_agent:"</span>+u_agent+<span class="string">"&lt;br&gt;"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="screen-对象"><a href="#screen-对象" class="headerlink" title="screen 对象"></a>screen 对象</h3><p>screen对象用于获取用户的屏幕信息。</p><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.<span class="keyword">screen</span>.属性</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/3365001-40e9fb4a8c6dd437.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象属性"></p><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。</p><p><strong>HTML文档可以说由节点构成的集合，DOM节点有：</strong></p><ol><li><p><strong>元素节点</strong>：上图中<code>&lt;html&gt;、&lt;body&gt;、&lt;p&gt;</code>等都是元素节点，即标签。</p></li><li><p><strong>文本节点</strong>:向用户展示的内容，如<code>&lt;li&gt;...&lt;/li&gt;</code>中的JavaScript、DOM、CSS等文本。</p></li><li><p>属性节点:元素属性，如<code>&lt;a&gt;</code>标签的链接属性<code>href=&quot;http://www.imooc.com&quot;</code>。</p></li></ol><p><img src="http://upload-images.jianshu.io/upload_images/3365001-6d5378e4cabf3354.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="节点属性"></p><p><img src="http://upload-images.jianshu.io/upload_images/3365001-872e4c9eee5e5882.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="遍历节点树"></p><p><img src="http://upload-images.jianshu.io/upload_images/3365001-f098db82ccd87c65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DOM操作"></p><p><strong>注意</strong>：前两个是document方法。</p><p><strong>getElementsByName()方法</strong></p><p>返回带有指定名称的节点对象的集合</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">document.getElementsByName(name)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>getElementsByTagName()方法</strong></p><p>返回带有指定标签名的节点对象的集合。返回元素的顺序是它们在文档中的顺序。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(Tagname) <span class="comment">// Tagname是标签的名称，如p、a、img等标签名</span></span><br></pre></td></tr></table></figure><p><strong>区别getElementByID,getElementsByName,getElementsByTagName</strong></p><p>如下:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"checkbox"</span> <span class="attribute">name</span>=<span class="string">"hobby"</span> <span class="attribute">id</span>=<span class="string">"hobby1"</span>&gt;  音乐</span><br></pre></td></tr></table></figure><p>input标签就像人的类别。</p><p>name属性就像人的姓名。</p><p>id属性就像人的身份证。</p><p><img src="http://upload-images.jianshu.io/upload_images/3365001-8e867bd57639c203.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="方法总结"></p><p><strong>getAttribute()方法</strong></p><p>通过元素节点的属性名称获取属性的值。</p><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">elementNode.getAttribute(<span class="keyword">name</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. elementNode：使用getElementById()、getElementsByTagName()等方法，获取到的元素节点。</span></span><br><span class="line"><span class="comment">//2. name：要想查询的元素节点的属性名字</span></span><br></pre></td></tr></table></figure><p><strong>setAttribute()方法</strong></p><p>setAttribute() 方法增加一个指定名称和值的新属性，或者把一个现有的属性设定为指定的值。</p><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">elementNode.setAttribute(<span class="keyword">name</span>,<span class="keyword">value</span>)</span><br><span class="line">//<span class="number">1.</span><span class="keyword">name</span>: 要设置的属性名。</span><br><span class="line">//<span class="number">2.</span><span class="keyword">value</span>: 要设置的属性值。</span><br></pre></td></tr></table></figure><h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><p>在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ：</p><ol><li><p>nodeName : 节点的名称</p></li><li><p>nodeValue ：节点的值</p></li><li><p>nodeType ：节点的类型</p></li></ol><p>一、<strong>nodeName 属性</strong>: 节点的名称，是只读的。</p><ol><li>元素节点的 nodeName 与标签名相同</li><li>属性节点的 nodeName 是属性的名称</li><li>文本节点的 nodeName 永远是 #text</li><li>文档节点的 nodeName 永远是 #document</li></ol><p>二、<strong>nodeValue 属性</strong>：节点的值</p><ol><li>元素节点的 nodeValue 是 undefined 或 null</li><li>文本节点的 nodeValue 是文本自身</li><li>属性节点的 nodeValue 是属性的值</li></ol><p>三、<strong>nodeType 属性</strong>: 节点的类型，是只读的。以下常用的几种结点类型:</p><table><thead><tr><th>元素类型</th><th>节点类型</th></tr></thead><tbody><tr><td>  元素</td><td>1</td></tr><tr><td>  属性</td><td>2</td></tr><tr><td>  文本</td><td>3</td></tr><tr><td>  注释</td><td>8</td></tr><tr><td>  文档</td><td>9</td></tr></tbody></table><p><strong>访问子节点childNodes</strong></p><p>访问选定元素节点下的所有子节点的列表，返回的值可以看作是一个数组，他具有length属性。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">elementNode</span><span class="selector-class">.childNodes</span></span><br></pre></td></tr></table></figure><p>注意：如果选定的节点没有子节点，则该属性返回不包含节点的 NodeList。</p><p><strong>访问子节点的第一和最后项</strong></p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">node</span>.<span class="title">firstChild</span></span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">node</span>. <span class="title">lastChild</span></span><br></pre></td></tr></table></figure><p><strong>访问父节点parentNode</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">elementNode</span><span class="selector-class">.parentNode</span></span><br></pre></td></tr></table></figure><p>注意：父节点只能有一个。</p><p><strong>访问兄弟节点</strong></p><ol><li>nextSibling 属性可返回某个节点之后紧跟的节点（处于同一树层级中）。</li></ol><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">nodeObject</span><span class="selector-class">.nextSibling</span></span><br></pre></td></tr></table></figure><ol start="2"><li>previousSibling 属性可返回某个节点之前紧跟的节点（处于同一树层级中）。</li></ol><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">nodeObject</span><span class="selector-class">.previousSibling</span></span><br></pre></td></tr></table></figure><p>说明：如果无此节点，则该属性返回 null。</p><p>注意: 两个属性获取的是节点。Internet Explorer 会忽略节点间生成的空白文本节点（例如，换行符号），而其它浏览器不会忽略。</p><p>解决问题方法:</p><p>判断节点nodeType是否为1, 如是为元素节点，跳过。</p><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_nextSibling</span><span class="params">(n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> x=n.nextSibling;</span><br><span class="line"><span class="keyword">while</span> (x &amp;&amp; x.nodeType!=<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  x=x.nextSibling;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_previousSibling</span><span class="params">(n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> x=n.previousSibling;</span><br><span class="line"><span class="keyword">while</span> (x &amp;&amp; x.nodeType!=<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  x=x.previousSibling;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入节点appendChild()</strong></p><p>在指定节点的最后一个子节点列表之后添加一个新的子节点。</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">appendChild</span><span class="params">(newnode)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> otest = <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>);  </span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> newnode = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span></span><br><span class="line"><span class="actionscript">  newnode.innerHTML=<span class="string">"PHP"</span>;</span></span><br><span class="line"><span class="undefined">  otest.appendChild(newnode);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>插入节点insertBefore()</strong></p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">insertBefore(newnode,<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">//newnode</span>: 要插入的新节点。</span><br><span class="line">//<span class="keyword">node</span><span class="title">: 指定此节点前插入节点。</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> otest = <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>);  </span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> newnode = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span></span><br><span class="line"><span class="actionscript">  newnode.innerHTML = <span class="string">"PHP"</span>;</span></span><br><span class="line"><span class="undefined">  otest.insertBefore(newnode, otest.childNodes[1]);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>删除节点removeChild()</strong></p><p>removeChild() 方法从子节点列表中删除某个节点。如删除成功，此方法可返回被删除的节点，如失败，则返回 NULL。</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">nodeObject.removeChild(<span class="keyword">node</span><span class="title">)</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">clearText</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> content=<span class="built_in">document</span>.getElementById(<span class="string">"content"</span>);</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">for</span>(<span class="keyword">var</span> i=content.childNodes.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> dnode = content.childNodes[i];</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> x = content.removeChild(dnode);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.write(x.innerHTML+<span class="string">"&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"clearText()"</span>&gt;</span>清除节点内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意: 把删除的子节点赋值给 x，这个子节点不在DOM树中，但是还存在内存中，可通过 x 操作。</p><p>如果要完全删除对象，给 x 赋 null 值</p><p><strong>替换元素节点replaceChild()</strong></p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">node</span>.<span class="title">replaceChild</span> (newnode,oldnew )</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/3365001-c6e6f9517dc90ba2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>注意: </p><ol><li>当 oldnode 被替换时，所有与之相关的属性内容都将被移除。 </li><li>newnode 必须先被建立。 </li></ol><p><strong>创建元素节点createElement</strong></p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.createElement(tagName)</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> body = <span class="built_in">document</span>.body; </span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> input = <span class="built_in">document</span>.createElement(<span class="string">"input"</span>);  </span></span><br><span class="line"><span class="actionscript">   input.type = <span class="string">"button"</span>;  </span></span><br><span class="line"><span class="actionscript">   input.value = <span class="string">"创建一个按钮"</span>;  </span></span><br><span class="line"><span class="undefined">   body.appendChild(input);  </span></span><br><span class="line"><span class="undefined"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>创建文本节点createTextNode</strong></p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">document</span>.createTextNode(<span class="class"><span class="keyword">data</span>)</span></span><br><span class="line">//<span class="class"><span class="keyword">data</span> : 字符串值，可规定此节点的文本</span></span><br></pre></td></tr></table></figure><p><strong>浏览器窗口可视区域大小</strong></p><p>一、对于IE9+、Chrome、Firefox、Opera 以及 Safari：</p><p>•  window.innerHeight - 浏览器窗口的内部高度</p><p>•  window.innerWidth - 浏览器窗口的内部宽度</p><p>二、对于 Internet Explorer 8、7、6、5：</p><p>•  document.documentElement.clientHeight表示HTML文档所在窗口的当前高度。</p><p>•  document.documentElement.clientWidth表示HTML文档所在窗口的当前宽度。</p><p>或者</p><p>Document对象的body属性对应HTML文档的<body>标签</body></p><p>•  document.body.clientHeight</p><p>•  document.body.clientWidth</p><p><strong>在不同浏览器都实用的 JavaScript 方案：</strong></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w= <span class="built_in">document</span>.documentElement.clientWidth</span><br><span class="line">      || <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line"><span class="keyword">var</span> h= <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">      || <span class="built_in">document</span>.body.clientHeight;</span><br></pre></td></tr></table></figure><p><strong>网页尺寸scrollHeight</strong></p><p>scrollHeight和scrollWidth，获取网页内容高度和宽度。</p><p>一、针对IE、Opera:</p><p>scrollHeight 是网页内容实际高度，可以小于 clientHeight。</p><p>二、针对NS、FF:</p><p>scrollHeight 是网页内容高度，不过最小值是 clientHeight。也就是说网页内容实际高度小于 clientHeight 时，scrollHeight 返回 clientHeight 。</p><p>三、浏览器兼容性</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w=<span class="built_in">document</span>.documentElement.scrollWidth</span><br><span class="line">   || <span class="built_in">document</span>.body.scrollWidth;</span><br><span class="line"><span class="keyword">var</span> h=<span class="built_in">document</span>.documentElement.scrollHeight</span><br><span class="line">   || <span class="built_in">document</span>.body.scrollHeight;</span><br></pre></td></tr></table></figure><p><strong>网页尺寸offsetHeight</strong></p><p>offsetHeight和offsetWidth，获取网页内容高度和宽度(包括滚动条等边线，会随窗口的显示大小改变)。</p><p>一、值</p><p>offsetHeight = clientHeight + 滚动条 + 边框。</p><p>二、浏览器兼容性</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w= <span class="built_in">document</span>.documentElement.offsetWidth</span><br><span class="line">    || <span class="built_in">document</span>.body.offsetWidth;</span><br><span class="line"><span class="keyword">var</span> h= <span class="built_in">document</span>.documentElement.offsetHeight</span><br><span class="line">    || <span class="built_in">document</span>.body.offsetHeight;</span><br></pre></td></tr></table></figure><p><strong>网页卷去的距离与偏移量</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/3365001-2eecab2a4ba5704b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>scrollLeft:设置或获取位于给定对象左边界与窗口中目前可见内容的最左端之间的距离 ，即左边灰色的内容。</p><p>scrollTop:设置或获取位于对象最顶端与窗口中可见内容的最顶端之间的距离 ，即上边灰色的内容。</p><p>offsetLeft:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 。</p><p>offsetTop:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算顶端位置 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JS 用法、注释；&lt;/li&gt;
&lt;li&gt;变量、判断语句、函数；&lt;/li&gt;
&lt;li&gt;输出内容（document.write）；&lt;/li&gt;
&lt;li&gt;对话框（dialog）；&lt;/li&gt;
&lt;li&gt;窗口（window）；&lt;/l
      
    
    </summary>
    
      <category term="JS" scheme="http://jovelin.cn/categories/JS/"/>
    
    
      <category term="JS" scheme="http://jovelin.cn/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>CSS 样式</title>
    <link href="http://jovelin.cn/2018/07/30/CSS%20%E4%B9%8B%20Position%20%E8%AF%A6%E8%A7%A3/"/>
    <id>http://jovelin.cn/2018/07/30/CSS 之 Position 详解/</id>
    <published>2018-07-30T01:00:01.000Z</published>
    <updated>2018-07-31T01:45:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>relative；</li><li>absolute；</li><li>fixed；</li><li>static；</li><li>z-index 属性。</li></ol></blockquote><a id="more"></a><h3 id="Position-属性定义"><a href="#Position-属性定义" class="headerlink" title="Position 属性定义"></a>Position 属性定义</h3><h4 id="我们先来看看-CSS3-Api-中对-position-属性的相关定义："><a href="#我们先来看看-CSS3-Api-中对-position-属性的相关定义：" class="headerlink" title="我们先来看看 CSS3 Api 中对 position 属性的相关定义："></a>我们先来看看 CSS3 Api 中对 position 属性的相关定义：</h4><ul><li>static：无特殊定位，对象遵循正常文档流。top，right，bottom，left 等属性不会被应用。</li><li>relative：对象遵循正常文档流，但将依据 top，right，bottom，left 等属性在正常文档流中偏移位置。而其层叠通过 z-index 属性定义。</li><li>absolute：对象脱离正常文档流，使用 top，right，bottom，left 等属性进行绝对定位。而其层叠通过 z-index 属性定义。</li><li>fixed：对象脱离正常文档流，使用 top，right，bottom，left 等属性以窗口为参考点进行定位，当出现滚动条时，对象不会随着滚动。而其层叠通过 z-index 属性定义。</li></ul><h4 id="什么是文档流？"><a href="#什么是文档流？" class="headerlink" title="什么是文档流？"></a>什么是文档流？</h4><ul><li>将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素,即为文档流。</li><li>只有三种情况会使得元素脱离文档流，分别是：浮动、绝对定位和相对定位。</li></ul><h3 id="Position-属性理解"><a href="#Position-属性理解" class="headerlink" title="Position 属性理解"></a>Position 属性理解</h3><p>CSS 的很多其他属性大多容易理解，比如字体，文本，背景等。有些 CSS 书籍也会对这些简单的属性进行大张旗鼓的介绍，而偏偏忽略了对一些难缠的属性讲解，有避重就轻的嫌疑。CSS 中主要难以理解的属性包括盒型结构，以及定位。正如 position is every thing，本文将主要讲述关于 position 的理解，力求让您看完本文后对 position 有着最全面的认识。</p><p>position 的四个属性值：</p><ol><li>relative</li><li>absolute</li><li>fixed</li><li>static</li></ol><p>下面分别讲述这四个属性：</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"parent"</span>&gt;</span><br><span class="line">     &lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"sub1"</span>&gt;sub1&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">     &lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"sub2"</span>&gt;sub2&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="1-relative"><a href="#1-relative" class="headerlink" title="1. relative"></a>1. relative</h3><p>relative 属性相对比较简单，我们要搞清它是相对哪个对象来进行偏移的。答案是它本身的位置。在上面的代码中，sub1 和 sub2 是同级关系，如果设定 sub1 一个 relative 属性，比如设置如下 CSS 代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#sub1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以这样理解，如果不设置 relative 属性，sub1 的位置按照正常的文档流，它应该处于某个位置。但当设置 sub1 的 position 为 relative 后，将根据 top，right，bottom，left 的值按照它<strong>理应所在</strong>的位置进行偏移，relative 的“相对的”意思也正体现于此。</p><p>对于此，您只需要记住，sub1 如果不设置 relative 时它应该在哪里，一旦设置后就按照它理应在的位置进行偏移。</p><p>随后的问题是，sub2 的位置又在哪里呢？<br>答案是它原来在哪里，现在就在哪里，它的位置不会因为 sub1 增加了 position 的属性而发生改变。</p><p>如果此时把 sub2 的 position 也设置为 relative，会发生什么现象？此时依然和sub1一样，按照它原来应有的位置进行偏移。</p><blockquote><p>注意：relative 的偏移是基于对象的 margin 的左上侧的。</p></blockquote><h3 id="2-absolute"><a href="#2-absolute" class="headerlink" title="2. absolute"></a>2. absolute</h3><p>这个属性总是有人给出误导。说当 position 属性设为 absolute 后，总是按照浏览器窗口来进行定位的，这其实是错误的。实际上，这是 fixed 属性的特点。</p><p>当 sub1 的 position 设置为 absolute 后，其到底以谁为对象进行偏移呢？这里分为两种情况：</p><p>（1）当 sub1 的父对象(或曾祖父，只要是父级对象) parent 也设置了 position 属性，且 position 的属性值为 absolute 或者 relative 时，也就是说，不是默认值的情况，此时 sub1 按照这个 parent 来进行定位。</p><p>注意：对象虽然确定好了，但有些细节需要您的注意，那就是我们到底以 parent 的哪个定位点来进行定位呢？如果 parent 设定了 margin，border，padding 等属性，那么这个定位点将忽略 padding，将会从 padding 开始的地方(即只从 padding 的左上角开始)进行定位，这与我们会想当然的以为会以 margin 的左上端开始定位的想法是不同的。</p><blockquote><p>说明：当使用 absolute 或 fixed 定位时，必须指定 left、right、top、bottom  属性中的至少一个，否则 left/right/top/bottom 属性会使用它们的默认值 auto ，这将导致对象遵从正常的 HTML 布局规则，在前一个对象之后立即被呈递，简单讲就是都变成 relative，会占用文档空间 所以你的 sub1 没有脱离文档所以看到其实是 relative 的效果 设置 left/right/top/bottom 中任意一个后再看就是 absolute 的效果啦 即以祖先元素的边框定位！</p></blockquote><p>接下来的问题是，sub2 的位置到哪里去了呢？由于当 position 设置为 absolute 后，会导致 sub1 溢出正常的文档流，就像它不属于 parent 一样，它漂浮了起来，在 DreamWeaver 中把它称为“层”，其实意思是一样的。此时 sub2 将获得 sub1 的位置，它的文档流不再基于 sub1，而是直接从 parent 开始。</p><p>（2）如果 sub1 不存在一个有着 position 属性的父对象，那么那就会以 body 为定位对象，按照浏览器的窗口进行定位，这个比较容易理解。</p><h3 id="3-fixed"><a href="#3-fixed" class="headerlink" title="3. fixed"></a>3. fixed</h3><p>fixed 是特殊的 absolute，即 fixed 总是以 body 为定位对象的，按照浏览器的窗口进行定位。</p><h3 id="4-static"><a href="#4-static" class="headerlink" title="4. static"></a>4. static</h3><p>position 的默认值，一般不设置 position 属性时，会按照正常的文档流进行排列。</p><h3 id="5-z-index-属性"><a href="#5-z-index-属性" class="headerlink" title="5. z-index 属性"></a>5. z-index 属性</h3><p>z-index，又称为对象的层叠顺序，它用一个整数来定义堆叠的层次，整数值越大，则被层叠在越上面，当然这是指同级元素间的堆叠，如果两个对象的此属性具有同样的值，那么将依据它们在 HTML 文档中流的顺序层叠，写在后面的将会覆盖前面的。需要注意的是，父子关系是无法用 z-index 来设定上下关系的，一定是子级在上父级在下。</p><blockquote><p>Note：使用 static 定位或无 position 定位的元素 z-index 属性是无效的。</p></blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.csdn.net/chen_zw/article/details/8741365" target="_blank" rel="noopener">CSS中position属性( absolute | relative | static | fixed )详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;relative；&lt;/li&gt;
&lt;li&gt;absolute；&lt;/li&gt;
&lt;li&gt;fixed；&lt;/li&gt;
&lt;li&gt;static；&lt;/li&gt;
&lt;li&gt;z-index 属性。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="HTML" scheme="http://jovelin.cn/categories/HTML/"/>
    
      <category term="CSS" scheme="http://jovelin.cn/categories/HTML/CSS/"/>
    
    
      <category term="HTML" scheme="http://jovelin.cn/tags/HTML/"/>
    
      <category term="CSS" scheme="http://jovelin.cn/tags/CSS/"/>
    
      <category term="Position" scheme="http://jovelin.cn/tags/Position/"/>
    
  </entry>
  
  <entry>
    <title>CSS 样式</title>
    <link href="http://jovelin.cn/2018/07/29/CSS%20%E6%A0%B7%E5%BC%8F/"/>
    <id>http://jovelin.cn/2018/07/29/CSS 样式/</id>
    <published>2018-07-29T01:00:01.000Z</published>
    <updated>2018-07-31T01:45:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>CSS 选择器；</li><li>CSS 继承、特殊性、层叠；</li><li>CSS 格式化排版；</li><li>CSS 元素分类；</li><li>CSS 盒模型；</li><li>CSS 布局模型。</li></ol></blockquote><a id="more"></a><h3 id="一、CSS-选择器"><a href="#一、CSS-选择器" class="headerlink" title="一、CSS 选择器"></a>一、CSS 选择器</h3><h4 id="1、类和-ID-选择器的区别"><a href="#1、类和-ID-选择器的区别" class="headerlink" title="1、类和 ID 选择器的区别"></a>1、类和 ID 选择器的区别</h4><p>相同点：可以应用于任何元素</p><p>不同点：</p><p>1、ID选择器只能在文档中使用一次。与类选择器不同，在一个HTML文档中，ID选择器只能使用一次，而且仅一次。而类选择器可以使用多次。</p><p>2、可以使用类选择器词列表方法为一个元素同时设置多个样式。我们可以为一个元素同时设多个样式，但只可以用类选择器的方法实现，ID选择器是不可以的（不能使用 ID 词列表）。</p><h4 id="2、子选择器"><a href="#2、子选择器" class="headerlink" title="2、子选择器"></a>2、子选择器</h4><p>子选择器，即大于符号(&gt;),用于选择指定标签元素的第一代子元素。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.first</span>&gt;<span class="selector-tag">span</span>&#123;<span class="attribute">border</span>:<span class="number">1px</span> solid red;&#125;</span><br></pre></td></tr></table></figure><h4 id="3、包含-后代-选择器"><a href="#3、包含-后代-选择器" class="headerlink" title="3、包含(后代)选择器"></a>3、包含(后代)选择器</h4><p>包含选择器，即加入空格,用于选择指定标签元素下的后辈元素。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.first</span> <span class="selector-tag">span</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：[子选择器] &gt; 作用于元素的第一代后代，[后代选择器] 空格 作用于元素的所有后代。</strong></p><h4 id="4、通用选择器"><a href="#4、通用选择器" class="headerlink" title="4、通用选择器"></a>4、通用选择器</h4><p>通用选择器是功能最强大的选择器，它使用一个（*）号指定，它的作用是匹配html中所有标签元素，如下使用下面代码使用html中任意标签元素字体颜色全部设置为红色：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5、伪类选择符"><a href="#5、伪类选择符" class="headerlink" title="5、伪类选择符"></a>5、伪类选择符</h4><p>更有趣的是伪类选择符，为什么叫做伪类选择符，它允许给html不存在的标签（标签的某种状态）设置样式，比如说我们给html中一个标签元素的鼠标滑过的状态来设置字体颜色：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6、分组选择符"><a href="#6、分组选择符" class="headerlink" title="6、分组选择符"></a>6、分组选择符</h4><p>当你想为html中多个标签元素设置同一个样式时，可以使用分组选择符（，），如下代码为右侧代码编辑器中的h1、span标签同时设置字体颜色为红色：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">span</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二、CSS-继承、特殊性、层叠"><a href="#二、CSS-继承、特殊性、层叠" class="headerlink" title="二、CSS 继承、特殊性、层叠"></a>二、CSS 继承、特殊性、层叠</h3><h4 id="1、继承"><a href="#1、继承" class="headerlink" title="1、继承"></a>1、继承</h4><p>继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。</p><h4 id="2、特殊性"><a href="#2、特殊性" class="headerlink" title="2、特殊性"></a>2、特殊性</h4><p>有的时候我们为同一个元素设置了不同的CSS样式代码，那么元素会启用哪一个CSS样式呢? <strong>权值</strong></p><p>权值规则：</p><p><strong>标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。</strong> 例如下面的代码：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:red;&#125; <span class="comment">/*权值为1*/</span></span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span>&#123;<span class="attribute">color</span>:green;&#125; <span class="comment">/*权值为1+1=2*/</span></span><br><span class="line"><span class="selector-class">.warning</span>&#123;<span class="attribute">color</span>:white;&#125; <span class="comment">/*权值为10*/</span></span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span><span class="selector-class">.warning</span>&#123;<span class="attribute">color</span>:purple;&#125; <span class="comment">/*权值为1+1+10=12*/</span></span><br><span class="line"><span class="selector-id">#footer</span> <span class="selector-class">.note</span> <span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:yellow;&#125; <span class="comment">/*权值为100+10+1=111*/</span></span><br></pre></td></tr></table></figure></p><p><strong>注意：还有一个权值比较特殊–继承也有权值但很低，有的文献提出它只有0.1，所以可以理解为继承的权值最低。</strong></p><h4 id="3、层叠"><a href="#3、层叠" class="headerlink" title="3、层叠"></a>3、层叠</h4><p>如果在html文件中对于同一个元素可以有多个css样式存在并且这多个css样式具有相同权重值怎么办？<strong>层叠</strong></p><p>层叠很好理解，后面的样式会覆盖前面的样式。</p><p><strong>内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。</strong></p><h4 id="4、重要性"><a href="#4、重要性" class="headerlink" title="4、重要性"></a>4、重要性</h4><p>我们在做网页代码的时，有些特殊的情况需要为某些样式设置具有最高权值，怎么办？这时候我们可以使用!important来解决。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:red<span class="meta">!important</span>;&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:green;&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：!important要写在分号的前面</strong></p><p>样式优先级为：<strong>浏览器默认的样式 &lt; 网页制作者样式 &lt; 用户自己设置的样式</strong>，但记住!important优先级样式是个例外，权值高于用户自己设置的样式。</p><h3 id="三、CSS-格式化排版"><a href="#三、CSS-格式化排版" class="headerlink" title="三、CSS 格式化排版"></a>三、CSS 格式化排版</h3><h4 id="文字排版–字体"><a href="#文字排版–字体" class="headerlink" title="文字排版–字体"></a>文字排版–字体</h4><p>注意不要设置不常用的字体，因为如果用户本地电脑上如果没有安装你设置的字体，就会显示浏览器默认的字体。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">font-family</span>:<span class="string">"Microsoft Yahei"</span>;&#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">font-family</span>:<span class="string">"微软雅黑"</span>;&#125;</span><br><span class="line"></span><br><span class="line">注意：第一种方法比第二种方法兼容性更好一些。</span><br></pre></td></tr></table></figure></p><h4 id="文字排版–字号、颜色"><a href="#文字排版–字号、颜色" class="headerlink" title="文字排版–字号、颜色"></a>文字排版–字号、颜色</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">font-size</span>:<span class="number">12px</span>;<span class="attribute">color</span>:<span class="number">#666</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="文字排版–粗体"><a href="#文字排版–粗体" class="headerlink" title="文字排版–粗体"></a>文字排版–粗体</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span>&#123;<span class="attribute">font-weight</span>:bold;&#125;</span><br></pre></td></tr></table></figure><h4 id="文字排版–斜体"><a href="#文字排版–斜体" class="headerlink" title="文字排版–斜体"></a>文字排版–斜体</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span>&#123;<span class="attribute">font-style</span>:italic;&#125;</span><br></pre></td></tr></table></figure><h4 id="文字排版–下划线"><a href="#文字排版–下划线" class="headerlink" title="文字排版–下划线"></a>文字排版–下划线</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span>&#123;<span class="attribute">text-decoration</span>:underline;&#125;</span><br></pre></td></tr></table></figure><h4 id="文字排版–删除线"><a href="#文字排版–删除线" class="headerlink" title="文字排版–删除线"></a>文字排版–删除线</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.oldPrice</span>&#123;<span class="attribute">text-decoration</span>:line-through;&#125;</span><br></pre></td></tr></table></figure><h4 id="段落排版–缩进"><a href="#段落排版–缩进" class="headerlink" title="段落排版–缩进"></a>段落排版–缩进</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">text-indent</span>:<span class="number">2em</span>;&#125;</span><br></pre></td></tr></table></figure><h4 id="段落排版–行间距（行高）"><a href="#段落排版–行间距（行高）" class="headerlink" title="段落排版–行间距（行高）"></a>段落排版–行间距（行高）</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">line-height</span>:<span class="number">1.5em</span>;&#125;</span><br></pre></td></tr></table></figure><h4 id="段落排版–中文字间距、字母间距"><a href="#段落排版–中文字间距、字母间距" class="headerlink" title="段落排版–中文字间距、字母间距"></a>段落排版–中文字间距、字母间距</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">中文字间隔、字母间隔设置：</span><br><span class="line"><span class="selector-tag">h1</span>&#123;<span class="attribute">letter-spacing</span>:<span class="number">50px</span>;&#125;</span><br><span class="line"></span><br><span class="line">单词间距设置：</span><br><span class="line"><span class="selector-tag">h1</span>&#123;<span class="attribute">word-spacing</span>:<span class="number">50px</span>;&#125;</span><br></pre></td></tr></table></figure><h4 id="段落排版–对齐"><a href="#段落排版–对齐" class="headerlink" title="段落排版–对齐"></a>段落排版–对齐</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&#123;<span class="attribute">text-align</span>:center;&#125;</span><br></pre></td></tr></table></figure><h3 id="四、CSS-元素分类"><a href="#四、CSS-元素分类" class="headerlink" title="四、CSS 元素分类"></a>四、CSS 元素分类</h3><p>在CSS中，html中的标签元素大体被分为三种不同的类型：<strong>块状元素、内联元素(又叫行内元素)和内联块状元素。</strong></p><p><strong>常用的块状元素有：</strong><br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>、<span class="tag">&lt;<span class="name">p</span>&gt;</span>、<span class="tag">&lt;<span class="name">h1</span>&gt;</span>...<span class="tag">&lt;<span class="name">h6</span>&gt;</span>、<span class="tag">&lt;<span class="name">ol</span>&gt;</span>、<span class="tag">&lt;<span class="name">ul</span>&gt;</span>、<span class="tag">&lt;<span class="name">dl</span>&gt;</span>、</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span>、<span class="tag">&lt;<span class="name">address</span>&gt;</span>、<span class="tag">&lt;<span class="name">blockquote</span>&gt;</span> 、<span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>常用的内联元素有：</strong><br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>、<span class="tag">&lt;<span class="name">span</span>&gt;</span>、<span class="tag">&lt;<span class="name">br</span>&gt;</span>、<span class="tag">&lt;<span class="name">i</span>&gt;</span>、<span class="tag">&lt;<span class="name">em</span>&gt;</span>、<span class="tag">&lt;<span class="name">strong</span>&gt;</span>、</span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>、<span class="tag">&lt;<span class="name">q</span>&gt;</span>、<span class="tag">&lt;<span class="name">var</span>&gt;</span>、<span class="tag">&lt;<span class="name">cite</span>&gt;</span>、<span class="tag">&lt;<span class="name">code</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>常用的内联块状元素有：</strong><br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span>&gt;</span>、<span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="元素分类–块级元素"><a href="#元素分类–块级元素" class="headerlink" title="元素分类–块级元素"></a>元素分类–块级元素</h4><p>什么是块级元素？</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">在html中<span class="tag">&lt;<span class="name">div</span>&gt;</span>、<span class="tag">&lt;<span class="name">p</span>&gt;</span>、<span class="tag">&lt;<span class="name">h1</span>&gt;</span>、<span class="tag">&lt;<span class="name">form</span>&gt;</span>、<span class="tag">&lt;<span class="name">ul</span>&gt;</span> 和 <span class="tag">&lt;<span class="name">li</span>&gt;</span>就是块级元素。</span><br></pre></td></tr></table></figure><p>设置display:block就是将元素显示为块级元素。如下代码就是将内联元素a转换为块状元素，从而使a元素具有块状元素特点。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span>&#123;<span class="attribute">display</span>:block;&#125;</span><br></pre></td></tr></table></figure></p><p><strong>块级元素特点：</strong></p><p>1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行）</p><p>2、元素的高度、宽度、行高以及顶和底边距都可设置。</p><p>3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。</p><h4 id="元素分类–内联元素"><a href="#元素分类–内联元素" class="headerlink" title="元素分类–内联元素"></a>元素分类–内联元素</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">在html中，<span class="tag">&lt;<span class="name">span</span>&gt;</span>、<span class="tag">&lt;<span class="name">a</span>&gt;</span>、<span class="tag">&lt;<span class="name">label</span>&gt;</span>、 <span class="tag">&lt;<span class="name">strong</span>&gt;</span></span><br><span class="line">和<span class="tag">&lt;<span class="name">em</span>&gt;</span>就是典型的内联元素（行内元素）（inline）元素。</span><br></pre></td></tr></table></figure><p>当然块状元素也可以通过代码display:inline将元素设置为内联元素。如下代码就是将块状元素div转换为内联元素，从而使 div 元素具有内联元素特点。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">display</span>:inline;&#125;</span><br></pre></td></tr></table></figure><p><strong>内联元素特点：</strong></p><p>1、和其他元素都在一行上；</p><p>2、元素的高度、宽度及顶部和底部边距不可设置；</p><p>3、元素的宽度就是它包含的文字或图片的宽度，不可改变。</p><h4 id="元素分类–内联块状元素"><a href="#元素分类–内联块状元素" class="headerlink" title="元素分类–内联块状元素"></a>元素分类–内联块状元素</h4><p>内联块状元素（inline-block）就是同时具备内联元素、块状元素的特点，代码display:inline-block就是将元素设置为内联块状元素。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span>&#123;<span class="attribute">display</span>:inline-block;&#125;</span><br></pre></td></tr></table></figure><p>inline-block 元素特点：</p><p>1、和其他元素都在一行上；</p><p>2、元素的高度、宽度、行高以及顶和底边距都可设置。</p><h3 id="五、CSS-盒模型"><a href="#五、CSS-盒模型" class="headerlink" title="五、CSS 盒模型"></a>五、CSS 盒模型</h3><p>盒子模型的边框就是围绕着内容及补白的线，这条线你可以设置它的粗细、样式和颜色(边框三个属性)。</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">border</span>:<span class="number">2px</span> solid red;&#125;</span><br><span class="line"></span><br><span class="line">dashed（虚线）、dotted（点线）、solid（实线）。</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">单独设置下边框</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">border-bottom</span>:<span class="number">1px</span> solid red;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">上、右、下、左</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">margin</span>:<span class="number">20px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">30px</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="六、CSS-布局模型"><a href="#六、CSS-布局模型" class="headerlink" title="六、CSS 布局模型"></a>六、CSS 布局模型</h3><p>布局模型与盒模型一样都是 CSS 最基本、 最核心的概念。 但布局模型是建立在盒模型基础之上，又不同于我们常说的 CSS 布局样式或 CSS 布局模板。如果说布局模型是本，那么 CSS 布局模板就是末了，是外在的表现形式。</p><p>CSS 包含 3 种基本的布局模型，用英文概括为：Flow、Layer 和 Float。</p><p>在网页中，元素有三种布局模型：</p><p>1、流动模型（Flow）</p><p>2、浮动模型 (Float)</p><p>3、层模型（Layer）</p><h4 id="流动模型"><a href="#流动模型" class="headerlink" title="流动模型"></a>流动模型</h4><p>流动模型，流动（Flow）是默认的网页布局模式。</p><p>特征：</p><p>1.块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。</p><p>2.内联元素都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行）</p><h4 id="浮动模型"><a href="#浮动模型" class="headerlink" title="浮动模型"></a>浮动模型</h4><p>任何元素在默认情况下是不能浮动的，但可以用 CSS 定义为浮动，如 div、p、table、img 等元素都可以被定义为浮动。如下代码可以实现两个 div 元素一行显示。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> red solid;</span><br><span class="line">    <span class="attribute">float</span>:left;<span class="comment">/*左浮动*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层模型"><a href="#层模型" class="headerlink" title="层模型"></a>层模型</h4><p>三种形式：</p><p>1、绝对定位(position: absolute)</p><p>2、相对定位(position: relative)</p><p>相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，<strong>偏移前的位置保留不动</strong>。</p><p>3、固定定位(position: fixed)</p><blockquote><p>详情可见：<a href="http://note.youdao.com/noteshare?id=57a8413c683df412462bc6066a841d95" target="_blank" rel="noopener">CSS 之 Position 详解</a></p></blockquote><h5 id="水平居中总结-不定宽块状元素方法"><a href="#水平居中总结-不定宽块状元素方法" class="headerlink" title="水平居中总结-不定宽块状元素方法"></a>水平居中总结-不定宽块状元素方法</h5><p>不定宽度的块状元素有三种方法居中（这三种方法目前使用的都很多）：</p><ul><li><p>1.加入 table 标签</p></li><li><p>2.设置 display: inline 方法：与第一种类似，显示类型设为 行内元素，进行不定宽元素的属性设置</p></li><li><p>3.设置 position:relative 和 left:50%：利用 相对定位 的方式，将元素向左偏移 50% ，即达到居中的目的</p></li></ul><p>方法一：</p><p>第一步：为需要设置的居中的元素外面加入一个 table 标签 ( 包括 <tbody>、<tr>、<td> )。</td></tr></tbody></p><p>第二步：为这个 table 设置“左右 margin 居中”（这个和定宽块状元素的方法一样）。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">table&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">margin</span><span class="selector-pseudo">:0</span> <span class="selector-tag">auto</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是第一行文本<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方法二：</p><p>改变块级元素的 display 为 inline 类型（设置为 行内元素 显示），然后使用 text-align:center 来实现居中效果。如下例子：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.container</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="comment">/* margin:0;padding:0（消除文本与div边框之间的间隙）*/</span></span></span><br><span class="line"><span class="css"><span class="selector-class">.container</span> <span class="selector-tag">ul</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">list-style</span><span class="selector-pseudo">:none</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">margin</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">padding</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">display</span><span class="selector-pseudo">:inline</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="comment">/* margin-right:8px（设置li文本之间的间隔）*/</span></span></span><br><span class="line"><span class="css"><span class="selector-class">.container</span> <span class="selector-tag">li</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">margin-right</span><span class="selector-pseudo">:8px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">display</span><span class="selector-pseudo">:inline</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方法相比第一种方法的优势是不用增加无语义标签，但也存在着一些问题：它将块状元素的 display 类型改为 inline，变成了行内元素，所以少了一些功能，比如设定长度值。</p><p>方法三：通过给父元素设置 float，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。</p><p>我们可以这样理解：假想ul层的父层（即下面例子中的div层）中间有条平分线将ul层的父层（div层）平均分为两份，ul层的css代码是将ul层的最左端与ul层的父层（div层）的平分线对齐；而li层的css代码则是将li层的平分线与ul层的最左端（也是div层的平分线）对齐，从而实现li层的居中。</p><p>代码如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.container</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">left</span><span class="selector-pseudo">:50</span>%</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.container</span> <span class="selector-tag">ul</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">list-style</span><span class="selector-pseudo">:none</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">margin</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">padding</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">left</span><span class="selector-pseudo">:-50</span>%;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.container</span> <span class="selector-tag">li</span>&#123;<span class="attribute">float</span>:left;<span class="attribute">display</span>:inline;<span class="attribute">margin-right</span>:<span class="number">8px</span>;&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这三种方法使用得都非常广泛，各有优缺点，具体选用哪种方法，可以视具体情况而定。</p><h5 id="垂直居中-父元素高度确定的单行文本"><a href="#垂直居中-父元素高度确定的单行文本" class="headerlink" title="垂直居中-父元素高度确定的单行文本"></a>垂直居中-父元素高度确定的单行文本</h5><p>父元素高度确定的单行文本的竖直居中的方法是通过设置父元素的 height 和 line-height 高度一致来实现的。(height: 该元素的高度，line-height: 顾名思义，行高（行间距），指在文本中，行与行之间的 基线间的距离 )。</p><p>line-height 与 font-size 的计算值之差，在 CSS 中成为“行间距”。分为两半，分别加到一个文本行内容的顶部和底部。</p><p>弊端：当文字内容的长度大于块的宽时，就有内容脱离了块。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.container</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">line-height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>:<span class="selector-id">#999</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    hi,imooc!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="垂直居中-父元素高度确定的多行文本"><a href="#垂直居中-父元素高度确定的多行文本" class="headerlink" title="垂直居中-父元素高度确定的多行文本"></a>垂直居中-父元素高度确定的多行文本</h5><p>方法一：使用插入 table  (包括tbody、tr、td)标签，同时设置 vertical-align：middle。</p><p>css 中有一个用于竖直居中的属性 vertical-align，在父元素设置此样式时，会对inline-block类型的子元素都有用。下面看一下例子：</p><p>css 中有一个用于竖直居中的属性 vertical-align，在父元素设置此样式时，会对inline-block类型的子元素都有用。下面看一下例子：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">table td&#123;height:500px;background:#ccc&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="tag">&lt;<span class="name">tbody</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>看我是否可以居中。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为 td 标签默认情况下就默认设置了 vertical-align 为 middle，所以我们不需要显式地设置了。</p><p>方法二：</p><p>在 chrome、firefox 及 IE8 以上的浏览器下可以设置块级元素的 display 为 table-cell（设置为表格单元显示），激活 vertical-align 属性，但注意 IE6、7 并不支持这个样式, 兼容性比较差。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.container</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:300px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>:<span class="selector-id">#ccc</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">display</span><span class="selector-pseudo">:table-cell</span>;<span class="comment">/*IE8以上及Chrome、Firefox*/</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">vertical-align</span><span class="selector-pseudo">:middle</span>;<span class="comment">/*IE8以上及Chrome、Firefox*/</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="隐性改变display类型"><a href="#隐性改变display类型" class="headerlink" title="隐性改变display类型"></a>隐性改变display类型</h5><p>有一个有趣的现象就是当为元素（不论之前是什么类型元素，display:none 除外）设置以下 2 个句之一：</p><ol><li><p>position : absolute</p></li><li><p>float : left 或 float:right</p></li></ol><p>简单来说，只要html代码中出现以上两句之一，元素的display显示类型就会自动变为以 display:inline-block（块状元素）的方式显示，当然就可以设置元素的 width 和 height 了，且默认宽度不占满父元素。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CSS 选择器；&lt;/li&gt;
&lt;li&gt;CSS 继承、特殊性、层叠；&lt;/li&gt;
&lt;li&gt;CSS 格式化排版；&lt;/li&gt;
&lt;li&gt;CSS 元素分类；&lt;/li&gt;
&lt;li&gt;CSS 盒模型；&lt;/li&gt;
&lt;li&gt;CSS 布局模型。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="HTML" scheme="http://jovelin.cn/categories/HTML/"/>
    
      <category term="CSS" scheme="http://jovelin.cn/categories/HTML/CSS/"/>
    
    
      <category term="HTML" scheme="http://jovelin.cn/tags/HTML/"/>
    
      <category term="CSS" scheme="http://jovelin.cn/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTML 标签</title>
    <link href="http://jovelin.cn/2018/07/28/HTML%20%E6%A0%87%E7%AD%BE/"/>
    <id>http://jovelin.cn/2018/07/28/HTML 标签/</id>
    <published>2018-07-28T01:00:01.000Z</published>
    <updated>2018-07-31T01:42:12.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>什么是 HTML；</li><li>HTML 元素；</li><li>HTML 属性；</li><li>HTML 标签。</li></ol></blockquote><a id="more"></a><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h3 id="1-什么是-HTML"><a href="#1-什么是-HTML" class="headerlink" title="1. 什么是 HTML"></a>1. 什么是 HTML</h3><ul><li>HTML 是用来描述网页的一种语言</li><li>HTML 指的是超文本标记语言 (Hyper Text Markup Language)</li><li>HTML 不是一种编程语言，而是一种标记语言 (markup language)</li><li>标记语言是一套标记标签 (markup tag)</li><li>HTML 使用标记标签来描述网页<br>第一个HTML文件<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span>&gt;</span> My First Heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span> 我的第一段文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span> HTML5 特有</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> 与 <span class="tag">&lt;/<span class="name">html</span>&gt;</span> 之间的文本描述网页</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> 与 <span class="tag">&lt;/<span class="name">body</span>&gt;</span> 之间的文本是可见的页面内容</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> 与 <span class="tag">&lt;/<span class="name">h1</span>&gt;</span> 之间的文本被显示为标题</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> 与 <span class="tag">&lt;/<span class="name">p</span>&gt;</span> 之间的文本被显示为段落</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span> 编码</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-HTML-元素"><a href="#2-HTML-元素" class="headerlink" title="2. HTML 元素"></a>2. HTML 元素</h3><ul><li>HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。</li><li>开始标签开放标签（opening tag），结束标签闭合标签（closing tag）</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is my first paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> 元素</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> 元素定义了整个 HTML 文档。</span><br><span class="line">这个元素拥有一个开始标签 <span class="tag">&lt;<span class="name">html</span>&gt;</span>，以及一个结束标签 <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> 元素</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> 元素定义了 HTML 文档的主体。</span><br><span class="line">这个元素拥有一个开始标签 <span class="tag">&lt;<span class="name">body</span>&gt;</span>，以及一个结束标签 <span class="tag">&lt;/<span class="name">body</span>&gt;</span>。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> 元素</span><br><span class="line">这个 <span class="tag">&lt;<span class="name">p</span>&gt;</span> 元素定义了 HTML 文档中的一个段落。</span><br><span class="line">这个元素拥有一个开始标签 <span class="tag">&lt;<span class="name">p</span>&gt;</span>，以及一个结束标签 <span class="tag">&lt;/<span class="name">p</span>&gt;</span>。</span><br></pre></td></tr></table></figure><h3 id="3-HTML-属性"><a href="#3-HTML-属性" class="headerlink" title="3. HTML 属性"></a>3. HTML 属性</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">属性为 HTML 元素提供附加信息</span><br><span class="line">HTML 标签可以拥有属性。属性提供了有关 HTML 元素的更多的信息。</span><br><span class="line">属性总是以名称/值对的形式出现，比如：name="value"。</span><br><span class="line">属性总是在 HTML 元素的开始标签中规定。</span><br><span class="line"></span><br><span class="line">属性例子</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> 定义标题的开始。</span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span> 拥有关于对齐方式的附加信息</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> 定义 HTML 文档的主体。</span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">"yellow"</span>&gt;</span> 拥有关于背景颜色的附加信息。</span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--注释的内容--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-HTML-标签"><a href="#4-HTML-标签" class="headerlink" title="4. HTML 标签"></a>4. HTML 标签</h3><h4 id="HTML-标题"><a href="#HTML-标题" class="headerlink" title="HTML 标题"></a>HTML 标题</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">HTML 标题（Heading）是通过 <span class="tag">&lt;<span class="name">h1</span>&gt;</span> - <span class="tag">&lt;<span class="name">h6</span>&gt;</span> 等标签进行定义的。</span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">h2</span>&gt;</span>标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">h3</span>&gt;</span>标题3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">h4</span>&gt;</span>标题4<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">h5</span>&gt;</span>标题5<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">h6</span>&gt;</span>标题6<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">水平线 <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span> 标签在 HTML 页面中创建水平线。</span><br><span class="line">hr 元素可用于分隔内容。</span><br><span class="line"></span><br><span class="line">字体标签</span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">"4"</span> <span class="attr">color</span>=<span class="string">"#0088FF"</span>&gt;</span>我的字体的设置<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"></span><br><span class="line">文本</span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>加粗<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>斜体<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>加下划线<span class="tag">&lt;/<span class="name">u</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span>加删除线<span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="HTML-段落"><a href="#HTML-段落" class="headerlink" title="HTML 段落"></a>HTML 段落</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">HTML 段落是通过 <span class="tag">&lt;<span class="name">p</span>&gt;</span> 标签进行定义的。</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落1 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">HTML 折行</span><br><span class="line">如果您希望在不产生一个新段落的情况下进行换行（新行），请使用 <span class="tag">&lt;<span class="name">br</span> /&gt;</span> 标签</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is<span class="tag">&lt;<span class="name">br</span> /&gt;</span>a para<span class="tag">&lt;<span class="name">br</span> /&gt;</span>graph with line breaks<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="HTML-链接"><a href="#HTML-链接" class="headerlink" title="HTML 链接"></a>HTML 链接</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">HTML 链接是通过 <span class="tag">&lt;<span class="name">a</span>&gt;</span> 标签进行定义的。</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span>&gt;</span>baidu<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">target 属性</span><br><span class="line">使用 Target 属性，你可以定义被链接的文档在何处显示</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com/"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="HTML-图像"><a href="#HTML-图像" class="headerlink" title="HTML 图像"></a>HTML 图像</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">HTML 图像是通过 &lt;img&gt; 标签进行定义的。</span><br><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">"dog.jpg"</span> <span class="attribute">width</span>=<span class="string">"104"</span> <span class="attribute">height</span>=<span class="string">"142"</span> /&gt;</span><br><span class="line"></span><br><span class="line">源属性（Src）</span><br><span class="line">src 指 <span class="string">"source"</span>。源属性的值是图像的 URL 地址</span><br><span class="line"></span><br><span class="line">替换文本属性（Alt）</span><br><span class="line">在浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息</span><br><span class="line">此时，浏览器将显示这个替代性的文本而不是图像。为页面上的图像都加上替换文本属性是个好习惯，</span><br><span class="line">这样有助于更好的显示信息，并且对于那些使用纯文本浏览器的人来说是非常有用的。</span><br></pre></td></tr></table></figure><h4 id="HTML-表格"><a href="#HTML-表格" class="headerlink" title="HTML 表格"></a>HTML 表格</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">格式</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> 每行</span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span> 每列</span><br><span class="line">    每行被分割为若干单元格</span><br><span class="line">    即数据单元格的内容</span><br><span class="line">    数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>行1列1<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>行1列2<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>行2列1<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>行2列2<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">边框属性  border</span><br><span class="line"></span><br><span class="line">&lt;table border = <span class="string">"1"</span>&gt;</span><br><span class="line">&lt;tr&gt;<span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>行1列1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>行1列2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line">&lt;tr&gt;<span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>行2列1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>行2列2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/table&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">表格的表头</span><br><span class="line"></span><br><span class="line">表格的表头使用 &lt;th&gt; 标签进行定义</span><br><span class="line">&lt;table border = <span class="string">"1"</span>&gt;</span><br><span class="line">&lt;tr&gt;<span class="xml"><span class="tag">&lt;<span class="name">th</span>&gt;</span>表头<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line">&lt;tr&gt;<span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>行1列1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>行1列2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line">&lt;tr&gt;<span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>行2列1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>行2列2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/table&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">表格中的空单元格</span><br><span class="line"></span><br><span class="line">    在一些浏览器中，没有内容的表格单元显示得不太好。如果某个单元格是空的</span><br><span class="line">    （没有内容），浏览器可能无法显示出这个单元格的边框。</span><br><span class="line">    </span><br><span class="line">    <span class="variable">&amp;nbsp</span>;</span><br><span class="line">    </span><br><span class="line"><span class="params">&lt;table border = "<span class="number">1</span>"&gt;</span></span><br><span class="line"><span class="params">&lt;tr&gt;</span><span class="params">&lt;th&gt;</span>表头<span class="params">&lt;/th&gt;</span><span class="params">&lt;/tr&gt;</span></span><br><span class="line"><span class="params">&lt;tr&gt;</span><span class="params">&lt;td&gt;</span>行<span class="number">1</span>列<span class="number">1</span><span class="params">&lt;/td&gt;</span><span class="params">&lt;td&gt;</span>行<span class="number">1</span>列<span class="number">2</span><span class="params">&lt;/td&gt;</span><span class="params">&lt;/tr&gt;</span></span><br><span class="line"><span class="params">&lt;tr&gt;</span><span class="params">&lt;td&gt;</span><span class="variable">&amp;nbsp</span><span class="params">&lt;/td&gt;</span><span class="params">&lt;td&gt;</span>行<span class="number">2</span>列<span class="number">2</span><span class="params">&lt;/td&gt;</span><span class="params">&lt;/tr&gt;</span></span><br><span class="line"><span class="params">&lt;/table&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">跨行或跨列的表格单元格</span><br><span class="line"></span><br><span class="line">colspan 跨列</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span> = <span class="string">"1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>跨两列<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>行1列1<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>行1列2<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>&amp;nbsp<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>行2列2<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line">rowspan 跨行</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span> = <span class="string">"1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>跨两列<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>行1列1<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>行1列2<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span> &gt;</span>跨两行<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> &gt;</span>行2列2<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>行3<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">单元格边距(Cell padding)</span><br><span class="line"></span><br><span class="line">单元格内容与其边框之间的空白</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>没有 cellpadding：<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>First<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>Row<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>   </span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>Second<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>Row<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>带有 cellpadding：<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">cellpadding</span>=<span class="string">"10"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>First<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>Row<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>   </span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>Second<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>Row<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">单元格间距(Cell spacing)</span><br><span class="line"></span><br><span class="line">增加单元格之间的距离</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>没有 cellspacing：<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>First<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>Row<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>   </span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>Second<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>Row<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>带有 cellspacing：<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>  <span class="attr">cellspacing</span>=<span class="string">"10"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>First<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>Row<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>   </span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>Second<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span>Row<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">向表格添加背景颜色或背景图像</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>背景颜色：<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">bgcolor</span>=<span class="string">"red"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>First<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>Row<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>Second<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>Row<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>背景图像：<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">background</span>=<span class="string">"dog01.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>First<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Row<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Second<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Row<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">在表格单元中排列内容</span><br><span class="line">    align</span><br><span class="line">    left</span><br><span class="line">    right</span><br><span class="line">    center</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span>消费项目....<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>一月<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>二月<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span>衣服<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>$241.10<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>$50.20<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span>化妆品<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>$30.00<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>$44.45<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span>食物<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>$730.40<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>$650.00<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span>总计<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>$1001.50<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>$744.65<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="code"><pre><span class="line">frame</span><br><span class="line">无法在 Internet Explorer 中正确地显示。</span><br></pre></td></tr></table></figure><h4 id="HTML-列表"><a href="#HTML-列表" class="headerlink" title="HTML 列表"></a>HTML 列表</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">无序列表</span><br><span class="line">无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。</span><br><span class="line">无序列表始于 <span class="tag">&lt;<span class="name">ul</span>&gt;</span> 标签。</span><br><span class="line">每个列表项始于 <span class="tag">&lt;<span class="name">li</span>&gt;</span>。</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>数据1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>数据2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>数据3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>数据4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>数据5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">有序列表</span><br><span class="line">列表项目使用数字进行标记</span><br><span class="line">有序列表始于 <span class="tag">&lt;<span class="name">ol</span>&gt;</span> 标签。</span><br><span class="line">每个列表项始于 <span class="tag">&lt;<span class="name">li</span>&gt;</span> 标签。</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>数据1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>数据2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>数据3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>数据4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>数据5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">定义列表</span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span> 标签开始</span><br><span class="line">每个自定义列表项以 <span class="tag">&lt;<span class="name">dt</span>&gt;</span> 开始</span><br><span class="line">每个自定义列表项的定义以 <span class="tag">&lt;<span class="name">dd</span>&gt;</span> 开始</span><br></pre></td></tr></table></figure><h4 id="HTML-块"><a href="#HTML-块" class="headerlink" title="HTML 块"></a>HTML 块</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">HTML <span class="tag">&lt;<span class="name">div</span>&gt;</span> 元素</span><br><span class="line"></span><br><span class="line">可用于组合其他 HTML 元素的容器</span><br><span class="line">CSS 一同使用，<span class="tag">&lt;<span class="name">div</span>&gt;</span> 元素可用于对大的内容块设置样式属性</span><br><span class="line">另一个常见的用途是文档布局</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color:#00FF00"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>This is a header<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">HTML <span class="tag">&lt;<span class="name">span</span>&gt;</span> 元素</span><br><span class="line"></span><br><span class="line">没有特定的含义</span><br><span class="line">当与 CSS 一同使用时，<span class="tag">&lt;<span class="name">span</span>&gt;</span> 元素可用于为部分文本设置样式属性</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>some text.<span class="tag">&lt;/<span class="name">span</span>&gt;</span>some other text.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="HTML-布局"><a href="#HTML-布局" class="headerlink" title="HTML 布局"></a>HTML 布局</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">div 元素是用于分组 HTML 元素的块级元素</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">            <span class="selector-tag">div</span><span class="selector-id">#container</span>&#123;<span class="attribute">width</span>:<span class="number">500px</span>&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">div</span><span class="selector-id">#header</span> &#123;<span class="attribute">background-color</span>:<span class="number">#99bbbb</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">div</span><span class="selector-id">#menu</span> &#123;<span class="attribute">background-color</span>:<span class="number">#ffff99</span>; <span class="attribute">height</span>:<span class="number">200px</span>; <span class="attribute">width</span>:<span class="number">100px</span>; <span class="attribute">float</span>:left;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">div</span><span class="selector-id">#content</span> &#123;<span class="attribute">background-color</span>:<span class="number">#EEEEEE</span>; <span class="attribute">height</span>:<span class="number">200px</span>; <span class="attribute">width</span>:<span class="number">400px</span>; <span class="attribute">float</span>:left;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">div</span><span class="selector-id">#footer</span> &#123;<span class="attribute">background-color</span>:<span class="number">#99bbbb</span>; <span class="attribute">clear</span>:both; <span class="attribute">text-align</span>:center;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">h1</span> &#123;<span class="attribute">margin-bottom</span>:<span class="number">0</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">h2</span> &#123;<span class="attribute">margin-bottom</span>:<span class="number">0</span>; <span class="attribute">font-size</span>:<span class="number">14px</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">ul</span> &#123;<span class="attribute">margin</span>:<span class="number">0</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">li</span> &#123;<span class="attribute">list-style</span>:none;&#125;</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Main Title of Web Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Menu<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>CSS<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span>Content goes here<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span>Copyright W3School.com.cn<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="HTML-表单"><a href="#HTML-表单" class="headerlink" title="HTML 表单"></a>HTML 表单</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">什么表单</span><br><span class="line">是一个包含表单元素的区域</span><br><span class="line">表单元素是允许用户在表单中（比如：文本域、下拉列表、单选框、复选框等等）输入信息的元素</span><br><span class="line">表单使用表单标签（<span class="tag">&lt;<span class="name">form</span>&gt;</span>）定义</span><br><span class="line"></span><br><span class="line">表单的动作属性（Action）和确认按钮</span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"input"</span> <span class="attr">action</span>=<span class="string">"html_form_action.asp"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">        Username: </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">form表单属性action与method（get,post）</span><br><span class="line"></span><br><span class="line">输入标签<span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line">    文本域（Text Fields）</span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">        文本域<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">单选按钮（Radio Buttons）</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span> = <span class="string">"sex"</span>&gt;</span>男</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span> = <span class="string">"sex"</span>&gt;</span>女</span><br><span class="line">注意，只能从中选取其一。</span><br><span class="line"></span><br><span class="line">复选框(Checkboxes)</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"checkbox"</span> &gt;</span>苹果</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"checkbox"</span> &gt;</span>香蕉</span><br><span class="line">隐藏 hidden</span><br><span class="line">图片 image</span><br><span class="line">密码框 password</span><br><span class="line">按钮 button</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Hello world!"</span>&gt;</span></span><br><span class="line">重置 reset</span><br><span class="line">提交 submit</span><br><span class="line">文件 file</span><br><span class="line"></span><br><span class="line">下拉列表</span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"cars"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"volvo"</span>&gt;</span>Volvo<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"saab"</span>&gt;</span>Saab<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"fiat"</span>&gt;</span>Fiat<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"audi"</span>&gt;</span>Audi<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">textarea</span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">"5"</span> <span class="attr">cols</span>=<span class="string">"30"</span> <span class="attr">name</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="HTML-框架"><a href="#HTML-框架" class="headerlink" title="HTML 框架"></a>HTML 框架</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">框架结构标签（<span class="tag">&lt;<span class="name">frameset</span>&gt;</span>）</span><br><span class="line">框架结构标签（<span class="tag">&lt;<span class="name">frameset</span>&gt;</span>）定义如何将窗口分割为框架</span><br><span class="line">每个 frameset 定义了一系列行或列</span><br><span class="line">rows/columns 的值规定了每行或每列占据屏幕的面积</span><br><span class="line"></span><br><span class="line">框架标签（Frame）</span><br><span class="line">Frame 标签定义了放置在每个框架中的 HTML 文档。</span><br><span class="line"></span><br><span class="line">例子</span><br><span class="line">    <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"25%,75%"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"frame_a.htm"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"frame_b.htm"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是 HTML；&lt;/li&gt;
&lt;li&gt;HTML 元素；&lt;/li&gt;
&lt;li&gt;HTML 属性；&lt;/li&gt;
&lt;li&gt;HTML 标签。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="HTML" scheme="http://jovelin.cn/categories/HTML/"/>
    
    
      <category term="HTML" scheme="http://jovelin.cn/tags/HTML/"/>
    
      <category term="HTML 标签" scheme="http://jovelin.cn/tags/HTML-%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>Python miniweb 框架</title>
    <link href="http://jovelin.cn/2018/07/26/Python%20miniweb%20%E6%A1%86%E6%9E%B6/"/>
    <id>http://jovelin.cn/2018/07/26/Python miniweb 框架/</id>
    <published>2018-07-26T01:00:01.000Z</published>
    <updated>2018-07-28T02:45:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>web 开发各个节点关系图；</li><li>资源分类；</li><li>路由；</li><li>shell 脚本。</li></ol></blockquote><a id="more"></a><h1 id="miniweb-框架"><a href="#miniweb-框架" class="headerlink" title="miniweb 框架"></a>miniweb 框架</h1><h3 id="一、web-开发各个节点关系图"><a href="#一、web-开发各个节点关系图" class="headerlink" title="一、web 开发各个节点关系图"></a>一、web 开发各个节点关系图</h3><p><img src="https://upload-images.jianshu.io/upload_images/3365001-d7c1e7dfb5b1f5f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="web 开发各个节点关系.png"></p><h3 id="二、资源分类"><a href="#二、资源分类" class="headerlink" title="二、资源分类"></a>二、资源分类</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 静态资源： 不需要经常变化的资源文件：常用的： 图片,css,js,早期html文件</span><br><span class="line"><span class="number">2.</span> 动态资源： 经常需要变化的资源</span><br><span class="line">依据用户的请求方式不同，请求时间不同，产生的数据会发送相应的变化</span><br><span class="line">数据一般来自数据库中的数据</span><br><span class="line"><span class="number">3.</span> 模板资源： 不存储任何用户数据的文件，一个'空文件',也是一个静态资源，但是会结合其他的数据，形成动态资源</span><br><span class="line">        比如说从数据库中查询出的数据，再往模板文件中添加，形成动态资源</span><br><span class="line">        </span><br><span class="line"><span class="number">3.1</span> 替换模板的作用：</span><br><span class="line">   模板网页 + 动态数据 = 动态网页</span><br><span class="line">实现步骤：</span><br><span class="line"><span class="number">1.</span> 访问数据库，获取动态数据</span><br><span class="line"><span class="number">2.</span> 读取模板文件</span><br><span class="line"><span class="number">3.</span> 通过正则表达式，把动态数据替换到模板页面中，形成一个新的动态页面</span><br><span class="line"><span class="number">4.</span> 返回新的动态页面内容(响应体)</span><br></pre></td></tr></table></figure><h3 id="三、路由"><a href="#三、路由" class="headerlink" title="三、路由"></a>三、路由</h3><p>web 开发过程中的路由概念图</p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-df04976fb4a66a83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="web 开发过程中的路由概念.png"></p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 请求路径 --&gt; 对应的执行函数</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 装饰器装饰路由</span><br><span class="line">装饰器工厂  向装饰器传参   @route(xxx)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 通过装饰器实现 mini_frame 中的路由器功能 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备一个装饰器工厂；通过装饰器的方式自动装配路由列表：[("/index.py", index)]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">route</span><span class="params">(url)</span></span>:  <span class="comment"># 装饰器工厂函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">w1</span><span class="params">(func)</span></span>:  <span class="comment"># 装饰器函数</span></span><br><span class="line">        <span class="comment"># url ---&gt; /index.py</span></span><br><span class="line">        <span class="comment"># func --&gt; index  即执行index()(被装饰函数)函数的地址</span></span><br><span class="line">        print(<span class="string">"添加装饰"</span>)</span><br><span class="line">        g_route_list.append((url,func))  <span class="comment"># ("/index.py", index)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">            print(<span class="string">"正在执行拓展功能..."</span>)</span><br><span class="line">            func()</span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line">    <span class="keyword">return</span> w1</span><br><span class="line"></span><br><span class="line">@route(<span class="string">"/index.py"</span>)</span><br><span class="line"><span class="comment"># <span class="doctag">@w</span>1  # 本质上 index = w1(index)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">pass</span><br></pre></td></tr></table></figure><h3 id="四、shell-脚本"><a href="#四、shell-脚本" class="headerlink" title="四、shell 脚本"></a>四、shell 脚本</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. xxx<span class="selector-class">.sh</span>   多个 linux 命令一起执行</span><br><span class="line">    设置执行权限</span><br><span class="line">        $ chmod <span class="number">777</span> xxx.sh</span><br><span class="line">    </span><br><span class="line">    run.sh</span><br><span class="line">        sudo python3 Web<span class="selector-class">.py</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. readme<span class="selector-class">.txt</span>  使用说明文档</span><br><span class="line">    运行步骤：</span><br><span class="line">        终端命令：./run.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;web 开发各个节点关系图；&lt;/li&gt;
&lt;li&gt;资源分类；&lt;/li&gt;
&lt;li&gt;路由；&lt;/li&gt;
&lt;li&gt;shell 脚本。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="Python 高级" scheme="http://jovelin.cn/tags/Python-%E9%AB%98%E7%BA%A7/"/>
    
      <category term="miniweb" scheme="http://jovelin.cn/tags/miniweb/"/>
    
  </entry>
  
  <entry>
    <title>Python 高级提升(三)</title>
    <link href="http://jovelin.cn/2018/07/24/Python%20%E9%AB%98%E7%BA%A7%E6%8F%90%E5%8D%87(%E4%B8%89)/"/>
    <id>http://jovelin.cn/2018/07/24/Python 高级提升(三)/</id>
    <published>2018-07-24T01:00:01.000Z</published>
    <updated>2018-07-28T02:12:24.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>代码编写两大原则；</li><li>闭包；</li><li>装饰器。</li></ol></blockquote><a id="more"></a><h3 id="一-代码编写两大原则"><a href="#一-代码编写两大原则" class="headerlink" title="一. 代码编写两大原则"></a>一. 代码编写两大原则</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>开放封闭原则</span><br><span class="line"><span class="code">    封闭：已实现的功能代码块</span></span><br><span class="line"><span class="code">    开放：对扩展开放</span></span><br><span class="line"><span class="code">    对已经实现的功能代码不允许被修改，但可以被扩展</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="bullet">2. </span>高内聚低耦合原则</span><br><span class="line"><span class="code">    高内聚：针对的是模块内部；</span></span><br><span class="line"><span class="code">    描述的是内部各个元素结合的密切程度，一般一个模块就做一件事情</span></span><br><span class="line"><span class="code">    低耦合：针对的是模块之间；模块之间关联度尽量少一点</span></span><br></pre></td></tr></table></figure><h3 id="二、闭包"><a href="#二、闭包" class="headerlink" title="二、闭包"></a>二、闭包</h3><h4 id="1-函数名"><a href="#1-函数名" class="headerlink" title="1. 函数名"></a>1. 函数名</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>函数名是一个引用函数代码空间的对象，这个对象在被赋值的时候也可以引用其他空间</span><br><span class="line"><span class="bullet">2. </span>可以把函数名当做参数来使用</span><br></pre></td></tr></table></figure><h4 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2. 闭包"></a>2. 闭包</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">闭包好比是一个轻量级的实例对象</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 闭包的结构</span><br><span class="line"><span class="number">1.</span> 外部函数：外部函数返回内部函数的引用</span><br><span class="line"><span class="number">2.</span> 内部函数：内部函数使用了外部函数的参数或者的变量</span><br><span class="line">把这种结构的整体称为闭包</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 闭包与普通函数的区别</span><br><span class="line"><span class="number">1.</span> 普通函数能保存功能，但是不能保存传送给函数的数据(局部变量)</span><br><span class="line"><span class="number">2.</span> 闭包能保存功能，也可以保存数据</span><br><span class="line">   </span><br><span class="line">提示：</span><br><span class="line">    假如内部函数要修改外部函数的变量，则需先声明 </span><br><span class="line">    在 python3 中使用 <span class="keyword">nonlocal</span> 关键字(好比函数使用全局变量，使用 <span class="keyword">global</span> 关键字)</span><br></pre></td></tr></table></figure><h4 id="3-闭包的语法格式"><a href="#3-闭包的语法格式" class="headerlink" title="3. 闭包的语法格式"></a>3. 闭包的语法格式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 闭包的语法格式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="comment"># 处理业务</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"内部函数使用了外部函数的参数：%d"</span> % num)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">f1 = func(<span class="number">100</span>)  <span class="comment"># f1---&gt;inner--&gt;内部函数的定义</span></span><br><span class="line"></span><br><span class="line">f1()</span><br></pre></td></tr></table></figure><h3 id="三、装饰器"><a href="#三、装饰器" class="headerlink" title="三、装饰器"></a>三、装饰器</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 在不改变函数的定义和调用的前提下，给函数扩展功能，这就是装饰器</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 装饰器的语法格式</span><br><span class="line">    <span class="comment"># 装饰器函数 本质就是闭包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">w1</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment"># 验证1</span></span><br><span class="line">        print(<span class="string">"正在验证..."</span>)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@w1  # 本质就是  f1 = w1(f1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span> <span class="comment"># 被装饰的函数</span></span><br><span class="line">    print(<span class="string">"查账"</span>)</span><br><span class="line"></span><br><span class="line">f1()</span><br></pre></td></tr></table></figure><h4 id="2-装饰器装饰不同类型的函数"><a href="#2-装饰器装饰不同类型的函数" class="headerlink" title="2. 装饰器装饰不同类型的函数"></a>2. 装饰器装饰不同类型的函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 装饰器装饰不同类型的函数</span><br><span class="line">a&gt; 装饰器装饰的函数没参数，没返回值</span><br><span class="line">b&gt; 装饰器装饰的函数有参数，没返回值</span><br><span class="line">c&gt; 装饰器装饰的函数没参数，有返回值</span><br><span class="line">d&gt; 装饰器装饰的函数有参数，有返回值</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 万能装饰器，无|有参数(多个)，无|有返回值</span><br><span class="line"><span class="comment"># 装饰器函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">w1</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"正在执行身份验证..."</span>)  <span class="comment"># 拓展功能</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)  <span class="comment"># 执行被装饰函数</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的函数</span></span><br><span class="line"><span class="meta">@w1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">"被装饰的函数：查账"</span>)</span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"value"</span></span><br></pre></td></tr></table></figure><h4 id="3-多个装饰器装饰一个函数"><a href="#3-多个装饰器装饰一个函数" class="headerlink" title="3. 多个装饰器装饰一个函数"></a>3. 多个装饰器装饰一个函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">""" </span></span><br><span class="line"><span class="string">多个装饰器装饰一个函数的分析：</span></span><br><span class="line"><span class="string">参照对象：被装饰的函数</span></span><br><span class="line"><span class="string">    1. 装饰时，由里到外</span></span><br><span class="line"><span class="string">    2. 执行的，由外到里</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="meta">@sms_veri  # 本质  f1=sms_veri(f1)  func---&gt; f1(被装饰函数的内存空间)</span></span><br><span class="line"><span class="meta">@pwd_veri  # 本质  f1=pwd_veri(f1)  func---&gt; f1(被装饰函数的内存空间)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span>  <span class="comment"># 被装饰的函数</span></span><br><span class="line">    print(<span class="string">"被装饰函数：转账功能"</span>)</span><br><span class="line">f1()</span><br></pre></td></tr></table></figure><h4 id="4-带有额外参数的装饰器函数"><a href="#4-带有额外参数的装饰器函数" class="headerlink" title="4. 带有额外参数的装饰器函数"></a>4. 带有额外参数的装饰器函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">小结：通过装饰器工厂来实现带额外参数的装饰器函数</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(flag)</span>:</span> <span class="comment"># 装饰器的工厂函数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span> <span class="comment"># 装饰器函数</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">                <span class="keyword">if</span> flag==<span class="number">1</span>:</span><br><span class="line">                    print(<span class="string">"正在执行身份验证功能..."</span>)</span><br><span class="line">                func() <span class="comment"># 执行被装饰的函数</span></span><br><span class="line">            <span class="keyword">return</span> inner</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @outer(1)  # outer(0)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"被装饰函数：转账功能"</span>)</span><br><span class="line">    </span><br><span class="line">    f1()</span><br></pre></td></tr></table></figure><h4 id="5-类装饰器"><a href="#5-类装饰器" class="headerlink" title="5. 类装饰器"></a>5. 类装饰器</h4><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 以定义类的方式实现装饰器</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类装饰器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="title">object</span>):</span></span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, func)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">self</span>.func = func</span><br><span class="line">            print(<span class="string">"添加身份验证的装饰功能"</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(<span class="keyword">self</span>, *args, **kwargs)</span></span><span class="symbol">:</span></span><br><span class="line">            print(<span class="string">"正在身份验证..."</span>)</span><br><span class="line">            <span class="keyword">self</span>.func()         </span><br><span class="line">    </span><br><span class="line">    @Person  <span class="comment"># check = Person(check) </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">()</span></span>:  <span class="comment"># 被装饰的函数</span></span><br><span class="line">        print(<span class="string">"我是被装饰的函数...支付功能..."</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 目前的 check 起始就是 Person 类的实例对象</span></span><br><span class="line">    <span class="comment"># 实例对象()：表示该对象是可调用的，所有需要对创建该对象的类添加 __call__ 魔法方法</span></span><br><span class="line">    pay()</span><br></pre></td></tr></table></figure><h3 id="四、装饰器总结"><a href="#四、装饰器总结" class="headerlink" title="四、装饰器总结"></a>四、装饰器总结</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>装饰器函数只有一个参数就是被装饰的函数的引用</span><br><span class="line"><span class="bullet">2. </span>装饰器能够将一个函数的功能在不修改代码和调用的情况下进行扩展</span><br><span class="line"><span class="bullet">3. </span>在函数定义的上方 @装饰器函数名，即可直接使用装饰器对下面的函数进行装饰</span><br><span class="line"><span class="bullet">4. </span>装饰器的使用场景</span><br><span class="line"><span class="code">引入日志</span></span><br><span class="line"><span class="code">函数执行时间统计</span></span><br><span class="line"><span class="code">执行函数前预备处理</span></span><br><span class="line"><span class="code">执行函数后清理功能</span></span><br><span class="line"><span class="code">权限校验等场景</span></span><br><span class="line"><span class="code">缓存</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码编写两大原则；&lt;/li&gt;
&lt;li&gt;闭包；&lt;/li&gt;
&lt;li&gt;装饰器。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="Python 高级" scheme="http://jovelin.cn/tags/Python-%E9%AB%98%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python 高级提升(二)</title>
    <link href="http://jovelin.cn/2018/07/22/Python%20%E9%AB%98%E7%BA%A7%E6%8F%90%E5%8D%87(%E4%BA%8C)/"/>
    <id>http://jovelin.cn/2018/07/22/Python 高级提升(二)/</id>
    <published>2018-07-22T01:00:01.000Z</published>
    <updated>2018-07-28T02:12:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>可变参数的装包与拆包；</li><li>属性和方法；</li><li>魔法属性、方法；</li><li>property 属性；</li><li>with 与 上下文管理。</li></ol></blockquote><a id="more"></a><h3 id="一、可变参数的装包与拆包"><a href="#一、可变参数的装包与拆包" class="headerlink" title="一、可变参数的装包与拆包"></a>一、可变参数的装包与拆包</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 装包，针对的是形参中的 *<span class="keyword">args</span>、**kwargs</span><br><span class="line">    通过<span class="string">'*'</span>告诉 <span class="keyword">python</span> 解析器 把调用者传递过来的没有变量接收的未命名参数，装在 <span class="keyword">args</span> 这个元组中</span><br><span class="line">    通过<span class="string">'**'</span>告诉 <span class="keyword">python</span> 解析器 把调用者传递过来的命名参数，装在kwargs这个字典中</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>. 拆包，针对的是函数体中的 *<span class="keyword">args</span>、**kwargs</span><br><span class="line">    函数体里的 <span class="keyword">args</span> 依然是那个元组，但是 *<span class="keyword">args</span> 的含义就是把元组中的数据进行拆包，也就是把元组中的数据拆成单个数据</span><br><span class="line">    kwargs 同理可知</span><br></pre></td></tr></table></figure><h3 id="二、属性和方法"><a href="#二、属性和方法" class="headerlink" title="二、属性和方法"></a>二、属性和方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 类属性与实例属性</span><br><span class="line">    <span class="number">1.</span> 类属性存放在类对象的内存中，在内存中只保存一份</span><br><span class="line">    <span class="number">2.</span> 实例属性存放在实例对象的内存中，在每个实例对象中都单独保存一份</span><br><span class="line">    <span class="number">3.</span> 如果每个实例对象需要具有相同值的属性，那么就定义类属性</span><br><span class="line">  </span><br><span class="line"><span class="number">2.</span> 静态方法，类方法，实例方法</span><br><span class="line">    <span class="number">1.</span> 方法定义： </span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">static_fun</span><span class="params">()</span>:</span></span><br><span class="line"><span class="string">"""静态方法"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">class_fun</span><span class="params">(cls)</span>:</span>  </span><br><span class="line"><span class="string">"""类方法"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_fun</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""实例方法"""</span></span><br><span class="line"></span><br><span class="line">    <span class="number">2.</span> 对比</span><br><span class="line">    相同点：对于所有的方法而言，均属于类，所以在内存中也只保存一份</span><br><span class="line">不同点：方法调用者不同、调用方法时自动传入的参数不同。</span><br></pre></td></tr></table></figure><h3 id="三、魔法属性、方法"><a href="#三、魔法属性、方法" class="headerlink" title="三、魔法属性、方法"></a>三、魔法属性、方法</h3><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">魔法属性和魔法方法是 Python 内置的一些属性和方法，代表着特殊意义，</span><br><span class="line">命名时会在前后加两个下划线，在执行特定操作时，系统会自动调用它</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="variable">__doc__</span></span><br><span class="line"><span class="variable">__doc__</span>：表示类的描述信息</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. <span class="variable">__module__</span>,<span class="variable">__class__</span></span><br><span class="line">    <span class="variable">__module__</span>：表示当前操作的对象或者类在哪个模块</span><br><span class="line">    <span class="variable">__class__</span>：表示当前操作的对象的类是什么</span><br><span class="line">   </span><br><span class="line"><span class="number">3</span>. <span class="variable">__dict__</span>,<span class="variable">__str__</span></span><br><span class="line">    <span class="variable">__dict__</span>：显示类或对象中的所有属性</span><br><span class="line">    <span class="variable">__str__</span>：如果类中重写了 <span class="variable">__str__</span> 方法，那么在打印对象时，输出该方法的返回值</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. <span class="variable">__init__</span>,<span class="variable">__del__</span></span><br><span class="line">    <span class="variable">__init__</span>：当类初始化对象时，自动执行该方法</span><br><span class="line">    <span class="variable">__del__</span>：当对象在内存中被销毁时，自动执行该方法</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>. <span class="variable">__call__</span>  </span><br><span class="line">    <span class="variable">__call__</span>：对象后面加 ()，会自动执行该魔法方法</span><br><span class="line">    提示：必须在创建对象的类中添加 <span class="variable">__call__</span>() 方法，表示类的实例对象是能被 callable 调用的</span><br></pre></td></tr></table></figure><h3 id="四、property-属性"><a href="#四、property-属性" class="headerlink" title="四、property 属性"></a>四、property 属性</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="keyword">property</span><span class="title"> </span>属性初体验</span><br><span class="line">    一种用起来像是使用的实例属性一样的特殊属性，可以对应于某个方法，<span class="keyword">property</span><span class="title"> </span>属性本质还是方法</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">property</span><span class="title"> </span>属性的定义和调用注意点：</span><br><span class="line">    <span class="number">1</span>. 定义时，在实例方法的基础上添加 @<span class="keyword">property</span><span class="title"> </span>装饰器；并且方法仅有一个 self 参数</span><br><span class="line">    <span class="number">2</span>. 调用时，无需括号</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. <span class="keyword">property</span><span class="title"> </span>属性的好处</span><br><span class="line">将一个属性的操作方法封装为一个属性，用户用起来就和操作普通属性完全一致,非常简单</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 通过装饰器的方式定义 <span class="keyword">property</span><span class="title"> </span>属性</span><br><span class="line">    <span class="number">1</span>. 使用装饰器方式定义 <span class="keyword">property</span><span class="title"> </span>属性</span><br><span class="line">    - @<span class="keyword">property</span><span class="title"></span></span><br><span class="line">        取得属性值，修饰的方法有且仅有一个 self 参数</span><br><span class="line">    - @方法名.setter</span><br><span class="line">        设置属性值，修饰的方法，只能传一个参数</span><br><span class="line">    - @方法名.deleter</span><br><span class="line">        删除属性，修饰的方法有且仅有一个 self 参数</span><br><span class="line">    </span><br><span class="line">    <span class="number">2</span>. 访问 <span class="keyword">property</span><span class="title"> </span>属性的三种方式</span><br><span class="line">    temp = obj.price  <span class="comment"># 获取 property 属性</span></span><br><span class="line">    obj.price = new_price  <span class="comment"># 修改 property 属性</span></span><br><span class="line">    del obj.price  <span class="comment"># 删除 property 属性(很少使用)</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. 通过类属性方式定义 <span class="keyword">property</span><span class="title"> </span>属性</span><br><span class="line">price = <span class="keyword">property</span><span class="title"></span>(get_price, set_price, del_price, <span class="string">"描述信息"</span>)</span><br><span class="line">     第一个参数是方法名: 获取属性值</span><br><span class="line">     第二个参数是方法名: 设置属性值</span><br><span class="line">     第三个参数是方法名: 删除属性</span><br><span class="line">     第四个参数是字符串: 该属性的描述信息，通过类名.属性名.__doc__调用</span><br><span class="line">     </span><br><span class="line">    obj.price  <span class="comment"># 获取 property 属性值</span></span><br><span class="line">    obj.price = new_price  <span class="comment"># 设置 property 属性值</span></span><br><span class="line">    obj.del_price()  <span class="comment"># 删除 property 属性(很少使用)</span></span><br><span class="line">    Obj.price.__doc__调用  <span class="comment"># 通过类名.属性名.__doc__调用</span></span><br></pre></td></tr></table></figure><h3 id="五、with-与-上下文管理"><a href="#五、with-与-上下文管理" class="headerlink" title="五、with 与 上下文管理"></a>五、with 与 上下文管理</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">with</span> 使用：</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"/home/python/Desktop/hello.txt"</span>, <span class="string">'w'</span>) <span class="keyword">as</span> <span class="built_in">file</span>:</span><br><span class="line">        <span class="built_in">file</span>.<span class="built_in">write</span>(<span class="string">'hello with'</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 上下文管理器        </span><br><span class="line">    上下文：context，也称为上下文环境，好比教室环境</span><br><span class="line">       上文</span><br><span class="line">       正文：讲课，主业务</span><br><span class="line">       下文</span><br><span class="line"></span><br><span class="line">上下文管理：</span><br><span class="line">任何实现了 __enter__() 和 __exit__() 方法的对象</span><br><span class="line">都可称之为上下文管理器，上下文管理器可以使用 <span class="keyword">with</span> 简化操作</span><br><span class="line">    __enter__()：初始化资源对象，且返回资源对象</span><br><span class="line">    __exit__()：业务执行完后，在该方法做善后、清理方面的工作</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 装饰器的方式</span><br><span class="line">import contextlib</span><br><span class="line"></span><br><span class="line">@contextlib.contextmanager</span><br><span class="line">def my_open(path, mode):</span><br><span class="line">f = <span class="built_in">open</span>(path, mode)</span><br><span class="line">yield f</span><br><span class="line">f.<span class="built_in">close</span>()</span><br><span class="line"></span><br><span class="line">小结： <span class="keyword">with</span> 语法用于简化资源操作的后续清除操作，是 <span class="keyword">try</span>/<span class="keyword">finally</span> 的替代方法，实现原理建立在上下文管理器之上</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可变参数的装包与拆包；&lt;/li&gt;
&lt;li&gt;属性和方法；&lt;/li&gt;
&lt;li&gt;魔法属性、方法；&lt;/li&gt;
&lt;li&gt;property 属性；&lt;/li&gt;
&lt;li&gt;with 与 上下文管理。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="Python 高级" scheme="http://jovelin.cn/tags/Python-%E9%AB%98%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python 高级提升(一)</title>
    <link href="http://jovelin.cn/2018/07/21/Python%20%E9%AB%98%E7%BA%A7%E6%8F%90%E5%8D%87(%E4%B8%80)/"/>
    <id>http://jovelin.cn/2018/07/21/Python 高级提升(一)/</id>
    <published>2018-07-21T01:00:01.000Z</published>
    <updated>2018-07-28T02:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>GIL (全局解释器锁)；</li><li>赋值、浅拷贝、深拷贝；</li><li>import 导入模块；</li><li>多继承以及 MRO 顺序。</li></ol></blockquote><a id="more"></a><h3 id="一、GIL-全局解释器锁"><a href="#一、GIL-全局解释器锁" class="headerlink" title="一、GIL (全局解释器锁)"></a>一、GIL (全局解释器锁)</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 单线程、多线程、多进程执行分析</span><br><span class="line">   双核 cpu</span><br><span class="line">     - 单线程： 一个 cpu <span class="number">100</span>% 使用，另一个空闲</span><br><span class="line">     - 两个线程： 两个 cpu 各自使用 <span class="number">50</span>%</span><br><span class="line">     - 两个进程： 两个 cpu 各自使用 <span class="number">100</span>%</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> GIL 概念：</span><br><span class="line">GIL，全局解释器锁(global interpreter lock)，它不是 python 语言的特性，而是 python 默认的解析器 cpython 的特性</span><br><span class="line">cpython 要求每个线程必须先获取 GIL 锁，才能执行线程中的代码</span><br><span class="line"></span><br><span class="line">目的：解决多线程同时竞争解析器程序的全局变量而出现的线程安全问题</span><br><span class="line">不足：在多线程中不能充分利用多核 cpu</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 如何解决 GIL 问题：</span><br><span class="line"><span class="number">1.</span> 换解析器 ，把 cpython 换成其他的，比如 jpython</span><br><span class="line"><span class="number">2.</span> 针对多线程执行的业务，用其他语言代码，比如 c++，java 来代替，python 就是胶水语言</span><br><span class="line"><span class="number">3.</span> 多进程+多协程方案</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 面试题：</span><br><span class="line">描述 Python GIL 的概念，以及它对 python 多线程的影响？一个单线程抓取网页的程序，与一个多线程抓取网页的程序哪个性能更高，并解释原因。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> GIL，全局解释器锁(global interpreter lock)，它是 cpython 解析器的特性，不是 python 的特性 ，它要求线程在执行前，需要获取GIL锁，</span><br><span class="line"><span class="number">2.</span> 由于 GIL 的存在，会影响多线程不能利用多核 CPU 资源，通过多进程方式可利用多个 CPU 资源</span><br><span class="line"><span class="number">3.</span> 线程释放 GIL 锁的情况：</span><br><span class="line">在 IO 操作等可能会引起阻塞的 system call 之前，可以暂时释放 GIL，但在执行完毕后，必须重新获取 GIL</span><br><span class="line">Python <span class="number">3.</span>x 使用计时器（执行时间达到阈值后，当前线程释放 GIL）</span><br><span class="line"><span class="number">4.</span> 多线程爬取比单线程性能有提升，因为遇到 IO 阻塞会自动释放 GIL 锁，这样在线程阻塞情况下，可以执行其他线程中的代码</span><br></pre></td></tr></table></figure><h3 id="二、赋值、浅拷贝、深拷贝"><a href="#二、赋值、浅拷贝、深拷贝" class="headerlink" title="二、赋值、浅拷贝、深拷贝"></a>二、赋值、浅拷贝、深拷贝</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">赋值是对多个对象指向同一个内存空间，多个对象共同操作同一个数据</span><br><span class="line">深拷贝与浅拷贝是对内存数据的复制，目的是能够单独操作数据</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 赋值</span><br><span class="line">对象之间赋值本质上是对象之间内存地址的引用传递</span><br><span class="line">也就是多个对象指向同一个内存空间</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 浅拷贝</span><br><span class="line"><span class="number">1</span>. 引入 <span class="keyword">copy</span><span class="bash"> 模块</span></span><br><span class="line"><span class="bash">2. copy.copy(object)</span></span><br><span class="line"><span class="bash">    object: 要拷贝的对象</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">小结：浅拷贝是对象的第一层(顶层)的拷贝</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">3. 深拷贝</span></span><br><span class="line"><span class="bash">深拷贝</span></span><br><span class="line"><span class="bash">1. 引入 copy 模块</span></span><br><span class="line"><span class="bash">2. copy.deepcopy(object)</span></span><br><span class="line"><span class="bash">    object: 要拷贝的对象</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">小结：深拷贝是对象的所有层的拷贝</span></span><br><span class="line"><span class="bash">  </span></span><br><span class="line"><span class="bash">4. 不可变类型(元组,数字,字符串)的拷贝</span></span><br><span class="line"><span class="bash">    1&gt; 如果在多层嵌套中都是不可变类型</span></span><br><span class="line"><span class="bash">     浅拷贝与深拷贝都是相同的，都不会单独开辟内存空间，而是引用原来的内存空间</span></span><br><span class="line"><span class="bash"> 2&gt; 如果顶层是不可变类型，但内部元素有嵌入可变类型</span></span><br><span class="line"><span class="bash">     浅拷贝还是不会开辟新的内存空间，而是引用原来的内存空间</span></span><br><span class="line"><span class="bash">     深拷贝会拷贝对象的所有层</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">5. 其他拷贝方式(列表切片、字典中的 copy)</span></span><br><span class="line"><span class="bash">    列表切片、字典中的 copy 都使用浅拷贝</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">面试题：</span></span><br><span class="line"><span class="bash">    如何在内存中复制一个数据</span></span><br><span class="line"><span class="bash">        浅拷贝，深拷贝 copy 模块</span></span><br><span class="line"><span class="bash">    切片操作与字典中的拷贝属于哪种拷贝:</span></span><br><span class="line"><span class="bash">        浅拷贝</span></span><br></pre></td></tr></table></figure><h4 id="三、import-导入模块"><a href="#三、import-导入模块" class="headerlink" title="三、import 导入模块"></a>三、import 导入模块</h4><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">import</span> 搜索路径</span><br><span class="line">a&gt; 查看搜索路径</span><br><span class="line">sys.path # 系统预设的搜索路径</span><br><span class="line"></span><br><span class="line">b&gt; 设置搜索路径</span><br><span class="line">    sys.path.append(<span class="string">"/python/a"</span>)</span><br><span class="line">    sys.path.insert(<span class="number">0</span>,<span class="string">"/python/b"</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 重新导入模块</span><br><span class="line">热更新： 服务没有停止，再更新模块</span><br><span class="line"><span class="keyword">import</span> imp</span><br><span class="line"> imp.reload(load_test)</span><br><span class="line">   load_test:模块名</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 多模块开发时引用其它模块共享变量的问题 </span><br><span class="line">  <span class="number">1.</span> <span class="keyword">import</span> <span class="keyword">module</span> 方式  </span><br><span class="line">  本地不会创建新变量，操作的是目标模块的变量</span><br><span class="line"> <span class="number">2.</span> <span class="keyword">from</span> <span class="keyword">module</span> <span class="keyword">import</span> * 方式</span><br><span class="line"> 在本地创建一个与目标模块相同的变量名，并且与目标模块变量指向同一个内存空间</span><br><span class="line"></span><br><span class="line">面试题: <span class="keyword">import</span> <span class="keyword">module</span> 与 <span class="keyword">from</span> <span class="keyword">module</span> <span class="keyword">import</span> * 两种模块导入有何区别</span><br><span class="line"></span><br><span class="line"> <span class="number">1.</span> <span class="keyword">import</span> <span class="keyword">module</span> 引用共享变量时，要使用 <span class="keyword">module</span>.变量名，而 <span class="keyword">from</span> <span class="keyword">module</span> <span class="keyword">import</span> * 直接使用变量名即可</span><br><span class="line"> <span class="number">2.</span> <span class="keyword">import</span> <span class="keyword">module</span> 方式  </span><br><span class="line"> 本地不会创建新变量，操作的是目标模块的变量</span><br><span class="line">  <span class="number">3.</span> <span class="keyword">from</span> <span class="keyword">module</span> <span class="keyword">import</span> * 方式</span><br><span class="line">在本地创建一个与目标模块相同的变量名，并且与目标模块变量指向同一个内存空间</span><br></pre></td></tr></table></figure><h3 id="四、多继承以及-MRO-顺序"><a href="#四、多继承以及-MRO-顺序" class="headerlink" title="四、多继承以及 MRO 顺序"></a>四、多继承以及 MRO 顺序</h3><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 单继承</span><br><span class="line">子类调用父类的方法的方式：</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. super().__init__()</span><br><span class="line">  <span class="number">2</span>. Parent.__init__(<span class="keyword">self</span>)</span><br><span class="line">  <span class="number">3</span>. super(类名,<span class="keyword">self</span>).__init__()</span><br><span class="line"></span><br><span class="line"> 单继承中，使用父类名与super调用父类的方法没有差异，是一样的</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 多继承中使用父类名调用父类的方法</span><br><span class="line">出现问题： 父类的方法会调用多次</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 多继承中使用 super() 调用父类的方法</span><br><span class="line">在多继承中，建议使用 super() 来调用父类的方法，而不用父类名的方式</span><br><span class="line"></span><br><span class="line">- mro顺序： <span class="function"><span class="keyword">Method</span> <span class="title">Resolution</span> <span class="title">Order</span> :</span></span><br><span class="line">    方法解决顺序，方法解析顺序</span><br><span class="line">    用于描述在Python多继承中子类调用多个父类相同方法的顺序 </span><br><span class="line">内部通过C3算法去解析</span><br><span class="line">- 类名.__mro__ : 用元组的形式存放子类调用多个父类相同方法的顺序（mro算法执行的结果）</span><br><span class="line"></span><br><span class="line">- super()与类名.__mro__的关系：</span><br><span class="line"># (&lt;<span class="keyword">class</span> <span class="string">'__main__.Grandson'</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">'__main__.Son1'</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">'__main__.Son2'</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">'__main__.Parent'</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">'object'</span>&gt;)</span><br><span class="line"></span><br><span class="line"> super(类名，<span class="keyword">self</span>)就是依照这个顺序确定要调用的是哪个父类的方法</span><br><span class="line">    通过<span class="keyword">self</span>确定mro顺序</span><br><span class="line">    通过类名找到当前类在mro中的位置，再返回下一个类作为super调用的父类</span><br><span class="line"></span><br><span class="line">小结： </span><br><span class="line">   <span class="number">1</span>. 单继承中，super().__init__相对于类名.__init__，基本无差别</span><br><span class="line">   <span class="number">2</span>. 多继承中，super() 能保证每个父类的方法只会执行一次，而使用类名的方法会导致方法被执行多次</span><br><span class="line">      多继承中建议使用super()</span><br><span class="line">   <span class="number">2</span>. super() 内部是通过 mro 算法来确定调用哪个父类的方法</span><br></pre></td></tr></table></figure><h3 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. vim -On one<span class="selector-class">.py</span>  two<span class="selector-class">.py</span> </span><br><span class="line">在vim中分屏显示多个文件</span><br><span class="line"><span class="number">2</span>.Htop命令： </span><br><span class="line">显示的内容比<span class="attribute">top</span>命令更加丰富，用于监视进程的资源占用率的情况</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GIL (全局解释器锁)；&lt;/li&gt;
&lt;li&gt;赋值、浅拷贝、深拷贝；&lt;/li&gt;
&lt;li&gt;import 导入模块；&lt;/li&gt;
&lt;li&gt;多继承以及 MRO 顺序。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="Python 高级" scheme="http://jovelin.cn/tags/Python-%E9%AB%98%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 与 Python 交互(五)</title>
    <link href="http://jovelin.cn/2018/07/18/MySQL%20%E4%B8%8E%20Python%20%E4%BA%A4%E4%BA%92(%E4%BA%94)/"/>
    <id>http://jovelin.cn/2018/07/18/MySQL 与 Python 交互(五)/</id>
    <published>2018-07-17T21:00:01.000Z</published>
    <updated>2018-07-28T02:57:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>Python 与 MySQL 的交互流程；</li><li>Connection 连接对象；</li><li>Cursor 对象；</li><li>sql 语句的参数化。</li></ol></blockquote><a id="more"></a><h3 id="一、Python-操作-MySQL-步骤-重点"><a href="#一、Python-操作-MySQL-步骤-重点" class="headerlink" title="一、Python 操作 MySQL 步骤(重点)"></a>一、Python 操作 MySQL 步骤(重点)</h3><h4 id="1-Python-与-MySQL-的交互"><a href="#1-Python-与-MySQL-的交互" class="headerlink" title="1. Python 与 MySQL 的交互"></a>1. Python 与 MySQL 的交互</h4><p><img src="https://upload-images.jianshu.io/upload_images/3365001-a63383fefa17d1f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Python与Mysql的交互.png"></p><h4 id="2-Python-访问数据库流程"><a href="#2-Python-访问数据库流程" class="headerlink" title="2. Python 访问数据库流程"></a>2. Python 访问数据库流程</h4><blockquote><p>提示：引入pymysql模块，通过该模块的api来访问mysql数据库(查看源码)</p></blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>创建一个Connection连接对象</span><br><span class="line"><span class="bullet">2. </span>通过Connection连接对象取得游标Cursor对象</span><br><span class="line"><span class="bullet">3. </span>通过游标执行Sql语句</span><br><span class="line"><span class="bullet">4. </span>通过游标获取执行结果</span><br><span class="line"><span class="bullet">5. </span>依据业务处理执行结果</span><br><span class="line"><span class="bullet">6. </span>关闭游标</span><br><span class="line"><span class="bullet">7. </span>关闭连接</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/3365001-8b8f1ca7bcda9100.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用Python DB API访问数据库流程.jpg"></p><h4 id="3-连接数据库对象"><a href="#3-连接数据库对象" class="headerlink" title="3. 连接数据库对象"></a>3. 连接数据库对象</h4><blockquote><p>快速写入conn连接代码的快捷技巧： <a href="http://note.youdao.com/noteshare?id=e7cdc06d7c2773263936a4b45c5e31a8" target="_blank" rel="noopener">PyCharm 快速输入技巧：Live Templates（自定义代码扩展）</a></p></blockquote><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">conn = pymysql.connect(参数列表)</span><br><span class="line">参数host：连接的mysql主机，如果本机是<span class="string">'localhost'</span></span><br><span class="line">参数port：连接的mysql主机的端口，默认是<span class="number">3306</span></span><br><span class="line">参数database：数据库的名称</span><br><span class="line">参数<span class="keyword">user</span>：连接的用户名</span><br><span class="line">参数password：连接的密码</span><br><span class="line">参数charset：通信采用的编码方式，推荐使用utf8</span><br><span class="line"></span><br><span class="line">conn.cursor()  <span class="comment"># 返回Cursor对象，用于执行sql语句并获得结果</span></span><br><span class="line">conn.commit()  <span class="comment"># 提交事务,当涉及增删改时，需要保存数据(持久化)到数据库中</span></span><br><span class="line">conn.close()  <span class="comment"># 关闭连接</span></span><br></pre></td></tr></table></figure><h4 id="4-Cursor-对象"><a href="#4-Cursor-对象" class="headerlink" title="4. Cursor 对象"></a>4. Cursor 对象</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cs_tuple = conn.cursor()  <span class="comment"># 默认为元组游标</span></span><br><span class="line"></span><br><span class="line">cs_tuple.close()  <span class="comment"># 关闭</span></span><br><span class="line">cs_tuple.execute(operation [, parameters ])  <span class="comment"># 执行语句，返回受影响的行数，主要用于执行select、insert、update、delete语句，也可以执行create、alter、drop等语句</span></span><br><span class="line">cs_tuple.fetchone()  <span class="comment"># 执行查询语句时，获取查询结果集的第一个行数据，返回一个元组</span></span><br><span class="line">cs_tuple.fetchall()  <span class="comment"># 执行查询时，获取结果集的所有行，一行构成一个元组，再将这些元组装入一个元组返回</span></span><br></pre></td></tr></table></figure><h4 id="5-Cursor-对表的增删改查"><a href="#5-Cursor-对表的增删改查" class="headerlink" title="5. Cursor 对表的增删改查"></a>5. Cursor 对表的增删改查</h4><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line">    Cursor：是一个生成器/迭代器</span><br><span class="line">    <span class="number">1</span>. cs1 = conn.<span class="built_in">cursor</span>()  # 取得元组Cursor</span><br><span class="line">    <span class="number">2</span>. cs1 = conn.<span class="built_in">cursor</span>(<span class="built_in">cursor</span>=pymysql.cursors.DictCursor)  # 取得字典Cursor，结果集是以字典的形式呈现的</span><br><span class="line">    <span class="number">3</span>. 对数据库进行增删改时，需要执行connection.commit()提交命令，把修改的数据持久化到数据库中(没有 commit 前是在内存中进行操作的)</span><br><span class="line">  </span><br><span class="line">查询</span><br><span class="line">    cs1.<span class="keyword">execute</span>(sql, <span class="keyword">args</span>)</span><br><span class="line">    <span class="built_in">cursor</span>.fetchone()  # 从结果集中抓取单条记录</span><br><span class="line">    <span class="built_in">cursor</span>.fetchall()  # 从结果集中抓取全部记录</span><br><span class="line">    </span><br><span class="line">    item = cs_dict.fetchone()  # 从结果集抓取一条数据，默认从第一个位置开始（抓取一次，游标下移一位，全部抓取完后，后面再抓取数据就为空）</span><br><span class="line">    <span class="keyword">print</span>(item[<span class="string">"name"</span>], item[<span class="string">"price"</span>])  # 字典</span><br><span class="line"></span><br><span class="line">增删改</span><br><span class="line">    <span class="built_in">cursor</span>.<span class="keyword">execute</span>(sql, <span class="keyword">args</span>)</span><br><span class="line">    conn.commit()</span><br></pre></td></tr></table></figure><h4 id="6-sql-语句的参数化"><a href="#6-sql-语句的参数化" class="headerlink" title="6. sql 语句的参数化"></a>6. sql 语句的参数化</h4><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 目的：通过sql参数化可以防止用户通过sql注入方式盗取数据</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 出现的问题：</span><br><span class="line"></span><br><span class="line">query_name = input(<span class="string">"请输入要查询的名称:"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户输入的值如下：</span></span><br><span class="line">query_name = <span class="string">' or 1 or '</span></span><br><span class="line">query_name = <span class="string">' or 1=1 or '</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sql字符串格式化后，会出现查询条件恒为True，即把所有数据都查询出来</span></span><br><span class="line">sql = <span class="string">"select * from goods WHERE name='%s'"</span> % sname  </span><br><span class="line">sql= select * <span class="built_in">from</span> goods WHERE name=<span class="string">''</span> <span class="keyword">or</span> <span class="number">1</span> <span class="keyword">or</span> <span class="string">''</span></span><br><span class="line">sql = select * <span class="built_in">from</span> goods WHERE name=<span class="string">''</span> <span class="keyword">or</span> <span class="number">1</span>=<span class="number">1</span> <span class="keyword">or</span> <span class="string">''</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行sql语句</span></span><br><span class="line">cs1.execute(sql)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 解决办法:</span><br><span class="line"></span><br><span class="line">sname=input(<span class="string">"请输入要查询的名称:"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不用开发者自己拼接字符串</span></span><br><span class="line">    sql = <span class="string">"select * from goods WHERE name=%s"</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">params</span> = [sname]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把sname作为sql参数传入到execute中，由sql的api来过滤一些特殊的字符</span></span><br><span class="line">affect_num = cs1.execute(sql, <span class="built_in">params</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 模糊查询</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- like</span></span><br><span class="line">    sql = <span class="string">"select * from goods WHERE name like %s"</span></span><br><span class="line">    <span class="built_in">params</span> = [<span class="string">'%%%s%%'</span>%key_name]  <span class="comment"># %笔记本%，注意：% 需要转义， _不需要转义</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- rlike</span></span><br><span class="line">    sql = <span class="string">"select * from goods WHERE name rlike %s"</span>  <span class="comment"># 正则实现模糊查询</span></span><br><span class="line">    <span class="built_in">params</span> = [query_key]  <span class="comment"># 正则</span></span><br><span class="line">    </span><br><span class="line">    affect_rows = cs1.execute(sql, <span class="built_in">params</span>)</span><br><span class="line">    print(<span class="string">"影响的行数:"</span>, affect_rows)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Python 与 MySQL 的交互流程；&lt;/li&gt;
&lt;li&gt;Connection 连接对象；&lt;/li&gt;
&lt;li&gt;Cursor 对象；&lt;/li&gt;
&lt;li&gt;sql 语句的参数化。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/categories/Python/MySQL/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 高级提升(四)</title>
    <link href="http://jovelin.cn/2018/07/18/MySQL%20%E9%AB%98%E7%BA%A7%E6%8F%90%E5%8D%87(%E5%9B%9B)/"/>
    <id>http://jovelin.cn/2018/07/18/MySQL 高级提升(四)/</id>
    <published>2018-07-17T20:00:01.000Z</published>
    <updated>2018-07-28T01:50:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>视图的作用、特点以及使用；</li><li>事务的 ACID 特性以及使用；</li><li>面试题：对索引的认识以及使用；</li><li>数据库的设计：E-R 模型、三范式。</li></ol></blockquote><a id="more"></a><h3 id="一、视图"><a href="#一、视图" class="headerlink" title="一、视图"></a>一、视图</h3><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">1. 掌握视图的作用、特点以及如何使用</span><br><span class="line"></span><br><span class="line">特点： </span><br><span class="line">    视图是对若干张基本表的引用，一张虚表，查询语句执行的结果</span><br><span class="line">    不存储具体的数据（基本表数据发生了改变，视图也会跟着改变） </span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">    1. <span class="keyword">create</span> <span class="keyword">view</span> 视图名称 <span class="keyword">as</span> <span class="keyword">select</span> ...</span><br><span class="line">    <span class="number">2.</span> <span class="keyword">select</span> * <span class="keyword">from</span> 视图</span><br><span class="line">    <span class="number">3.</span> <span class="keyword">drop</span> <span class="keyword">view</span> 视图名称</span><br><span class="line">    </span><br><span class="line">作用：视图的优缺点（面试：谈一谈对视图的认识）</span><br><span class="line"></span><br><span class="line">a&gt;优点:</span><br><span class="line"><span class="number">1.</span> 简化查询操作</span><br><span class="line">对于复杂的查询，往往是有多个数据表进行关联查询而得到,对于这个复杂的查询结果保存为一个视图，便于下一次查询时简化查询操作</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 逻辑上的独立性，屏蔽了真实表结构更改带来的影响</span><br><span class="line">视图可以使应用程序和数据库表在一定程度上独立。如果没有视图，应用一定是建立在表上的。有了视图之后，程序可以建立在视图之上，从而程序与数据库表被视图分割开来。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 视图能够对机密数据提供一定安全保护</span><br><span class="line">因为视图是虚拟的，物理上是不存在的，只是存储了数据的集合，我们可以将基表中重要的字段信息，可以不通过视图给用户</span><br><span class="line"></span><br><span class="line">b&gt; 不足：</span><br><span class="line">    <span class="number">1.</span> 性能差</span><br><span class="line">对视图(<span class="keyword">select</span>)的查询最终转换为对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，也会花费一定时间</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 额外增加数据库的复杂度</span><br></pre></td></tr></table></figure><h3 id="二、事务"><a href="#二、事务" class="headerlink" title="二、事务"></a>二、事务</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">在Python中，打开一个连接，默认会开启事务，针对增删改，需要事务的提交 conn.commit()</span><br><span class="line"></span><br><span class="line">遇到的问题？</span><br><span class="line">银行转账分为2部分</span><br><span class="line">1. A账号转出1000元</span><br><span class="line">2. B账号转入1000元</span><br><span class="line">两部分操作是不可分割的，要么一起成功，要么一起失败</span><br><span class="line">解决方案： 使用事务</span><br><span class="line"></span><br><span class="line">1. 事务是什么</span><br><span class="line"></span><br><span class="line">所谓事务,它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的执行单位</span><br><span class="line"></span><br><span class="line">2. 事务的ACID特性 (面试题：事务的ACID是什么)</span><br><span class="line">   </span><br><span class="line"><span class="meta">a&gt;</span><span class="bash"> 原子性(Atomic)： 语句不可分割，要么同时执行，要么同时不执行</span></span><br><span class="line"><span class="meta">b&gt;</span><span class="bash"> 一致性(Consistency): 数据库总是从一个一致性的状态转换到另一个一致性的状态</span></span><br><span class="line"><span class="meta">c&gt;</span><span class="bash"> 隔离性(Isolation)：通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的</span></span><br><span class="line"><span class="meta">d&gt;</span><span class="bash"> 持久性(Durability)</span></span><br><span class="line">    一旦事务提交，则其所做的修改会永久保存到数据库</span><br><span class="line">   </span><br><span class="line">3. mysql事务的使用</span><br><span class="line"></span><br><span class="line">1. 开启事务命令</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启事务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> start transaction;</span></span><br><span class="line">begin;  </span><br><span class="line">2. 提交事务命令</span><br><span class="line">    commit；</span><br><span class="line">3. 事务回滚命令</span><br><span class="line">rollback;</span><br><span class="line"></span><br><span class="line">4. 事务的提示：</span><br><span class="line"></span><br><span class="line">1. innodb引擎支持事务(默认的引擎)，MyISAM不支持事务</span><br><span class="line">2. 使用终端操作数据库(也就是mysql的客户端)的时候 也是默认开始事物的，只是在回车确认操作的时候 终端会默认执行commit 所以我们不需要手动commit。但假如手动调用begin时，就需要手动调用commit提交事务</span><br><span class="line">3. 使用python操作数据库的时候 默认开启事务的 </span><br><span class="line">4. 但是python对数据库进行增删改的时候 需要手动commit</span><br></pre></td></tr></table></figure><h3 id="三、索引"><a href="#三、索引" class="headerlink" title="三、索引"></a>三、索引</h3><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">遇到问题1：</span><br><span class="line">    如何快速查字典的单词，快速找一本书中的某章节的具体内容？</span><br><span class="line">遇到问题2：</span><br><span class="line">    当数据库中数据量很大时，查找数据会变得很慢，如何优化查询？</span><br><span class="line">解决方案：使用索引</span><br><span class="line"></span><br><span class="line">1. 什么是索引</span><br><span class="line">索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</span><br><span class="line">索引就好比是一本书前面的目录，能加快数据库的查询速度</span><br><span class="line"></span><br><span class="line">2. 索引原理(了解)</span><br><span class="line">    思想： 不断缩小查找范围</span><br><span class="line">    内部具体实现方案： B+Tree实现</span><br><span class="line">        数据分析： 数据结构</span><br><span class="line">        线性表，二叉树，三叉数， 队列， 栈 </span><br><span class="line"></span><br><span class="line">3. 索引的使用</span><br><span class="line">a&gt; 查看索引</span><br><span class="line">show <span class="keyword">index</span> <span class="keyword">from</span> 表名;</span><br><span class="line">show <span class="keyword">index</span> <span class="keyword">from</span> goods;</span><br><span class="line"></span><br><span class="line">b&gt; 创建索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> 索引名称 <span class="keyword">on</span> 表名(字段名称(长度))</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> name_index <span class="keyword">on</span> goods(name(<span class="number">150</span>));</span><br><span class="line"></span><br><span class="line">c&gt; 删除索引</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> 索引名称 <span class="keyword">on</span> 表名;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> name_index <span class="keyword">on</span> goods;</span><br><span class="line"></span><br><span class="line">4. 索引优化查询测试</span><br><span class="line">1. 创建表 t_news(新闻)表</span><br><span class="line">   <span class="keyword">create</span> table t_news(<span class="built_in">title</span> varchar(<span class="number">10</span>));</span><br><span class="line">2. 通过python程序向t_news表添加10万条记录</span><br><span class="line"><span class="number">3.</span> 测试有无索引的查询效率</span><br><span class="line"><span class="keyword">set</span> profiling=<span class="number">1</span>; # 开启时间检测</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_news <span class="keyword">where</span> <span class="built_in">title</span>=<span class="string">'ha-80000'</span>; # 建立索引之前执行查询</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> title_index <span class="keyword">on</span> t_news(<span class="built_in">title</span>(<span class="number">10</span>)); # 创建索引之后执行查询</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_news <span class="keyword">where</span> <span class="built_in">title</span>=<span class="string">'ha-80000'</span>; </span><br><span class="line">show profiles; # 显示执行简表</span><br><span class="line"></span><br><span class="line">5. 索引注意点(面试题:谈谈你对索引的认识):</span><br><span class="line">    1. 索引最主要解决的问题:当数据量较大时,且这些数据不需要经常修改,使用索引来加快查询速度</span><br><span class="line">2. 对于比较小的表，查询开销不会很大，也没有必要建立另外的索引</span><br><span class="line">3. 建立太多的索引将会影响更新和插入的速度，因为它需要同样更新每个索引文件</span><br><span class="line">4. 对于一个经常需要更新和插入的表格，就没有必要为一个很少使用的where字句单独建立索引了 </span><br><span class="line">5. 建立索引会占用磁盘空间</span><br></pre></td></tr></table></figure><h3 id="四、数据库的设计"><a href="#四、数据库的设计" class="headerlink" title="四、数据库的设计"></a>四、数据库的设计</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">E-R模型：实体关系模型</span><br><span class="line">    1. 一对一</span><br><span class="line">    2. 一对多</span><br><span class="line">    3. 多对一</span><br><span class="line">    4. 多对多</span><br><span class="line">    </span><br><span class="line">三范式</span><br><span class="line">    1NF： 列不能再分割</span><br><span class="line">    2NF： 基于1NF，有主键，非主键要依赖主键</span><br><span class="line">    3NF ：基于2NF，不能传递依赖主键</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. E-R模型(Entity-Relationship Model)</span><br><span class="line"></span><br><span class="line">关系型数据库是建立在实体关系模型(E-R模型)基础之上,再开展数据库的分析与设计</span><br><span class="line">        基于面向对象思想的分析与设计</span><br><span class="line">        </span><br><span class="line">        面向对象的分析与设计：</span><br><span class="line">            1. 同学  2. 老师  3. 班级  4. 教室</span><br><span class="line">            实体-关系模型 </span><br><span class="line"></span><br><span class="line">在项目开发中，一般会先设计好数据库，数据库开发一般是项目开发的第一步</span><br><span class="line"><span class="meta">a&gt;</span><span class="bash"> 实体(Entry)</span></span><br><span class="line">实体设计就好比定义一个类一样，指定从哪些方面来描述对象，一个实体可以转换为数据库中的一个表</span><br><span class="line"></span><br><span class="line"><span class="meta">b&gt;</span><span class="bash"> 关系(Relationship)</span></span><br><span class="line">描述两个实体之间的对应规则</span><br><span class="line">1. 一对一：</span><br><span class="line">一个萝卜一个坑</span><br><span class="line">学生与指纹</span><br><span class="line">员工和工资卡</span><br><span class="line"></span><br><span class="line">2. 一对多</span><br><span class="line">班级与学生</span><br><span class="line">客户与订单</span><br><span class="line">部门与员工</span><br><span class="line"></span><br><span class="line">3. 多对一</span><br><span class="line">学生与班级</span><br><span class="line">员工与部门</span><br><span class="line"></span><br><span class="line">4. 多对多关系</span><br><span class="line">  学生与社团</span><br><span class="line">  运动员与比赛项目</span><br><span class="line"></span><br><span class="line">2. 三范式:</span><br><span class="line"></span><br><span class="line">为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式</span><br><span class="line">数据库的范式越高，则数据冗余越少，但是会导致查询效率降低，一般数据库设计满足第三范式，就很好了</span><br><span class="line"></span><br><span class="line"><span class="meta">a&gt;</span><span class="bash"> 第一范式 1NF </span></span><br><span class="line">强调的是列的原子性，即列不能够再分成其他几列 </span><br><span class="line"></span><br><span class="line"><span class="meta">b&gt;</span><span class="bash"> 第二范式</span></span><br><span class="line">首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键</span><br><span class="line">   依据主键能够推导出其他字段的信息</span><br><span class="line"></span><br><span class="line"><span class="meta">c&gt;</span><span class="bash"> 第三范式</span></span><br><span class="line">首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;视图的作用、特点以及使用；&lt;/li&gt;
&lt;li&gt;事务的 ACID 特性以及使用；&lt;/li&gt;
&lt;li&gt;面试题：对索引的认识以及使用；&lt;/li&gt;
&lt;li&gt;数据库的设计：E-R 模型、三范式。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/categories/Python/MySQL/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 外键使用(三)</title>
    <link href="http://jovelin.cn/2018/07/18/MySQL%20%E5%A4%96%E9%94%AE%E4%BD%BF%E7%94%A8(%E4%B8%89)/"/>
    <id>http://jovelin.cn/2018/07/18/MySQL 外键使用(三)/</id>
    <published>2018-07-17T19:00:01.000Z</published>
    <updated>2018-07-28T01:49:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>外键概念；</li><li>外键的创建和删除使用；</li><li>面试题：在目前主流的数据库设计中，为什么越来越少使用到外键约束？</li></ol></blockquote><a id="more"></a><h3 id="外键的概念和使用"><a href="#外键的概念和使用" class="headerlink" title="外键的概念和使用"></a>外键的概念和使用</h3><h5 id="1-外键概念："><a href="#1-外键概念：" class="headerlink" title="1. 外键概念："></a>1. 外键概念：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前表的某个字段是另一个的主键</span><br></pre></td></tr></table></figure><h5 id="2-创建外键"><a href="#2-创建外键" class="headerlink" title="2. 创建外键:"></a>2. 创建外键:</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表时就添加</span></span><br><span class="line">foreign key(brand_id) references goods_brands(id)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建完表后添加</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> goods <span class="keyword">add</span> foreign <span class="keyword">key</span>(brand_id) <span class="keyword">references</span> goods_brands(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure><h5 id="3-删除外键"><a href="#3-删除外键" class="headerlink" title="3. 删除外键:"></a>3. 删除外键:</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> goods <span class="keyword">drop</span> foreign <span class="keyword">key</span> goods_ibfk_1;</span><br></pre></td></tr></table></figure><h5 id="4-涉及外键的面试"><a href="#4-涉及外键的面试" class="headerlink" title="4. 涉及外键的面试"></a>4. 涉及外键的面试</h5><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">在目前主流的数据库设计中，为什么越来越少使用到外键约束？</span><br><span class="line"></span><br><span class="line">    原因： 会极大的降低表更新的效率</span><br><span class="line">如何替代 <span class="string">'通过外键约束实现数据有效性验证'</span></span><br><span class="line">解决思想： 可在数据录入时验证<span class="comment">(UI 层、表示层、前端页面)</span>，或者在业务层面<span class="comment">(python代码)</span>去验证，而不要数据库层面去验证。</span><br><span class="line"></span><br><span class="line">M<span class="attr">VC 三层模型：</span></span><br><span class="line"><span class="attr">    1</span>. UI 层（表示层）</span><br><span class="line">    <span class="number">2.</span> 业务逻辑层</span><br><span class="line">    <span class="number">3.</span> 数据库层</span><br></pre></td></tr></table></figure><blockquote><p>Mysql 增加、删除外键详细：<a href="https://blog.csdn.net/qq_34988341/article/details/78305892" target="_blank" rel="noopener">https://blog.csdn.net/qq_34988341/article/details/78305892</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;外键概念；&lt;/li&gt;
&lt;li&gt;外键的创建和删除使用；&lt;/li&gt;
&lt;li&gt;面试题：在目前主流的数据库设计中，为什么越来越少使用到外键约束？&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/categories/Python/MySQL/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 命令语句(二)</title>
    <link href="http://jovelin.cn/2018/07/18/MySQL%20%E5%91%BD%E4%BB%A4%E8%AF%AD%E5%8F%A5(%E4%BA%8C)/"/>
    <id>http://jovelin.cn/2018/07/18/MySQL 命令语句(二)/</id>
    <published>2018-07-17T18:00:01.000Z</published>
    <updated>2018-07-28T02:04:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>使用命令行启动、登录 MySQL 数据库；</li><li>数据库、数据表和数据(记录)的增删查改；</li><li>数据(记录)的高级查询；</li><li>数据库的备份与恢复。</li></ol></blockquote><a id="more"></a><h3 id="一、基本命令行"><a href="#一、基本命令行" class="headerlink" title="一、基本命令行"></a>一、基本命令行</h3><h4 id="1-MySQL-服务器操作"><a href="#1-MySQL-服务器操作" class="headerlink" title="1. MySQL 服务器操作"></a>1. MySQL 服务器操作</h4><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">启动: sudo service mysql start</span><br><span class="line">查看: <span class="keyword">ps</span> -aux | <span class="keyword">grep</span> <span class="string">'mysql'</span></span><br><span class="line">停止: sudo service mysql <span class="keyword">stop</span></span><br><span class="line">重启：sudo service mysql restart</span><br></pre></td></tr></table></figure><!-- more --><h4 id="2-MySQL-客户端操作"><a href="#2-MySQL-客户端操作" class="headerlink" title="2. MySQL 客户端操作"></a>2. MySQL 客户端操作</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">登录: mysql -u root -p</span><br><span class="line">退出: <span class="keyword">exit</span><span class="regexp">/quit</span></span><br></pre></td></tr></table></figure><h4 id="3-数据库操作"><a href="#3-数据库操作" class="headerlink" title="3. 数据库操作"></a>3. 数据库操作</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">数据库操作：使用、查看、创建、删除</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 使用数据库</span></span><br><span class="line">    <span class="keyword">use</span> db_xxx;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 查看所有数据库</span></span><br><span class="line">    <span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 查看当前数据库</span></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">database</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 创建</span></span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">database</span> db_xxx <span class="keyword">charset</span>=utf8;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 查看创建语句</span></span><br><span class="line">    <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">database</span> db_xxx;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 删除</span></span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">database</span> db_xxx;</span><br></pre></td></tr></table></figure><h4 id="4-数据表操作"><a href="#4-数据表操作" class="headerlink" title="4. 数据表操作"></a>4. 数据表操作</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">数据表操作：查看、创建、修改、删除</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 查看</span></span><br><span class="line">    <span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 创建</span></span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> 数据表名字 (字段 类型 约束[, 字段 类型 约束]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 修改</span></span><br><span class="line">    <span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span>|<span class="keyword">modify</span>|<span class="keyword">change</span>|<span class="keyword">drop</span> 列名 类型及约束;</span><br><span class="line">        <span class="comment">-- 添加字段 </span></span><br><span class="line">        <span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 类型;</span><br><span class="line">        <span class="comment">-- 修改字段：不重命名版</span></span><br><span class="line">        <span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">modify</span> 列名 类型及约束;</span><br><span class="line">        <span class="comment">-- 修改字段：重命名版</span></span><br><span class="line">        <span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">change</span> 原名 新名 类型及约束;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 删除</span></span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br></pre></td></tr></table></figure><h4 id="5-数据-记录-的增删改查curd"><a href="#5-数据-记录-的增删改查curd" class="headerlink" title="5. 数据(记录)的增删改查curd"></a>5. 数据(记录)的增删改查curd</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">对数据表中数据的操作：增加、删除、修改和基本查询</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 新增</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> 表名(列<span class="number">1</span>,...) <span class="keyword">values</span>(值<span class="number">1</span>,...)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 删除</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 修改</span></span><br><span class="line">    <span class="keyword">update</span> 表名 <span class="keyword">set</span> 列<span class="number">1</span>=值<span class="number">1</span>,列<span class="number">2</span>=值<span class="number">2.</span>.. <span class="keyword">where</span> 条件;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 基本查询</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><h3 id="二、高级查询"><a href="#二、高级查询" class="headerlink" title="二、高级查询"></a>二、高级查询</h3><h4 id="1-基本查询"><a href="#1-基本查询" class="headerlink" title="1.基本查询"></a>1.基本查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1. 查询所有字段、指定字段的数据</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> students;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">name</span>,age <span class="keyword">from</span> students;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 消除重复行命令distinct</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> gender <span class="keyword">from</span> students;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. as给字段、表起别名</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> s.name <span class="keyword">as</span> <span class="string">'姓名'</span>,s.age <span class="keyword">as</span> <span class="string">'年龄'</span> <span class="keyword">from</span> students <span class="keyword">as</span> s;</span><br></pre></td></tr></table></figure><h4 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2.条件查询"></a>2.条件查询</h4><figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">where</span>后跟比较运算符、逻辑运算符</span><br><span class="line"></span><br><span class="line">    比较运算符：&gt;   &lt;   &gt;=  &lt;=  =   !=</span><br><span class="line">    逻辑运算符：<span class="keyword">and</span> <span class="keyword">or</span> <span class="keyword">not</span> </span><br><span class="line"></span><br><span class="line">    -- 优先级：<span class="keyword">not</span>&gt;<span class="keyword">and</span>&gt;<span class="keyword">or</span>，如果同时出现并希望先算<span class="keyword">or</span>，需要结合()使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 模糊查询<span class="keyword">like</span>和范围查询<span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">    name <span class="keyword">like</span> <span class="comment">'%杰'</span></span><br><span class="line">        % ： 代表任意个字符</span><br><span class="line">        _ : 代表一个字符</span><br><span class="line">    </span><br><span class="line">    id  <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 空判断<span class="keyword">is</span> null和非空判断<span class="keyword">is</span> <span class="keyword">not</span> null</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> height <span class="keyword">is</span> null;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span>  height <span class="keyword">is</span> <span class="keyword">not</span> null;</span><br></pre></td></tr></table></figure><h4 id="3-排序"><a href="#3-排序" class="headerlink" title="3. 排序"></a>3. 排序</h4><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">放在 <span class="keyword">from</span>、<span class="keyword">where</span>、<span class="keyword">group</span> <span class="keyword">by</span>之后</span><br><span class="line"></span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> 列<span class="number">1</span> <span class="keyword">asc</span> ，列<span class="number">2</span> <span class="keyword">desc</span>；</span><br><span class="line">    <span class="keyword">desc</span>: 降序</span><br><span class="line">    <span class="keyword">asc</span>：升序，默认</span><br></pre></td></tr></table></figure><h4 id="4-聚合函数"><a href="#4-聚合函数" class="headerlink" title="4. 聚合函数"></a>4. 聚合函数</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">count</span><span class="params">(*)</span></span>\count(列)：总数 </span><br><span class="line"><span class="function"><span class="title">max</span><span class="params">(列)</span></span>: 最大值</span><br><span class="line"><span class="function"><span class="title">min</span><span class="params">(列)</span></span>: 最小值</span><br><span class="line"><span class="function"><span class="title">sum</span><span class="params">(列)</span></span>：求和</span><br><span class="line"><span class="function"><span class="title">avg</span><span class="params">(列)</span></span>：求平均</span><br></pre></td></tr></table></figure><blockquote><p>round(avg(price),2) : 四舍五入, 保留两位小数</p></blockquote><h4 id="5-分组查询"><a href="#5-分组查询" class="headerlink" title="5. 分组查询"></a>5. 分组查询</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">group by + group_concat(字段名)/聚合函数/having</span><br><span class="line"></span><br><span class="line">更精细化统计</span><br><span class="line">   <span class="built_in"> group </span>by： 分组</span><br><span class="line">    group_concat： 拼接字符串，拼接字段名</span><br><span class="line">    聚合函数： 最大，最小，平均，计数，求和</span><br><span class="line">    having： 对分组后的结果集进一步筛选</span><br><span class="line"></span><br><span class="line">注意1: </span><br><span class="line">    select 列中只能存放分组函数(比如聚合函数)，或是出现在group by子句中的分组标签</span><br><span class="line">    </span><br><span class="line">注意2：</span><br><span class="line">    where: 对源数据做条件筛选，不能接聚合函数</span><br><span class="line">    having: 是对分组之后的数据做进一步的筛选操作, 有having就一定有group by, 有<span class="built_in"> group </span>by 不一定有having，接聚合函数</span><br></pre></td></tr></table></figure><h4 id="6-分页查询"><a href="#6-分页查询" class="headerlink" title="6. 分页查询"></a>6. 分页查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">limit [<span class="keyword">start</span>],<span class="keyword">count</span> </span><br><span class="line"></span><br><span class="line">    <span class="number">1.</span> 放在查询语句的最后</span><br><span class="line">    <span class="number">2.</span> <span class="keyword">start</span>=(page<span class="number">-1</span>)*<span class="keyword">count</span></span><br></pre></td></tr></table></figure><h4 id="7-连接查询"><a href="#7-连接查询" class="headerlink" title="7. 连接查询"></a>7. 连接查询</h4><figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">inner <span class="built_in">join</span> <span class="keyword">on</span> : 内连接(结果仅包含符合连接条件的两表中的行)</span><br><span class="line"></span><br><span class="line"><span class="built_in">left</span> <span class="built_in">join</span> <span class="keyword">on</span> : 左连接(完全显示左表所有的行，如果左表中某行 在右表中没有匹配的行，则右表该行显示<span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">right</span> <span class="built_in">join</span> <span class="keyword">on</span> : 右连接(与左连接相反)</span><br></pre></td></tr></table></figure><h4 id="8-子查询"><a href="#8-子查询" class="headerlink" title="8. 子查询"></a>8. 子查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查询中嵌套查询：</span><br><span class="line">分为三种：</span><br><span class="line">    1.标量子查询: 子查询的结果为一个值(一行一列)</span><br><span class="line">    2.列子查询：  子查询的结果为一个列(一列多行)</span><br><span class="line">    3.表子查询:   子查询的结果为一个表(多行多列)</span><br><span class="line">    </span><br><span class="line">例子：</span><br><span class="line">    1. 查出高于平均身高的信息</span><br><span class="line">        1. (<span class="keyword">select</span> <span class="keyword">avg</span>(height) <span class="keyword">from</span> students) // 结果：<span class="number">172</span></span><br><span class="line">    <span class="number">2.</span> <span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> height&gt;(<span class="keyword">select</span> <span class="keyword">avg</span>(height) <span class="keyword">from</span> students);</span><br><span class="line">    </span><br><span class="line">2. 查出能够对应上班级号的学生信息</span><br><span class="line">    1. (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> classes)  // 结果：<span class="keyword">list</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="number">2.</span> <span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> cls_id <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> classes);</span><br><span class="line">  </span><br><span class="line">3. 查询编号小于6的男性同学的姓名</span><br><span class="line">    1. (<span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> <span class="keyword">id</span>&lt;<span class="number">6</span>) // 结果：一张表</span><br><span class="line">    <span class="number">2.</span> <span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> <span class="keyword">id</span>&lt;<span class="number">6</span>) <span class="keyword">as</span> s  <span class="keyword">where</span> gender=<span class="string">'男'</span>;</span><br></pre></td></tr></table></figure><h4 id="9-自关联查询"><a href="#9-自关联查询" class="headerlink" title="9. 自关联查询"></a>9. 自关联查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">通俗讲，就是自己关联自己,再通过内连接实现数据查询</span><br><span class="line"></span><br><span class="line">1. 向areas插入记录</span><br><span class="line">    source areas.sql;</span><br><span class="line">提示：areas.sql 文件要存放在 mysql 登录的目录中</span><br><span class="line"></span><br><span class="line">2. 查询广东省中的所有城市</span><br><span class="line">    第一种方式(两条sql语句)：</span><br><span class="line">        1. 查广东省的id</span><br><span class="line">        <span class="keyword">select</span> aid  <span class="keyword">from</span> areas <span class="keyword">where</span> atitle=<span class="string">'广东省'</span>; // 440000 </span><br><span class="line"></span><br><span class="line">        2. 再把省的id作为pid，查出对应的城市信息</span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> areas <span class="keyword">where</span> pid=<span class="number">440000</span>;</span><br><span class="line"></span><br><span class="line">    第二种方式(子查询)：</span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> areas <span class="keyword">where</span> pid=(<span class="keyword">select</span> aid <span class="keyword">from</span> areas <span class="keyword">where</span> atitle=<span class="string">'广东省'</span>);</span><br><span class="line"></span><br><span class="line">    第三种方式(自关联)： </span><br><span class="line">        <span class="keyword">select</span> city.* <span class="keyword">from</span> areas <span class="keyword">as</span> city <span class="keyword">inner</span> <span class="keyword">join</span> areas <span class="keyword">as</span> province <span class="keyword">on</span> city.pid=province.aid <span class="keyword">where</span> province.atitle=<span class="string">'广东省'</span>;</span><br></pre></td></tr></table></figure><h3 id="三、查询总结"><a href="#三、查询总结" class="headerlink" title="三、查询总结"></a>三、查询总结</h3><ul><li><strong>查询的完整格式 （^_^ 不要被吓到 其实很简单 ! _ !）</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> select_expr [,select_expr,...] [      </span><br><span class="line">      <span class="keyword">FROM</span> tb_name</span><br><span class="line">      [<span class="keyword">WHERE</span> 条件判断]</span><br><span class="line">      [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &#123;col_name | postion&#125; [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>], ...] </span><br><span class="line">      [<span class="keyword">HAVING</span> <span class="keyword">WHERE</span> 条件判断]</span><br><span class="line">      [<span class="keyword">ORDER</span> <span class="keyword">BY</span> &#123;col_name|expr|postion&#125; [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>], ...]</span><br><span class="line">      [ <span class="keyword">LIMIT</span> &#123;[<span class="keyword">offset</span>,]rowcount | <span class="keyword">row_count</span> <span class="keyword">OFFSET</span> <span class="keyword">offset</span>&#125;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li><strong>完整的select语句</strong></li></ul><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">select distinct *</span><br><span class="line">    <span class="keyword">from</span> tb_name</span><br><span class="line">    where <span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">   <span class="built_in"> group </span>by <span class="built_in">..</span>. having <span class="built_in">..</span>.</span><br><span class="line">    order by <span class="built_in">..</span>.</span><br><span class="line">    limit start,count</span><br></pre></td></tr></table></figure><ul><li><strong>执行顺序</strong></li></ul><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tb_name</span><br><span class="line">    where <span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">   <span class="built_in"> group </span>by <span class="built_in">..</span>.</span><br><span class="line">    select distinct *</span><br><span class="line">    having <span class="built_in">..</span>.</span><br><span class="line">    order by <span class="built_in">..</span>.</span><br><span class="line">    limit start,count</span><br></pre></td></tr></table></figure><blockquote><p>实际使用中，只是语句中某些部分的组合，而不是全部</p></blockquote><h3 id="四、备份-还原"><a href="#四、备份-还原" class="headerlink" title="四、备份/还原"></a>四、备份/还原</h3><h5 id="1-备份"><a href="#1-备份" class="headerlink" title="1. 备份"></a>1. 备份</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>冷备份： 数据库停止再备份</span><br><span class="line"></span><br><span class="line"><span class="bullet">2. </span>热备份： 很多情况数据库运行时备份</span><br><span class="line"></span><br><span class="line"><span class="code">    逻辑备份，备份的是数据库相关的sql语句</span></span><br><span class="line"><span class="code">    适合中小型数据的备份</span></span><br><span class="line"></span><br><span class="line"><span class="code">    mysqldump –uroot –p 数据库名 &gt; python.sql;</span></span><br></pre></td></tr></table></figure><h5 id="2-还原"><a href="#2-还原" class="headerlink" title="2. 还原"></a>2. 还原</h5><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">1. 创建新数据库</span><br><span class="line"></span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">database</span> 新数据库名 charset=utf8;</span><br><span class="line"></span><br><span class="line">2. 从sql文件中导入数据</span><br><span class="line"></span><br><span class="line">    mysql -uroot –p 新数据库名 &lt; python.sql</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用命令行启动、登录 MySQL 数据库；&lt;/li&gt;
&lt;li&gt;数据库、数据表和数据(记录)的增删查改；&lt;/li&gt;
&lt;li&gt;数据(记录)的高级查询；&lt;/li&gt;
&lt;li&gt;数据库的备份与恢复。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/categories/Python/MySQL/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/tags/MySQL/"/>
    
      <category term="MySQL 命令" scheme="http://jovelin.cn/tags/MySQL-%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 数据库(一)</title>
    <link href="http://jovelin.cn/2018/07/18/MySQL%20%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%B8%80)/"/>
    <id>http://jovelin.cn/2018/07/18/MySQL 数据库(一)/</id>
    <published>2018-07-17T17:00:01.000Z</published>
    <updated>2018-07-28T02:04:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>关系型数据库 与 RDBMS；</li><li>SQL 和 MySQL 的介绍；</li><li>数据类型与约束。</li></ol></blockquote><a id="more"></a><h3 id="一、数据库介绍"><a href="#一、数据库介绍" class="headerlink" title="一、数据库介绍"></a>一、数据库介绍</h3><h4 id="1-数据存储"><a href="#1-数据存储" class="headerlink" title="1. 数据存储"></a>1. 数据存储</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据库是由一些特殊的文件组成，用来存储数据</span><br></pre></td></tr></table></figure><h4 id="2-数据库分类"><a href="#2-数据库分类" class="headerlink" title="2. 数据库分类"></a>2. 数据库分类</h4><ul><li>关系型数据库</li><li>非关系型数据库</li></ul><!-- more --><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 关系型数据库</span><br><span class="line"></span><br><span class="line">    建立在关系模型基础上的数据库，通俗讲这种数据库由多个表组成，表与表存在一定的关系</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>. 主要的几种关系型数据库</span><br><span class="line"></span><br><span class="line">    oracle：在大型项目中使用,银行,电信等项目</span><br><span class="line">    mysql：web时代使用最广泛的关系型数据库</span><br><span class="line">    <span class="keyword">ms</span> <span class="title">sql</span> server：在微软的项目中使用</span><br><span class="line">    sqlite：轻量级数据库，主要应用在移动平台</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 关系型数据库核心的元素</span><br><span class="line"></span><br><span class="line">    数据行（记录）</span><br><span class="line">    数据列（字段）</span><br><span class="line">    数据表（数据行的集合）</span><br><span class="line">    数据库（数据表的集合）</span><br><span class="line">    主键（特殊的字段，用来唯一标识记录的唯一性）</span><br></pre></td></tr></table></figure><h4 id="3-RDBMS"><a href="#3-RDBMS" class="headerlink" title="3. RDBMS"></a>3. RDBMS</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">1. RDBMS：Relational Database Management System</span><br><span class="line"></span><br><span class="line">    关系型数据库管理系统，用于管理数据库</span><br><span class="line"></span><br><span class="line">2. RDBMS 与关系型数据库的关系</span><br><span class="line">    </span><br><span class="line">    通过 RDBMS 实现对数据库的增删改查</span><br></pre></td></tr></table></figure><h4 id="4-SQL"><a href="#4-SQL" class="headerlink" title="4. SQL"></a>4. SQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SQL(Structured Query Language) 结构化查询语言，是一种用来操作RDBMS的数据库语言，当前关系型数据库都支持使用SQL语言进行操作，</span><br><span class="line">也就是说可以通过 SQL 操作 oracle,sql server,mysql,sqlite 等等所有的关系型的数据库。</span><br><span class="line"></span><br><span class="line">- DQL：数据查询语言，用于对数据进行查询，如<span class="keyword">select</span></span><br><span class="line">- DML：数据操作语言，对数据进行增加、修改、删除，如<span class="keyword">insert</span>、udpate、<span class="keyword">delete</span></span><br><span class="line">- <span class="keyword">DDL</span>：数据定义语言，进行数据库、表的管理等，如<span class="keyword">create</span>、<span class="keyword">drop</span></span><br><span class="line"></span><br><span class="line">- TPL：事务处理语言，对事务进行处理，包括<span class="keyword">begin</span> <span class="keyword">transaction</span>、<span class="keyword">commit</span>、<span class="keyword">rollback</span></span><br><span class="line">- DCL：数据控制语言，进行授权与权限回收，如<span class="keyword">grant</span>、<span class="keyword">revoke</span></span><br><span class="line">- CCL：指针控制语言，通过控制指针完成表的操作，如<span class="keyword">declare</span> <span class="keyword">cursor</span></span><br></pre></td></tr></table></figure><blockquote><p>提示： sql语句不区分大小写，每条sql语句后面加;    </p></blockquote><h4 id="5-MySQL"><a href="#5-MySQL" class="headerlink" title="5. MySQL"></a>5. MySQL</h4><ul><li>MySQL 官方网站：<a href="https://www.mysql.com/" target="_blank" rel="noopener">www.mysql.com</a></li></ul><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">MySQL 是一个关系型数据库管理系统，最早由瑞典 MySQL AB 公司开发，后来被Sun公司收购，</span><br><span class="line">Sun公司后来又被 <span class="keyword">Oracle </span>公司收购，目前属于 <span class="keyword">Oracle </span>旗下产品</span><br><span class="line"></span><br><span class="line">MySQL 对跨平台支持性好，提供了多种主流语言调用的API</span><br><span class="line"></span><br><span class="line">MySQL 市场占有率高，且开源，免费，是中小型项目首选的关系型数据库系统</span><br></pre></td></tr></table></figure><h4 id="6-数据库引擎"><a href="#6-数据库引擎" class="headerlink" title="6. 数据库引擎"></a>6. 数据库引擎</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InnoDB，MyISAM 数据库引擎</span><br><span class="line"></span><br><span class="line">mysql 创建表时，默认是InnoDB引擎</span><br><span class="line"></span><br><span class="line">两种类型有什么区别：</span><br><span class="line">MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。 </span><br><span class="line">MyISAM类型的表强调的是性能，其执行速度比InnoDB类型更快，但是不提供事务等高级特性，而InnoDB提供事务支持,行级锁，高并发。</span><br><span class="line">一般开发中默认使用的是innodb引擎</span><br></pre></td></tr></table></figure><p><br></p><h3 id="二、数据类型与约束"><a href="#二、数据类型与约束" class="headerlink" title="二、数据类型与约束"></a>二、数据类型与约束</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 数据类型：</span><br><span class="line">   使用数据类型的原则是：够用就行，尽量使用取值范围小的，而不用大的，这样可以更多的节省存储空间</span><br><span class="line"></span><br><span class="line">   <span class="number">1.</span> int： 整形</span><br><span class="line"><span class="number">2.</span> bit：位（<span class="number">0</span> | <span class="number">1</span>）</span><br><span class="line"><span class="number">2.</span> decimal： 浮点数  # dicemal(<span class="number">5</span>,<span class="number">2</span>) # 总位数<span class="number">5</span>位，小数位<span class="number">2</span>位</span><br><span class="line"><span class="number">3.</span> varchar： 可变字符类型 # 可节省存储空间</span><br><span class="line"><span class="number">4.</span> enum： 枚举类型 # gender enum(<span class="string">"男"</span>,<span class="string">"女"</span>) 注意：有中文时，数据库编码必须支持中文（utf<span class="number">-8</span> 可以，latin1 不行）</span><br><span class="line"><span class="number">5.</span> datetime： 日期时间类型</span><br><span class="line"><span class="number">6.</span> tinyint： 非贪婪整形</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 数据约束：</span><br><span class="line"><span class="number">1.</span> 主键： primary <span class="type">key</span>(id)</span><br><span class="line"><span class="number">2.</span> 自增： auto_increment</span><br><span class="line"><span class="number">2.</span> 非空： not null</span><br><span class="line"><span class="number">3.</span> 唯一值： unique</span><br><span class="line"><span class="number">4.</span> 缺省值： <span class="section">default</span></span><br><span class="line"><span class="number">5.</span> 外键： foreign <span class="type">key</span> </span><br><span class="line"><span class="number">6.</span> 无符号： unsigned</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关系型数据库 与 RDBMS；&lt;/li&gt;
&lt;li&gt;SQL 和 MySQL 的介绍；&lt;/li&gt;
&lt;li&gt;数据类型与约束。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/categories/Python/MySQL/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Python HTTP 协议与 web 静态服务器</title>
    <link href="http://jovelin.cn/2018/07/15/Python%20HTTP%20%E5%8D%8F%E8%AE%AE%E4%B8%8E%20web%20%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://jovelin.cn/2018/07/15/Python HTTP 协议与 web 静态服务器/</id>
    <published>2018-07-15T12:08:35.000Z</published>
    <updated>2018-07-28T02:31:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>浏览器请求的基本流程；</li><li>浏览器请求的 URL；</li><li>请求报文格式；</li><li>响应报文格式；</li><li>网络响应状态码；</li><li>长连接和短连接。</li></ol></blockquote><a id="more"></a><h1 id="HTTP-超文本传输协议"><a href="#HTTP-超文本传输协议" class="headerlink" title="HTTP 超文本传输协议"></a>HTTP 超文本传输协议</h1><p><strong>超文本传输协议（HyperText Transfer Protocol）是一种应用层协议。</strong></p><p>HTTP是万维网的数据通信的基础。设计HTTP最初的目的是为了提供一种发布和接收HTML页面&lt;网页&gt;的方法。</p><ul><li>1989年蒂姆·伯纳斯-李在CERN研发</li><li>1999年公布现今广泛使用的HTTP 1.1版(RFC2616)</li></ul><h3 id="一、浏览器请求的基本流程"><a href="#一、浏览器请求的基本流程" class="headerlink" title="一、浏览器请求的基本流程"></a>一、浏览器请求的基本流程</h3><p><img src="https://upload-images.jianshu.io/upload_images/3365001-07b4a469d55b38bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="mini-web服务器工作流程"></p><h3 id="二、浏览器请求的-URL"><a href="#二、浏览器请求的-URL" class="headerlink" title="二、浏览器请求的 URL"></a>二、浏览器请求的 URL</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> www.baidu.com: 网站(网址)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   url(统一资源定位符):</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   完整版: http://www.baidu.com:80/aaa/bbb/index.html?username=aaa&amp;password=123</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       http/https: https是http加密后进行传输;(https收费...)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       端口: http: 80;    https: 443;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       /aaa/bbb/index.html: 请求的资源路径;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       username=aaa&amp;password=123: 传输的内容;(请求体...GET)</span></span><br></pre></td></tr></table></figure><h3 id="三、请求报文格式总结"><a href="#三、请求报文格式总结" class="headerlink" title="三、请求报文格式总结"></a>三、请求报文格式总结</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 总结: 请求报文格式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.请求行;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     GET / HTTP/1.1\r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.请求头;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     头属性: 属性值\r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     Host: www.baidu.com\r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.空行;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     \r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.请求体;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     username=jovelin&amp;password=123456</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 请求报文格式分析:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.请求行(request line)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   格式: 请求方式 资源路径 协议及版本号\r\n</span></span><br><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">   GET: 常用请求方式GET/POST;   (GET/POST/PUT/DELETE...)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       GET:  获取(从服务器获取信息的时候用...)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       POST: 发送(向服务器存储信息的时候用...)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   /: /aaa/bbb/index.html; 想要访问的页面/图片/音频...(明天要用...)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   HTTP/1.1: 协议及版本号</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   空行: \r\n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.请求头(request header)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   格式: 头属性: 头信息\r\n</span></span><br><span class="line">Host: www.baidu.com\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       Host: 主机;(记住...)</span></span><br><span class="line">Connection: keep-alive\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       Connection: 链接;(长连接)</span></span><br><span class="line">Upgrade-Insecure-Requests: 1\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       提示服务端我可以解析https;</span></span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       User-Agent: 用户代理;(浏览器及系统版本...)</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       Accept: 接收!</span></span><br><span class="line">Accept-Encoding: gzip, deflate, br\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       压缩: 数据压缩算法;</span></span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       语言: 中文;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.空行;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     \r\n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.请求体;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     username=jovelin&amp;password=123456</span></span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/3365001-28c36634d5de588c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="请求报文格式总结"></p><h3 id="四、响应报文格式总结"><a href="#四、响应报文格式总结" class="headerlink" title="四、响应报文格式总结"></a>四、响应报文格式总结</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 总结: 响应报文格式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.响应行;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   HTTP/1.1 200 OK\r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.响应头;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   头属性: 头信息\r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   Server: BWS/1.1\r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.换行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   \r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.响应体;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   文本/图片/音频/视频/网页...</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 响应报文格式分析:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.响应行(response line)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   格式: 协议及版本号 状态码 英文解释\r\n</span></span><br><span class="line">HTTP/1.1 200 OK\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       HTTP/1.1: 协议及版本号</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       200 OK: 状态码 英文解释</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.响应头(response header)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   格式: 头属性: 属性值\r\n</span></span><br><span class="line">Connection: Keep-Alive\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">   长连接</span></span><br><span class="line">Content-Encoding: gzip\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">   压缩格式</span></span><br><span class="line">Content-Type: text/html; charset=utf-8\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">   请求体的文本类型;</span></span><br><span class="line">Date: Wed, 14 Mar 2018 09:52:48 GMT\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">   更新时间</span></span><br><span class="line">Server: BWS/1.1\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">   服务器名:(记住,因为简单,以后用)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.空行;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     \r\n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.响应体(response body)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     文本/图片/音频/视频/网页...</span></span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/3365001-31f7768dcb76551e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="响应报文格式总结"></p><h3 id="五、网络响应状态码"><a href="#五、网络响应状态码" class="headerlink" title="五、网络响应状态码"></a>五、网络响应状态码</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>xx 成功  <span class="number">200</span> OK  （发送成功）</span><br><span class="line"><span class="number">3</span>xx 重定向 </span><br><span class="line"><span class="number">302</span> Moved Temporarily/<span class="number">302</span> Found   解释作用(暂时跳转)  <span class="number">301</span>/<span class="number">2</span>/<span class="number">3</span>/<span class="number">4</span>/<span class="number">7</span></span><br><span class="line"><span class="number">307</span> Internal Redirect（内部重定向）</span><br><span class="line"><span class="symbol">Location:</span> https:<span class="comment">//www.baidu.com</span></span><br><span class="line"><span class="number">4</span>xx 客户端错误 <span class="number">404</span> Not Found（客户端发送的页面没找打）</span><br><span class="line"><span class="symbol">http:</span><span class="comment">//help.xunlei.com/online/stat_inst.php?pid=0000&amp;thunderver=5.8.14.706&amp;thundertype=4&amp;peerid=000C294E4AE1J3J4</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//video.baomihua.com/play_error/-30001</span></span><br><span class="line"><span class="number">5</span>xx 服务器错误 <span class="number">503</span> Service Unavailable（服务器不能使用）</span><br></pre></td></tr></table></figure><h3 id="六、长连接和短连接"><a href="#六、长连接和短连接" class="headerlink" title="六、长连接和短连接"></a>六、长连接和短连接</h3><p><br></p><p><strong>TCP长/短连接 好比 地铁卡/单程票</strong></p><p><br></p><p>在HTTP/1.0中, 默认使用的是短连接.也就是说, 浏览器和服务器每进行一次HTTP操作, 就建立一次连接, 但任务结束就中断连接.如果客户端浏览器访问的某个HTML或其他类型的 Web 页中包含有其他的Web资源，如js文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p><p>但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码:</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Connection</span>:<span class="meta">keep</span>-alive</span><br></pre></td></tr></table></figure><p>在真正的读写操作之前，server与client之间必须建立一个连接，</p><p>当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，</p><p>连接的建立通过三次握手，释放则需要四次握手，</p><p>所以说每个连接的建立都是需要资源消耗和时间消耗的。</p><h4 id="TCP-短连接"><a href="#TCP-短连接" class="headerlink" title="TCP 短连接"></a>TCP 短连接</h4><p><strong>短连接一般只会在 client/server 间传递一次读写操作！</strong></p><ol><li>client 向 server 发起连接请求</li><li>server 接到请求，双方建立连接</li><li>client 向 server 发送消息</li><li>server 回应 client</li><li>一次读写完成，此时双方任何一个都可以发起 close 操作 (一般都是 client 先发起 close 操作。当然也不排除有特殊的情况。)</li></ol><h4 id="TCP-长连接"><a href="#TCP-长连接" class="headerlink" title="TCP 长连接"></a>TCP 长连接</h4><ol><li>client 向 server 发起连接</li><li>server 接到请求，双方建立连接</li><li>client 向 server 发送消息</li><li>server 回应 client</li><li>一次读写完成，连接不关闭</li><li>后续读写操作…</li><li>长时间操作之后 client 发起关闭请求</li></ol><h4 id="TCP长-短连接的优点和缺点"><a href="#TCP长-短连接的优点和缺点" class="headerlink" title="TCP长/短连接的优点和缺点"></a>TCP长/短连接的优点和缺点</h4><p>长连接可以省去较多的TCP建立和关闭的操作，节约时间。但是如果用户量太大容易造成服务器负载过高最终导致服务不可用。</p><p>短连接对于服务器来说实现起来较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但是如果用户访问量很大, 往往可能在很短时间内需要创建大量的连接，造成服务器响应速度过慢。</p><p><strong>总之：</strong></p><p>小的WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源来让套接字 保持存活-keep alive，</p><p>对于中大型WEB网站一般都采用长连接，好处是响应用户请求的时间更短，用户体验更好，虽然更耗硬件资源一些，但这都不是事儿。另外，数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误。</p><h3 id="七、案例"><a href="#七、案例" class="headerlink" title="七、案例"></a>七、案例</h3><p>1.模拟服务器(服务端)</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 需求: 获取请求报文的格式;</span></span><br><span class="line"></span><br><span class="line">import <span class="built_in">socket</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tcp_socket = <span class="built_in">socket</span>.<span class="built_in">socket</span>(<span class="built_in">socket</span>.AF_INET, <span class="built_in">socket</span>.SOCK_STREAM)</span><br><span class="line">    tcp_socket.setsockopt(<span class="built_in">socket</span>.SOL_SOCKET, <span class="built_in">socket</span>.SO_REUSEADDR, True)</span><br><span class="line">    tcp_socket.bind((<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>))</span><br><span class="line">    tcp_socket.listen(<span class="number">128</span>)</span><br><span class="line">    print(<span class="string">"服务已开启..."</span>)</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        service_client_socket, ip_port = tcp_socket.accept()</span><br><span class="line">        print(ip_port, <span class="string">"已连接..."</span>)</span><br><span class="line">        data_bin = service_client_socket.recv(<span class="number">5000</span>)</span><br><span class="line">        print(<span class="string">"二进制数据："</span>, data_bin)</span><br><span class="line">        print(<span class="string">"解析后数据："</span>, data_bin.decode())</span><br><span class="line">        service_client_socket.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><p>2.模拟浏览器(客户端)</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 需求: 获取响应报文的格式内容并保存;</span></span><br><span class="line"></span><br><span class="line">import <span class="built_in">socket</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建TCP连接</span></span><br><span class="line">    tcp_socket = <span class="built_in">socket</span>.<span class="built_in">socket</span>(<span class="built_in">socket</span>.AF_INET, <span class="built_in">socket</span>.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># DNS解析 和 连接HTTP服务器</span></span><br><span class="line">    tcp_socket.connect((<span class="string">"www.baidu.com"</span>, <span class="number">80</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 组包 发送HTTP请求报文</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求行</span></span><br><span class="line">    request_line = <span class="string">"GET / HTTP/1.1\r\n"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求头</span></span><br><span class="line">    request_header = <span class="string">"Host: www.baidu.com\r\n"</span></span><br><span class="line">    request_data = request_line + request_header + <span class="string">"\r\n"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送请求</span></span><br><span class="line">    tcp_socket.<span class="built_in">send</span>(request_data.encode())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收响应报文</span></span><br><span class="line">    response_data = tcp_socket.recv(<span class="number">4096</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对响应报文进行解析 -- 切割</span></span><br><span class="line">    response_str_data = response_data.decode()</span><br><span class="line">    <span class="comment"># print(response_data)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># '\r\n\r\n'之后的数据就是响应体数据</span></span><br><span class="line">    index = response_str_data.find(<span class="string">"\r\n\r\n"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 切割出的数据就是文件数据</span></span><br><span class="line">    html_data = response_str_data[index + <span class="number">4</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># data_file = open("index.html", "wb")</span></span><br><span class="line">    <span class="comment"># data_file.write(html_data.encode())</span></span><br><span class="line">    <span class="comment"># data_file.close()</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"index.html"</span>, <span class="string">"wb"</span>) <span class="keyword">as</span> <span class="built_in">file</span>:</span><br><span class="line">        <span class="built_in">file</span>.<span class="built_in">write</span>(html_data.encode())</span><br><span class="line">        <span class="comment"># 如果是长连接,还有很多内容没有收到,需要死循环接收</span></span><br><span class="line">        <span class="keyword">while</span> True:</span><br><span class="line">            <span class="comment"># 后面在获取到的响应内容,就不包含响应行和响应头了</span></span><br><span class="line">            data_bin = tcp_socket.recv(<span class="number">4096</span>)</span><br><span class="line">            <span class="keyword">if</span> data_bin:</span><br><span class="line">                <span class="built_in">file</span>.<span class="built_in">write</span>(data_bin)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭套接字</span></span><br><span class="line">    tcp_socket.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><ol start="3"><li>web 静态服务器</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebServer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Web 服务器类"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ip, port)</span>:</span></span><br><span class="line">        <span class="comment"># 创建套接字</span></span><br><span class="line">        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        <span class="comment"># 设置套接字复用地址</span></span><br><span class="line">        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 绑定IP地址和端口</span></span><br><span class="line">        self.socket.bind((ip, port))</span><br><span class="line">        <span class="comment"># 设置被动套接字</span></span><br><span class="line">        self.socket.listen(<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startup</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""等待客户端连接"""</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="comment"># 等待被连接</span></span><br><span class="line">            service_client_socket, ip_port = self.socket.accept()</span><br><span class="line">            print(ip_port, <span class="string">"连接成功."</span>, end=<span class="string">"\n\n"</span>)</span><br><span class="line">            <span class="comment"># 处理请求</span></span><br><span class="line">            gevent.spawn(self.client_handler, service_client_socket)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">client_handler</span><span class="params">(self, service_client_socket)</span>:</span></span><br><span class="line">        <span class="string">"""处理客户端请求"""</span></span><br><span class="line">        request_data_bin = service_client_socket.recv(<span class="number">4096</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> request_data_bin:</span><br><span class="line">            print(<span class="string">'客户端已经断开连接.'</span>, end=<span class="string">"\n\n"</span>)</span><br><span class="line">            service_client_socket.close()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"客户端请求报文："</span>, request_data_bin, end=<span class="string">"\n\n"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 解析 HTTP 文本</span></span><br><span class="line">        my_http = self.parse_http(request_data_bin.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取固定页面数据</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response_line = <span class="string">'HTTP/1.1 200 OK\r\n'</span></span><br><span class="line">            response_header = <span class="string">'Server: PythonWebServer1.0\r\n'</span></span><br><span class="line">            file = open(<span class="string">'./static'</span> + my_http[<span class="string">'url'</span>], <span class="string">'rb'</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            response_line = <span class="string">'HTTP/1.1 404 NOT FOUND\r\n'</span></span><br><span class="line">            response_header = <span class="string">'Server: PythonWebServer1.0\r\n'</span></span><br><span class="line">            file = open(<span class="string">'./static/404.html'</span>, <span class="string">'rb'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取文件内容</span></span><br><span class="line">        response_content = file.read()</span><br><span class="line">        file.close()</span><br><span class="line">        <span class="comment"># 拼接响应报文</span></span><br><span class="line">        response_data = (response_line + response_header + <span class="string">'\r\n'</span>).encode(<span class="string">'utf-8'</span>) + response_content</span><br><span class="line">        <span class="comment"># 发送响应报文</span></span><br><span class="line">        service_client_socket.send(response_data)</span><br><span class="line">        <span class="comment"># 关闭套接字</span></span><br><span class="line">        service_client_socket.close()</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"\n"</span>, <span class="string">"-"</span> * <span class="number">100</span>, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_http</span><span class="params">(request_data)</span>:</span></span><br><span class="line">        <span class="string">"""解析 HTTP 文本"""</span></span><br><span class="line"></span><br><span class="line">        my_http = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 分成多行</span></span><br><span class="line">        request_headers = request_data.split(<span class="string">'\r\n'</span>)</span><br><span class="line">        request_lines = request_headers[<span class="number">0</span>].split(<span class="string">' '</span>)</span><br><span class="line">        print(<span class="string">"request_lines: "</span>, request_lines, end=<span class="string">"\n\n"</span>)</span><br><span class="line"></span><br><span class="line">        my_http[<span class="string">'method'</span>] = request_lines[<span class="number">0</span>]</span><br><span class="line">        my_http[<span class="string">'url'</span>] = request_lines[<span class="number">1</span>]</span><br><span class="line">        my_http[<span class="string">'version'</span>] = request_lines[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 未指定页面时 默认访问 index.html</span></span><br><span class="line">        <span class="keyword">if</span> my_http[<span class="string">'url'</span>] == <span class="string">"/"</span>:</span><br><span class="line">            my_http[<span class="string">'url'</span>] = <span class="string">"/index.html"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> header <span class="keyword">in</span> request_headers[<span class="number">1</span>:]:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> header:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Host: www.baidu.com</span></span><br><span class="line">            lines = header.split(<span class="string">':'</span>)</span><br><span class="line">            my_http[lines[<span class="number">0</span>]] = lines[<span class="number">1</span>][<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"my_http: "</span>, my_http, end=<span class="string">"\n\n"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> my_http</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">port_handler</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""指定端口"""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 默认设置端口为 8888</span></span><br><span class="line">    port = <span class="number">8888</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 获取外部传递过来的参数;</span></span><br><span class="line">    <span class="comment"># # 1.尽量值传递一个参数过来</span></span><br><span class="line">    <span class="comment"># #   ctrl+z: 退出页面,但是程序没有退出;(该端口还可以使用)</span></span><br><span class="line">    <span class="comment"># #   ctrl+c: 退出页面,也退出程序;</span></span><br><span class="line">    <span class="comment"># # print(sys.argv[1])</span></span><br><span class="line">    <span class="comment"># if not len(sys.argv) == 2:</span></span><br><span class="line">    <span class="comment">#     print('输入的格式错误,正确的格式应该是: python3 文件名.py 端口号')</span></span><br><span class="line">    <span class="comment">#     return</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># # 2.如果传递过来端口号,里面有非数字;(也不行)</span></span><br><span class="line">    <span class="comment"># if not sys.argv[1].isdigit():</span></span><br><span class="line">    <span class="comment">#     print('端口号, 必须是整数!!!')</span></span><br><span class="line">    <span class="comment">#     return</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># # 3.取值范围: [0-65535]</span></span><br><span class="line">    <span class="comment"># if not 0 &lt;= int(sys.argv[1]) &lt;= 65535:</span></span><br><span class="line">    <span class="comment">#     print('端口号必须在: [0-65535]之间!!!')</span></span><br><span class="line">    <span class="comment">#     return</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># # 4.如果全部通过,那么要把端口号,传递到程序中</span></span><br><span class="line">    <span class="comment"># # 获取用户指定的绑定端口</span></span><br><span class="line">    <span class="comment"># port = int(sys.argv[1])</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> port</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 服务器 IP，默认为本机 IP</span></span><br><span class="line">    server_ip = <span class="string">""</span></span><br><span class="line">    <span class="comment"># 服务器 端口</span></span><br><span class="line">    server_port = port_handler()</span><br><span class="line">    web_server = WebServer(server_ip, server_port)</span><br><span class="line">    web_server.startup()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;浏览器请求的基本流程；&lt;/li&gt;
&lt;li&gt;浏览器请求的 URL；&lt;/li&gt;
&lt;li&gt;请求报文格式；&lt;/li&gt;
&lt;li&gt;响应报文格式；&lt;/li&gt;
&lt;li&gt;网络响应状态码；&lt;/li&gt;
&lt;li&gt;长连接和短连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="HTTP" scheme="http://jovelin.cn/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Python 中 exit() 的用法</title>
    <link href="http://jovelin.cn/2018/07/15/Python%20%E4%B8%AD%20exit()%20%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://jovelin.cn/2018/07/15/Python 中 exit() 的用法/</id>
    <published>2018-07-14T16:22:31.000Z</published>
    <updated>2018-07-28T02:03:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Python 中 exit() 的用法总结</strong>：</p><ol><li><p><strong>sys.exit(n)  退出程序引发 SystemExit 异常，可以捕获异常执行些清理工作</strong>。</p><p> n 默认值为 0，表示正常退出，其他都是非正常退出。还可以 sys.exit(“sorry, goodbye!”);</p><p> 一般 <strong>主程序中</strong> 使用此退出。</p></li></ol><a id="more"></a><ol><li><p><strong>os._exit(n)，直接退出，不抛异常， 不执行相关清理工作</strong>。</p><p> 常用在 <strong>子进程</strong> 的退出。</p></li><li><p><strong>exit()/quit()，跑出 SystemExit 异常</strong>。</p><p> 一般在 <strong>交互式 shell 中</strong> 退出时使用。</p></li><li><p><strong>exit(0) 有什么功能</strong>？</p><p> 在很多类型的操作系统里，exit(0) 可以中断某个程序，而其中的数字参数则用来表示程序是否是碰到错误而中断。</p><p> exit(1) 表示发生了错误，而 exit(0) 则表示程序是正常退出的。</p><p> 这和我们学的布尔逻辑  0==False 正好相反，不过你可以用不一样的数字表示不同的错误结果。</p><p> 比如你可以用 exit(100) 来表示另一种和 exit(2) 或 exit(1) 不同的错误。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Python 中 exit() 的用法总结&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;sys.exit(n)  退出程序引发 SystemExit 异常，可以捕获异常执行些清理工作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; n 默认值为 0，表示正常退出，其他都是非正常退出。还可以 sys.exit(“sorry, goodbye!”);&lt;/p&gt;
&lt;p&gt; 一般 &lt;strong&gt;主程序中&lt;/strong&gt; 使用此退出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="exit 方法" scheme="http://jovelin.cn/tags/exit-%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python 正则表达式</title>
    <link href="http://jovelin.cn/2018/07/12/Python%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://jovelin.cn/2018/07/12/Python 正则表达式/</id>
    <published>2018-07-12T07:21:00.000Z</published>
    <updated>2018-07-28T02:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>定义；</li><li>常用的元字符；</li><li>常用的限定符（量词）；</li><li>分组；</li><li>正则高级 API（4个）；</li><li>r 的作用；</li><li>贪婪/非贪婪。</li></ol></blockquote><a id="more"></a><h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。</p><p><strong>简而言之：正则表达式就是记录文本规则的代码。</strong></p><!-- more --><p>特点: </p><p>操作字符串</p><p>1.更快的方式操作字符串；(表单校验，数据匹配…)</p><p>2.普通字符串操作无法做到的，或者很难做的正则很容易搞定！！！</p><p>使用场景：</p><p>1.表单校验</p><p>2.api 里面也需要正则</p><p><strong>正则表达式代码体验</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python 解释器为我们提供了一个使用正则的模块，这个模块叫做re(regex)</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 1.match()：匹配 -&gt; object</span></span><br><span class="line">    <span class="comment"># group()：通过匹配后，可以使用group()获取内容</span></span><br><span class="line">    obj = re.match(<span class="string">r"jovelin"</span>, <span class="string">"jovelin"</span>)</span><br><span class="line">    print(obj.group())  <span class="comment"># -&gt; jovelin</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.如果被匹配的内容多余正则；(只返回开头匹配的部分)</span></span><br><span class="line">    obj = re.match(<span class="string">r"jovelin"</span>, <span class="string">"jovelin.cn"</span>)</span><br><span class="line">    print(obj.group())  <span class="comment"># -&gt; jovelin</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.如果开头部分，没有匹配的内容； 那么返回None</span></span><br><span class="line">    obj = re.match(<span class="string">r"jovelin"</span>, <span class="string">"www.jovelin.cn"</span>)</span><br><span class="line">    print(obj)  <span class="comment"># -&gt; None</span></span><br><span class="line"></span><br><span class="line">    print(<span class="keyword">None</span>, type(<span class="keyword">None</span>))  <span class="comment"># -&gt; None &lt;class 'NoneType'&gt;</span></span><br></pre></td></tr></table></figure><h3 id="二、常用的元字符"><a href="#二、常用的元字符" class="headerlink" title="二、常用的元字符"></a>二、常用的元字符</h3><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:left">匹配除换行符(\n)以外的任意字符</td></tr><tr><td style="text-align:center">[]</td><td style="text-align:left">匹配 [ ] 中列举的字符</td></tr><tr><td style="text-align:center">\w 与 \W</td><td style="text-align:left">匹配字母或数字或下划线或汉字(单词) / 反义(非单词)</td></tr><tr><td style="text-align:center">\s 与 \S</td><td style="text-align:left">匹配任意的空白符 / 反义(非空白)</td></tr><tr><td style="text-align:center">\d 与 \D</td><td style="text-align:left">匹配数字 [0-9] / 反义(非数字)</td></tr><tr><td style="text-align:center">\b 与 \B</td><td style="text-align:left">匹配单词的开始或结束 / 反义</td></tr><tr><td style="text-align:center">^</td><td style="text-align:left">匹配字符串的开始</td></tr><tr><td style="text-align:center">$</td><td style="text-align:left">匹配字符串的结束</td></tr></tbody></table><p><strong>代码演示：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># . 匹配任意1个字符（除了 \n）</span></span><br><span class="line">print(re.match(<span class="string">r'a.b'</span>, <span class="string">'a\nb'</span>))  <span class="comment"># -&gt; None</span></span><br><span class="line"><span class="comment">#  - 在 [] 里代表范围</span></span><br><span class="line">print(re.match(<span class="string">r'a[a-c]c'</span>, <span class="string">'abc'</span>).group())  <span class="comment"># -&gt; abc</span></span><br><span class="line"><span class="comment"># 在 [] 里面也想使用 - 那么需要 \ 转义</span></span><br><span class="line">print(re.match(<span class="string">r'a[a\-c]c'</span>, <span class="string">'a-c'</span>).group())  <span class="comment"># -&gt; a-c</span></span><br><span class="line"><span class="comment"># \b用法 与 ^ $ 相似，不过 \b 只匹配单词，\B 只匹配非单词</span></span><br><span class="line">print(re.match(<span class="string">r"\b\w+\b"</span>, <span class="string">"0_9_a_z_A_Z汉字"</span>).group())  <span class="comment"># -&gt; 0_9_a_z_A_Z</span></span><br><span class="line">print(re.match(<span class="string">r"\B\W+\B"</span>, <span class="string">"!@#$%^&amp;*"</span>).group())  <span class="comment"># -&gt; !@#$%^&amp;*</span></span><br><span class="line"><span class="comment"># ^匹配字符串开头</span></span><br><span class="line"><span class="comment"># $匹配字符串结尾</span></span><br><span class="line">print(re.match(<span class="string">r'[\w\W]*$'</span>, <span class="string">'0_9_a_z_A_Z汉字!@#$%^&amp;* \n\t'</span>).group())  <span class="comment"># -&gt; 0_9_a_z_A_Z汉字!@#$%^&amp;* </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意: ^ 如果出现在 [] 中，代表的是取反!   (想要使用 ^,可以转义 \)</span></span><br><span class="line">print(re.match(<span class="string">r'^[\^]$'</span>, <span class="string">'^'</span>).group())  <span class="comment"># -&gt; ^</span></span><br><span class="line">print(re.match(<span class="string">r'^[^^]$'</span>, <span class="string">'^'</span>))  <span class="comment"># -&gt; None</span></span><br><span class="line">print(re.match(<span class="string">r'^[^47]$'</span>, <span class="string">'47'</span>))  <span class="comment"># -&gt; 47</span></span><br></pre></td></tr></table></figure><h3 id="三、常用的限定符（量词）"><a href="#三、常用的限定符（量词）" class="headerlink" title="三、常用的限定符（量词）"></a>三、常用的限定符（量词）</h3><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:left">说明</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:left">重复零次或更多次</td><td style="text-align:left">&gt;=0</td></tr><tr><td style="text-align:center">+</td><td style="text-align:left">重复一次或更多次</td><td style="text-align:left">&gt;=1</td></tr><tr><td style="text-align:center">?</td><td style="text-align:left">重复零次或一次</td><td style="text-align:left">0 or 1</td></tr><tr><td style="text-align:center">{n}</td><td style="text-align:left">重复n次</td><td style="text-align:left">==n</td></tr><tr><td style="text-align:center">{n,}</td><td style="text-align:left">重复n次或更多次</td><td style="text-align:left">&gt;=n</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:left">重复n到m次</td><td style="text-align:left">n&lt;=X&lt;=m</td></tr></tbody></table><p><strong>代码演示：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># * 匹配前一个字符出现0次或者无限次，即可有可无 (&gt;=0)</span></span><br><span class="line">print(re.match(<span class="string">r'a*b'</span>, <span class="string">'b'</span>).group())  <span class="comment"># -&gt; b</span></span><br><span class="line"><span class="comment"># + 匹配前一个字符出现1次或者无限次，即至少有1次 (&gt;=1)</span></span><br><span class="line">print(re.match(<span class="string">r'a+b'</span>, <span class="string">'b'</span>))  <span class="comment"># -&gt; None，必须要 1 个 a</span></span><br><span class="line"><span class="comment"># &#123;n&#125; 匹配前一个字符出现n次 == n                           (== n)</span></span><br><span class="line">print(re.match(<span class="string">r'a&#123;2&#125;b'</span>, <span class="string">'ab'</span>))  <span class="comment"># -&gt; None，必须要 2 个 a</span></span><br><span class="line"><span class="comment"># &#123;n,m&#125; 匹配前一个字符出现: n次&lt;= 前一个字符 &lt;=m次 (n&lt;=X&lt;=m)</span></span><br><span class="line">print(re.match(<span class="string">r'a&#123;2,5&#125;b'</span>, <span class="string">'ab'</span>))  <span class="comment"># -&gt; None，a 的次数必须是 2&lt;=a&lt;=5</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>案例</strong>：</p><p>1.校验手机号</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMobileNumber</span><span class="params">(tel)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    校验手机号是否正确</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> re.match(<span class="string">r"^[1-][34578-]\d&#123;9&#125;$"</span>, tel) <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(isMobileNumber(<span class="string">"18819950820"</span>))</span><br></pre></td></tr></table></figure><p>2.校验邮箱</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">邮箱名称部分为： [a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)&#123;0,4&#125;</span></span><br><span class="line"><span class="string">域名部分： [a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+</span></span><br><span class="line"><span class="string">连起来 ^[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)&#123;0,4&#125;@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)&#123;1,2&#125;$</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isEmail</span><span class="params">(email)</span>:</span></span><br><span class="line">    <span class="string">"""校验邮箱是否正确"""</span></span><br><span class="line">    <span class="keyword">if</span> re.match(<span class="string">r"^[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)&#123;0,4&#125;@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)&#123;1,2&#125;$"</span>, email) <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(isEmail(<span class="string">"jovelin@163.com"</span>))</span><br><span class="line">print(isEmail(<span class="string">"jovelin.dev@gmail.com"</span>))</span><br><span class="line">print(isEmail(<span class="string">"jovelin@163.com.cn"</span>))</span><br><span class="line">print(isEmail(<span class="string">"jovelin.dev@gmail.com.cn"</span>))</span><br></pre></td></tr></table></figure><h3 id="四、分组"><a href="#四、分组" class="headerlink" title="四、分组"></a>四、分组</h3><p>用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作。</p><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">(abc)</td><td style="text-align:left">将括号中字符作为一个分组</td></tr><tr><td style="text-align:center">竖线</td><td style="text-align:left">匹配左右任意一个表达式</td></tr><tr><td style="text-align:center">\num</td><td style="text-align:left">引用分组num匹配到的字符串</td></tr><tr><td style="text-align:center">(?P<name>)</name></td><td style="text-align:left">分组起别名</td></tr><tr><td style="text-align:center">(?P=name)</td><td style="text-align:left">引用别名为name分组匹配到的字符串</td></tr></tbody></table><p>代码演示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># (abc) 将括号中字符作为一个分组</span></span><br><span class="line">print(re.match(<span class="string">r'(aaa)bbb(ccc)'</span>, <span class="string">'aaabbbccc'</span>).group())</span><br><span class="line"><span class="comment"># 一个括号就是一个分组； group()：参数代表分组的编号；写 0 或者不写时，获取全部；</span></span><br><span class="line">print(re.match(<span class="string">r'(aaa)bbb(ccc)'</span>, <span class="string">'aaabbbccc'</span>).group())</span><br><span class="line">print(re.match(<span class="string">r'(aaa)bbb(ccc)'</span>, <span class="string">'aaabbbccc'</span>).group(<span class="number">0</span>))</span><br><span class="line">print(re.match(<span class="string">r'(aaa)bbb(ccc)'</span>, <span class="string">'aaabbbccc'</span>).group(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 竖线 | 匹配左右任意一个表达式（和 [] 相似）</span></span><br><span class="line">print(re.match(<span class="string">r'aaa(xxx|yyy|zzz)bbb'</span>, <span class="string">'aaaxxxbbb'</span>).group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># \num 引用分组 num 匹配到的字符串</span></span><br><span class="line"><span class="comment">#       前后保证一致，要使用到分组！</span></span><br><span class="line">print(re.match(<span class="string">r'^&lt;(\w+)&gt;\w+&lt;/\1&gt;$'</span>, <span class="string">'&lt;html&gt;nihao&lt;/html&gt;'</span>).group())</span><br><span class="line">print(re.match(<span class="string">r'^&lt;(\w+)&gt;&lt;(\w+)&gt;\w+&lt;/\2&gt;&lt;/\1&gt;$'</span>, <span class="string">'&lt;html&gt;&lt;div&gt;nihao&lt;/div&gt;&lt;/html&gt;'</span>).group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># (?P&lt;name&gt;正则)  分组起别名</span></span><br><span class="line"><span class="comment"># (?P=name)      引用别名为name分组匹配到的字符串</span></span><br><span class="line">print(re.match(<span class="string">r'^&lt;(?P&lt;re1&gt;\w+)&gt;&lt;(?P&lt;re2&gt;\w+)&gt;\w+&lt;/(?P=re2)&gt;&lt;/(?P=re1)&gt;$'</span>, <span class="string">'&lt;html&gt;&lt;div&gt;jovelin&lt;/div&gt;&lt;/html&gt;'</span>).group())</span><br></pre></td></tr></table></figure><h3 id="五、正则高级-API（4个）"><a href="#五、正则高级-API（4个）" class="headerlink" title="五、正则高级 API（4个）"></a>五、正则高级 API（4个）</h3><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">search()</td><td style="text-align:left">搜索字符串中符合正则表达式的内容 -&gt; 只返回第一个</td></tr><tr><td style="text-align:center">findall()</td><td style="text-align:left">搜索字符串中符合正则表达式的内容 -&gt; 返回一个列表</td></tr><tr><td style="text-align:center">sub()</td><td style="text-align:left">替换字符串中符合正则的内容 -&gt; 替换后的字符串</td></tr><tr><td style="text-align:center">split()</td><td style="text-align:left">按照指定正则切割字符串 -&gt; 返回列表</td></tr></tbody></table><p>代码演示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.search()</span></span><br><span class="line">print(re.search(<span class="string">r"\d+"</span>, <span class="string">"aaa111bbb222ccc333ddd"</span>).group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.findall()</span></span><br><span class="line">print(re.findall(<span class="string">r"\d+"</span>, <span class="string">"aaa111bbb222ccc333ddd"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.sub()</span></span><br><span class="line">print(re.sub(<span class="string">r"\d+"</span>, <span class="string">"***"</span>, <span class="string">"aaa111bbb222ccc333ddd"</span>))</span><br><span class="line"><span class="comment"># sub(正则, 替换成***, 被操作的字符串, 替换次数)</span></span><br><span class="line">print(re.sub(<span class="string">r"\d+"</span>, <span class="string">"***"</span>, <span class="string">"aaa111bbb222ccc333ddd"</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.split()</span></span><br><span class="line">print(re.split(<span class="string">r"\d+"</span>, <span class="string">"aaa111bbb222ccc333ddd eee"</span>))</span><br><span class="line">print(re.split(<span class="string">r"\d+|\s"</span>, <span class="string">"aaa111bbb222ccc333ddd eee"</span>))</span><br></pre></td></tr></table></figure><h3 id="六、r-的作用"><a href="#六、r-的作用" class="headerlink" title="六、r 的作用"></a>六、r 的作用</h3><p>让程序把正则直接当做正则看；(不是从字符串开始解释)</p><figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line"># c:<span class="symbol">\a</span>aa<span class="symbol">\b</span>bb<span class="symbol">\c</span>cc</span><br><span class="line">print('c:<span class="symbol">\a</span>aa<span class="symbol">\b</span>bb<span class="symbol">\c</span>cc')</span><br><span class="line">print('c:<span class="symbol">\\</span>aaa<span class="symbol">\\</span>bbb<span class="symbol">\\</span>ccc')</span><br><span class="line"></span><br><span class="line"># 问题：在字符串中写 <span class="symbol">\ </span>时会转义，需要写成 <span class="symbol">\\</span></span><br><span class="line"># 不写 r 时 <span class="symbol">\\</span><span class="symbol">\\</span> -&gt; <span class="symbol">\\</span></span><br><span class="line">print(re.match('c:<span class="symbol">\\</span><span class="symbol">\\</span>aaa<span class="symbol">\\</span><span class="symbol">\\</span>bbb<span class="symbol">\\</span><span class="symbol">\\</span>ccc', 'c:<span class="symbol">\\</span>aaa<span class="symbol">\\</span>bbb<span class="symbol">\\</span>ccc').group())</span><br><span class="line"># 写 r 时 <span class="symbol">\\</span> -&gt; <span class="symbol">\\</span></span><br><span class="line">print(re.match(r'c:<span class="symbol">\\</span>aaa<span class="symbol">\\</span>bbb<span class="symbol">\\</span>ccc', 'c:<span class="symbol">\\</span>aaa<span class="symbol">\\</span>bbb<span class="symbol">\\</span>ccc').group())</span><br></pre></td></tr></table></figure><h3 id="七、贪婪-非贪婪"><a href="#七、贪婪-非贪婪" class="headerlink" title="七、贪婪/非贪婪"></a>七、贪婪/非贪婪</h3><p>贪婪：(量词在自己的范围内，取最多…)</p><p>非贪婪：(量词在自己的范围内，取最少… ) </p><p>非贪婪用法：量词后面加?</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'贪婪'</span>, re.match(<span class="string">r'a+'</span>, <span class="string">'aaa'</span>).group())  <span class="comment"># -&gt; aaa</span></span><br><span class="line"><span class="comment"># 量词后面加?</span></span><br><span class="line">print(<span class="string">'非贪婪'</span>, re.match(<span class="string">r'a+?'</span>, <span class="string">'aaa'</span>).group())  <span class="comment"># -&gt; a</span></span><br><span class="line">print(<span class="string">'贪婪'</span>, re.match(<span class="string">r'a&#123;1,2&#125;'</span>, <span class="string">'aaa'</span>).group())  <span class="comment"># -&gt; aa</span></span><br><span class="line"><span class="comment"># 量词后面加?</span></span><br><span class="line">print(<span class="string">'非贪婪'</span>, re.match(<span class="string">r'a&#123;1,3&#125;?'</span>, <span class="string">'aaa'</span>).group())  <span class="comment"># -&gt; a</span></span><br></pre></td></tr></table></figure><blockquote><p>更多参考内容： <a href="http://deerchao.net" target="_blank" rel="noopener">http://deerchao.net</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义；&lt;/li&gt;
&lt;li&gt;常用的元字符；&lt;/li&gt;
&lt;li&gt;常用的限定符（量词）；&lt;/li&gt;
&lt;li&gt;分组；&lt;/li&gt;
&lt;li&gt;正则高级 API（4个）；&lt;/li&gt;
&lt;li&gt;r 的作用；&lt;/li&gt;
&lt;li&gt;贪婪/非贪婪。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="正则表达式" scheme="http://jovelin.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 多任务-线程、进程与协程</title>
    <link href="http://jovelin.cn/2018/07/10/Python%20%E5%A4%9A%E4%BB%BB%E5%8A%A1-%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/"/>
    <id>http://jovelin.cn/2018/07/10/Python 多任务-线程、进程与协程/</id>
    <published>2018-07-09T16:20:12.000Z</published>
    <updated>2018-07-28T02:26:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>多线程；</li><li>多进程；</li><li>进程、线程对比；</li><li>多协程；</li><li>进程、线程、协程对比。</li></ol></blockquote><a id="more"></a><h1 id="Python-多任务-线程、进程与协程"><a href="#Python-多任务-线程、进程与协程" class="headerlink" title="Python 多任务-线程、进程与协程"></a>Python 多任务-线程、进程与协程</h1><p>什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。</p><h3 id="一、线程"><a href="#一、线程" class="headerlink" title="一、线程"></a>一、线程</h3><p>线程是进程的一个实体，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-4cf0e2846bad9723.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="进程和线程.png"></p><h4 id="并行-并发"><a href="#并行-并发" class="headerlink" title="并行/并发"></a>并行/并发</h4><p><img src="https://upload-images.jianshu.io/upload_images/3365001-9365b83598e8f764.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02-CPU及线程介绍.png"></p><p><strong>并发</strong></p><p>指的是任务数多余cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）</p><p><strong>并行</strong></p><p>指的是任务数小于等于cpu核数，即任务真的是一起执行的</p><h4 id="多线程图解"><a href="#多线程图解" class="headerlink" title="多线程图解"></a>多线程图解</h4><p><img src="https://upload-images.jianshu.io/upload_images/3365001-81ffaa2cf10ae661.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03-线程.png"></p><h4 id="共享全局变量与问题"><a href="#共享全局变量与问题" class="headerlink" title="共享全局变量与问题"></a>共享全局变量与问题</h4><p>在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据。</p><p><strong>问题</strong>：</p><p>如果多个线程同时对同一个全局变量操作，会出现资源竞争问题，从而数据结果会不正确。（即线程非安全）</p><h4 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h4><p>同步：单线程（从上到下依次执行顺序）</p><p>异步：多线程（开启多个任务一同执行，互不影响）</p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p><strong>当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制</strong>。</p><p><strong>锁的好处</strong>：</p><ul><li>确保了某段关键代码只能由一个线程从头到尾完整地执行</li></ul><p><strong>锁的坏处</strong>：</p><ul><li>阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了<br>由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁</li></ul><h4 id="死锁（一种-bug）"><a href="#死锁（一种-bug）" class="headerlink" title="死锁（一种 bug）"></a>死锁（一种 bug）</h4><p>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。</p><p><strong>避免死锁</strong></p><ul><li>程序设计时要尽量避免（银行家算法）</li><li>添加超时时间等</li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>1.多线程体验</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python 解释器中有一个模块专门控制线程，实现多任务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        print(<span class="string">"send msg"</span>, i + <span class="number">1</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive_msg</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        print(<span class="string">"receive msg"</span>, i + <span class="number">1</span>)</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建线程对象（target=函数名, name=线程别名, args=参数, kwargs=字典参数）</span></span><br><span class="line">    t1 = threading.Thread(target=send_msg, name=<span class="string">"send"</span>, args=(<span class="number">3</span>,))</span><br><span class="line">    t2 = threading.Thread(target=receive_msg, name=<span class="string">"receive"</span>, kwargs=&#123;<span class="string">"num"</span>: <span class="number">3</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 三个 API</span></span><br><span class="line">    print(threading.enumerate())</span><br><span class="line">    print(threading.current_thread())</span><br><span class="line">    print(threading.active_count())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 守护线程</span></span><br><span class="line">    t1.setDaemon(<span class="keyword">True</span>)</span><br><span class="line">    t2.setDaemon(<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开启线程</span></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 线程等待</span></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"*** main thread ***"</span>)</span><br></pre></td></tr></table></figure><p>2.自定义线程类</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendThread</span>(<span class="title">threading</span>.<span class="title">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, num)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="comment"># threading.Thread.__init__(self)</span></span><br><span class="line">        <span class="keyword">super</span>(SendThread, <span class="keyword">self</span>).__init_<span class="number">_</span>()</span><br><span class="line">        <span class="comment"># super().__init__()</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.num = num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)<span class="symbol">:</span></span><br><span class="line">            print(<span class="string">"send msg"</span>, i + <span class="number">1</span>)</span><br><span class="line">            time.sleep(<span class="number">0</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.send_msg()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiveThread</span>(<span class="title">threading</span>.<span class="title">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive_msg</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)<span class="symbol">:</span></span><br><span class="line">            print(<span class="string">"receive msg"</span>, i + <span class="number">1</span>)</span><br><span class="line">            time.sleep(<span class="number">0</span>.<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.receive_msg()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    t1 = SendThread(<span class="number">3</span>)</span><br><span class="line">    t2 = ReceiveThread()</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"*** main thread ***"</span>)</span><br></pre></td></tr></table></figure><h3 id="二、进程"><a href="#二、进程" class="headerlink" title="二、进程"></a>二、进程</h3><p>运行的程序以及运行时用到的资源这个整体称之为进程，是系统进行资源分配和调度的一个独立单位。</p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-4e2b4618127c7d94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01-进程.png"></p><h4 id="进程间通信-Queue"><a href="#进程间通信-Queue" class="headerlink" title="进程间通信-Queue"></a>进程间通信-Queue</h4><p>进程间通信：运行的程序之间的数据共享。</p><h3 id="三、进程、线程对比"><a href="#三、进程、线程对比" class="headerlink" title="三、进程、线程对比"></a>三、进程、线程对比</h3><p>功能</p><ul><li>进程，能够完成多任务，比如 在一台电脑上能够同时运行多个 QQ。</li><li>线程，能够完成多任务，比如 一个 QQ 中的多个聊天窗口。</li></ul><p>定义的不同</p><ul><li>进程是系统进行资源分配和调度的一个独立单位。</li><li>线程是进程的一个实体，是 CPU  调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</li><li>线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</li></ul><p>区别</p><ul><li>一个程序至少有一个进程，一个进程至少有一个线程。</li><li>线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高。</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率，</li><li>线线程不能够独立执行，必须依存在进程中。</li><li>可以将进程理解为工厂中的一条流水线，而其中的线程就是这个流水线上的工人。</li></ul><p>优缺点</p><ul><li>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。</li></ul><h3 id="四、协程"><a href="#四、协程" class="headerlink" title="四、协程"></a>四、协程</h3><p>协程，又称微线程，纤程。英文名Coroutine。</p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-d37fbaaca0679c6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02-协程.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-8f26f1b69124ba7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03-迭代器和生成器.png"></p><h4 id="greenlet"><a href="#greenlet" class="headerlink" title="greenlet"></a>greenlet</h4><p>为了更好使用协程来完成多任务，python中的greenlet模块对其封装，从而使得切换任务变的更加简单</p><p><strong>安装方式</strong></p><p>使用如下命令安装 greenlet 模块:</p><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">pip3 list: 验证已安装的python第三方插件（如果没有pip3会提示安装）</span><br><span class="line"></span><br><span class="line">sudo pip3 install greenlet</span><br></pre></td></tr></table></figure><h4 id="gevent"><a href="#gevent" class="headerlink" title="gevent"></a>gevent</h4><p>greenlet已经实现了协程，但是这个还的人工切换，是不是觉得太麻烦了，不要捉急，python还有一个比greenlet更强大的并且能够自动切换任务的模块gevent</p><p>其原理是当一个greenlet遇到IO(指的是input output 输入输出，比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。</p><p>由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO</p><p><strong>安装方式</strong></p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip3 <span class="keyword">install</span> gevent</span><br></pre></td></tr></table></figure><h4 id="协程和线程差异"><a href="#协程和线程差异" class="headerlink" title="协程和线程差异"></a>协程和线程差异</h4><p>在实现多任务时, 线程切换从系统层面远不止保存和恢复 CPU 上下文这么简单。</p><p>操作系统为了程序运行的高效性每个线程都有自己缓存 Cache 等等数据，操作系统还会帮你做这些数据的恢复操作。所以线程的切换非常耗性能。</p><p>但是协程的切换只是单纯的操作 CPU 的上下文，所以一秒钟切换个上百万次系统都抗的住。</p><h3 id="五、进程、线程、协程对比"><a href="#五、进程、线程、协程对比" class="headerlink" title="五、进程、线程、协程对比"></a>五、进程、线程、协程对比</h3><ol><li>进程是资源分配的单位</li><li>线程是操作系统调度的单位</li><li>进程切换需要的资源很最大，效率很低</li><li>线程切换需要的资源一般，效率一般（当然了在不考虑GIL的情况下）</li><li>协程切换任务资源很小，效率高</li><li>多进程、多线程根据cpu核数不一样可能是并行的，但是协程是在一个线程中 所以是并发</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多线程；&lt;/li&gt;
&lt;li&gt;多进程；&lt;/li&gt;
&lt;li&gt;进程、线程对比；&lt;/li&gt;
&lt;li&gt;多协程；&lt;/li&gt;
&lt;li&gt;进程、线程、协程对比。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="多任务" scheme="http://jovelin.cn/tags/%E5%A4%9A%E4%BB%BB%E5%8A%A1/"/>
    
      <category term="线程" scheme="http://jovelin.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="进程" scheme="http://jovelin.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="协程" scheme="http://jovelin.cn/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python 网络通信-udp、tcp 与 socket</title>
    <link href="http://jovelin.cn/2018/07/08/Python%20%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1-udp%E3%80%81tcp%20%E4%B8%8E%20socket/"/>
    <id>http://jovelin.cn/2018/07/08/Python 网络通信-udp、tcp 与 socket/</id>
    <published>2018-07-07T16:21:11.000Z</published>
    <updated>2018-07-28T02:21:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>UDP 和 TCP 及 socket 介绍；</li><li>网络七层协议(四/五层模型)；</li><li>IP 地址与端口；</li><li>Python3 编码转换；</li><li>Socket 套接字；</li><li>UDP 协议；</li><li>TCP 协议。</li></ol></blockquote><a id="more"></a><h1 id="Python-网络通信"><a href="#Python-网络通信" class="headerlink" title="Python 网络通信"></a>Python 网络通信</h1><h3 id="一、UDP-和-TCP-及-socket-介绍"><a href="#一、UDP-和-TCP-及-socket-介绍" class="headerlink" title="一、UDP 和 TCP 及 socket 介绍"></a>一、UDP 和 TCP 及 socket 介绍</h3><p><strong>注意：udp 和 tcp 都是网络传输的协议，只不过具体传输形式不一样，但功能都是定义网络传输数据规则。</strong></p><p><strong>udp 和 tcp (发短信和打电话)(不同: 是否创建链接)</strong></p><ol><li><p><strong>udp 是用户数据报协议</strong>，UDP(User Datagram Protocol)不能保证数据的准确性和有效性。<br>(数据报:是通过网络传输的数据的基本单元) </p></li><li><p><strong>tcp 是传输控制协议</strong>，TCP(Transmission Control Protocol)能保证数据的准确性和有效性。<br>(和udp差不多依靠socket技术)</p></li><li><p><strong>socket 就是具体实现 tcp 和 udp 的底层技术(也称套接字/流对象)</strong>(不在网络七层协议之列-因为是技术不是协议)</p></li></ol><h3 id="二、网络七层协议-四-五层模型"><a href="#二、网络七层协议-四-五层模型" class="headerlink" title="二、网络七层协议(四/五层模型)"></a>二、网络七层协议(四/五层模型)</h3><p><img src="https://upload-images.jianshu.io/upload_images/3365001-893eb6882ef825ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="七层协议1.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-03725767e52c896a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="七层协议2.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-d812e52bc2dc7743.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络七层协议.png"></p><h3 id="三、IP-地址与端口"><a href="#三、IP-地址与端口" class="headerlink" title="三、IP 地址与端口"></a>三、IP 地址与端口</h3><p>网络通信过程中，之所需要ip、port等，就是为了能够将一个复杂的通信过程进行任务划分，从而保证数据准确无误的传递。</p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-5d9168459fadd31a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ip和端口.png"></p><h4 id="ip-地址"><a href="#ip-地址" class="headerlink" title="ip 地址"></a>ip 地址</h4><p>作用：用来在网络中标记一台电脑，比如 192．168．1．1 在本地局域网上是唯一的。</p><p>注意：IP 地址 127．0．0．1~127．255．255．255 用于回路测试</p><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>端口是通过端口号来标记的，端口号只有整数，范围是从0到65535</p><h5 id="知名端口"><a href="#知名端口" class="headerlink" title="知名端口"></a>知名端口</h5><p>众所周知的端口号，范围从0到1023</p><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">80 </span>端口分配给HTTP服务</span><br><span class="line"><span class="symbol">21 </span>端口分配给FTP服务</span><br></pre></td></tr></table></figure><h5 id="动态端口"><a href="#动态端口" class="headerlink" title="动态端口"></a>动态端口</h5><p>范围是从1024到65535</p><h5 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h5><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">netstat －an 查看端口状态</span><br><span class="line">lsof -<span class="selector-tag">i</span>:port 查看端口占用</span><br></pre></td></tr></table></figure><h3 id="四、Python3-编码转换"><a href="#四、Python3-编码转换" class="headerlink" title="四、Python3 编码转换"></a>四、Python3 编码转换</h3><p>str-&gt;bytes:encode编码</p><p>bytes-&gt;str:decode解码</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding: 在解码编码过程中使用的编码(此处指“编码方案”是名词)</span></span><br><span class="line"><span class="comment"># errors: 错误的处理方案</span></span><br><span class="line">bytes.decode(<span class="attribute">encoding</span>=<span class="string">"utf-8"</span>, <span class="attribute">errors</span>=<span class="string">"strict"</span>)</span><br><span class="line">str.encode(<span class="attribute">encoding</span>=<span class="string">"utf-8"</span>, <span class="attribute">errors</span>=<span class="string">"strict"</span>)</span><br></pre></td></tr></table></figure><p>详细的可以参照官方文档：</p><p><a href="https://docs.python.org/3/library/stdtypes.html?highlight=decode#str.encode" target="_blank" rel="noopener">str.encode()</a></p><p><a href="https://docs.python.org/3/library/stdtypes.html?highlight=decode#bytes.decode" target="_blank" rel="noopener">bytes.decode()</a></p><h3 id="五、Socket-套接字"><a href="#五、Socket-套接字" class="headerlink" title="五、Socket 套接字"></a>五、Socket 套接字</h3><p><strong>socket(简称 套接字也成为插口–流对象)</strong> 是进程间通信的一种方式，它与其他进程间通信的一个主要不同是：</p><p>它能实现不同主机间的进程间通信，我们网络上各种各样的服务大多都是基于 Socket 来完成通信的。</p><p>例如我们每天浏览网页、QQ 聊天、收发 email 等等。</p><h4 id="Socket-反问理解"><a href="#Socket-反问理解" class="headerlink" title="Socket 反问理解"></a>Socket 反问理解</h4><p>———start———</p><p><strong>what 是什么</strong>？（概念、理解）</p><p>socket(简称 套接字 也称为插口–流对象) 是进程间通信的一种方式</p><p><br></p><p><strong>why 为什么用</strong>？（用它的好处，特点/不同点）</p><p>是实现tcp和udp的底层技术，能实现 不同主机间 的进程间通信</p><p><br></p><p><strong>where 在哪使用</strong>？（案例、项目）</p><p>网络程序发送、接收数据（发短信、打电话、广播）</p><p>————end————</p><h3 id="六、UDP-协议"><a href="#六、UDP-协议" class="headerlink" title="六、UDP 协议"></a>六、UDP 协议</h3><p>udp 是用户数据报协议，UDP (User Datagram Protocol) 不能保证数据的准确性和有效性。 (数据报:是通过网络传输的数据的基本单元)</p><p>udp 通信模型中，在通信开始之前，不需要建立相关的链接，只需要发送数据即可，类似于生活中，”写信/发短信”</p><p>python 使用 udp 协议要通过 socket 技术:</p><pre><code>使用步骤：1.引包 2.创建流对象(ipv4, udp) 3.发送(二进制字符串, 元组ip和端口) 4.关闭流对象</code></pre><p>创建 socket 语法</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Address Family：可以选择 AF_INET（用于 Internet 进程间通信） 或者 AF_UNIX（用于同一台机器进程间通信）,实际工作中常用AF_INET</span></span><br><span class="line"><span class="comment"># Type：套接字类型，可以是 SOCK_STREAM（流式套接字，主要用于 TCP 协议）或者 SOCK_DGRAM（数据报套接字，主要用于 UDP 协议）</span></span><br><span class="line"></span><br><span class="line">import <span class="built_in">socket</span></span><br><span class="line">    <span class="built_in">socket</span>.<span class="built_in">socket</span>(AddressFamily, Type)</span><br></pre></td></tr></table></figure><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>1.udp 发送</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.引包</span></span><br><span class="line">import <span class="built_in">socket</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 2.创建流对象(ipv4, udp)</span></span><br><span class="line">    <span class="comment"># socket是一个模块</span></span><br><span class="line">    <span class="comment"># socket.socket是一个类</span></span><br><span class="line">    <span class="comment">#   socket.AF_INET: 这个socket数据传世用ipv4;</span></span><br><span class="line">    <span class="comment">#   socket.SOCK_DGRAM: 这个socket使用udp协议进行数据传输;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># socket对象(套接字);    插口 -- 流对象(就要关闭 -- 发送和接收信息)</span></span><br><span class="line">    udp_socket = <span class="built_in">socket</span>.<span class="built_in">socket</span>(<span class="built_in">socket</span>.AF_INET, <span class="built_in">socket</span>.SOCK_DGRAM)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3.发送(二进制字符串, 元组ip和端口)</span></span><br><span class="line">    str1 = <span class="string">'你好,我是udp协议发送的测试数据...'</span></span><br><span class="line">    tuple1 = (<span class="string">'192.168.1.1'</span>, <span class="number">8888</span>)</span><br><span class="line">    udp_socket.sendto(str1.encode(<span class="string">'utf-8'</span>), tuple1)</span><br><span class="line">    print(tuple1, <span class="string">'发送成功!'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4.关闭流对象</span></span><br><span class="line">    udp_socket.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><p>2.udp 接收（主动接收方需手动绑定端口，发送方才知道发送给谁）</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">socket</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 1.创建套接字对象</span></span><br><span class="line">    udp_socket = <span class="built_in">socket</span>.<span class="built_in">socket</span>(<span class="built_in">socket</span>.AF_INET, <span class="built_in">socket</span>.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 绑定本地的相关信息，如果一个网络程序不绑定，则系统会随机分配</span></span><br><span class="line">    local_addr = (<span class="string">''</span>, <span class="number">8888</span>) <span class="comment">#  ip地址和端口号，ip一般不用写，表示本机的任何一个ip</span></span><br><span class="line">    udp_socket.bind(local_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.数据接收( recvfrom() )</span></span><br><span class="line">    <span class="comment">#       参数: 最多一次性接收1024字节;</span></span><br><span class="line">    <span class="comment">#       返回值: 一个元组(二进制数据, ip及port组成的元组)</span></span><br><span class="line">    <span class="comment">#       recvfrom(): 可以阻塞代码!( 类似input() )</span></span><br><span class="line">    <span class="comment">#       发送和接收数据的时候,udp承受的最大上线为: 64k</span></span><br><span class="line">    str2, tuple2 = udp_socket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    print(str2)</span><br><span class="line">    print(tuple2)</span><br><span class="line">    print(str2.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="comment"># print(str2.decode('gbk'))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4.关闭套接字</span></span><br><span class="line">    udp_socket.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><p>3.udp 聊天器</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">说明：在一个电脑中编写1个程序，有2个功能：</span></span><br><span class="line"><span class="string">    1.获取键盘数据，并将其发送给对方</span></span><br><span class="line"><span class="string">    2.接收数据并显示</span></span><br><span class="line"><span class="string">    并且功能数据进行选择以上的2个功能调用</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(udp_socket)</span>:</span></span><br><span class="line">    <span class="string">"""获取键盘数据，并将其发送给对方"""</span></span><br><span class="line">    <span class="comment"># 1. 从键盘输入数据</span></span><br><span class="line">    msg = input(<span class="string">"\n请输入要发送的数据:"</span>)</span><br><span class="line">    <span class="comment"># 2. 输入对方的ip地址</span></span><br><span class="line">    dest_ip = input(<span class="string">"\n请输入对方的ip地址:"</span>)</span><br><span class="line">    <span class="comment"># 3. 输入对方的port</span></span><br><span class="line">    dest_port = int(input(<span class="string">"\n请输入对方的port:"</span>))</span><br><span class="line">    <span class="comment"># 4. 发送数据</span></span><br><span class="line">    udp_socket.sendto(msg.encode(<span class="string">"utf-8"</span>), (dest_ip, dest_port))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_msg</span><span class="params">(udp_socket)</span>:</span></span><br><span class="line">    <span class="string">"""接收数据并显示"""</span></span><br><span class="line">    <span class="comment"># 1. 接收数据</span></span><br><span class="line">    recv_msg = udp_socket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># 2. 解码</span></span><br><span class="line">    recv_ip = recv_msg[<span class="number">1</span>]</span><br><span class="line">    recv_msg = recv_msg[<span class="number">0</span>].decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    <span class="comment"># 3. 显示接收到的数据</span></span><br><span class="line">    print(<span class="string">"&gt;&gt;&gt;%s:%s"</span> % (str(recv_ip), recv_msg))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 1. 创建套接字</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">    <span class="comment"># 2. 绑定本地信息</span></span><br><span class="line">    udp_socket.bind((<span class="string">""</span>, <span class="number">7890</span>))</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># 3. 选择功能</span></span><br><span class="line">        print(<span class="string">"="</span>*<span class="number">30</span>)</span><br><span class="line">        print(<span class="string">"1:发送消息"</span>)</span><br><span class="line">        print(<span class="string">"2:接收消息"</span>)</span><br><span class="line">        print(<span class="string">"="</span>*<span class="number">30</span>)</span><br><span class="line">        op_num = input(<span class="string">"请输入要操作的功能序号:"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4. 根据选择调用相应的函数</span></span><br><span class="line">        <span class="keyword">if</span> op_num == <span class="string">"1"</span>:</span><br><span class="line">            send_msg(udp_socket)</span><br><span class="line">        <span class="keyword">elif</span> op_num == <span class="string">"2"</span>:</span><br><span class="line">            recv_msg(udp_socket)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"输入有误，请重新输入..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="七、TCP-协议"><a href="#七、TCP-协议" class="headerlink" title="七、TCP 协议"></a>七、TCP 协议</h3><p>TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。</p><p>TCP通信需要经过 <strong>创建连接、数据传送、终止连接</strong> 三个步骤。</p><p>TCP通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，”打电话””</p><h4 id="TCP-特点"><a href="#TCP-特点" class="headerlink" title="TCP 特点"></a>TCP 特点</h4><p><strong>1.面向连接</strong></p><ol><li>通信双方必须先建立连接才能进行数据的传输，双方都必须为该连接分配必要的系统内核资源，以管理连接的状态和连接上的传输。</li><li><strong>TCP不适用于广播的应用程序，基于广播的应用程序请使用UDP协议。</strong></li></ol><p><strong>2.可靠传输</strong></p><ol><li>TCP采用发送应答机制<ul><li>TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文段传输成功</li></ul></li><li>超时重传<ul><li>发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段。</li><li>TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。</li></ul></li><li>错误校验<ul><li>TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。</li></ul></li><li>流量控制和阻塞管理<ul><li>流量控制用来避免主机发送得过快而使接收方来不及完全收下。</li></ul></li></ol><h4 id="tcp-注意点"><a href="#tcp-注意点" class="headerlink" title="tcp 注意点"></a>tcp 注意点</h4><ol><li>tcp服务器一般情况下都需要绑定ip和端口，否则客户端找不到这个服务器及其服务对应的端口</li><li>tcp客户端一般不绑定，因为是主动链接服务器，所以只要确定好服务器的ip、port等信息就好，本地客户端可以随机</li><li>tcp服务器中通过listen可以将socket创建出来的主动套接字变为被动的，这是做tcp服务器时必须要做的</li><li>当客户端需要链接服务器时，就需要使用connect进行链接，udp是不需要链接的而是直接发送，但是tcp必须先链接，只有链接成功才能通信</li><li>当一个tcp客户端连接服务器时，服务器端会有1个新的套接字，这个套接字用来标记这个客户端，单独为这个客户端服务</li><li>listen后的套接字是被动套接字，用来接收新的客户端的链接请求的，而accept返回的新套接字是标记这个新客户端的</li><li>关闭listen后的套接字意味着被动套接字关闭了，会导致新的客户端不能够链接服务器，但是之前已经链接成功的客户端正常通信。</li><li>关闭accept返回的套接字意味着这个客户端已经服务完毕</li><li>当客户端的套接字调用close后，服务器端会recv解堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来区别客户端是否已经下线</li><li>空字符串能够直接发送不能够直接接收(tcp服务端会过滤)</li></ol><h4 id="tcp-三次握手和四次挥手"><a href="#tcp-三次握手和四次挥手" class="headerlink" title="tcp 三次握手和四次挥手"></a>tcp 三次握手和四次挥手</h4><h5 id="tcp-三次握手图解"><a href="#tcp-三次握手图解" class="headerlink" title="tcp 三次握手图解"></a>tcp 三次握手图解</h5><p><img src="https://upload-images.jianshu.io/upload_images/3365001-3f3bcc28ca39fa1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tcp三次握手1.png"></p><table><thead><tr><th>标志位</th><th>序号</th></tr></thead><tbody><tr><td>SYN: 表示连接请求</td><td>seq:表示报文序号</td></tr><tr><td>ACK: 表示确认</td><td>ack: 表示确认号</td></tr><tr><td>FIN:  表示关闭连接</td><td></td></tr></tbody></table><p><img src="https://upload-images.jianshu.io/upload_images/3365001-4203e495de645009.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="tcp三次握手.png"></p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）第一次握手：<span class="built_in">Client</span>将标志位SYN置为<span class="number">1</span>，随机产生一个值seq=J，并将该数据包发送给<span class="built_in">Server</span>，<span class="built_in">Client</span>进入SYN_SENT状态，等待<span class="built_in">Server</span>确认。</span><br><span class="line">（<span class="number">2</span>）第二次握手：<span class="built_in">Server</span>收到数据包后由标志位SYN=<span class="number">1</span>知道<span class="built_in">Client</span>请求建立连接，<span class="built_in">Server</span>将标志位SYN和ACK都置为<span class="number">1</span>， ack (number )=J+<span class="number">1</span>，随机产生一个值seq=K，并将该数据包发送给<span class="built_in">Client</span>以确认连接请求，<span class="built_in">Server</span>进入SYN_RCVD状态。</span><br><span class="line">（<span class="number">3</span>）第三次握手：<span class="built_in">Client</span>收到确认后，检查ack是否为J+<span class="number">1</span>，ACK是否为<span class="number">1</span>，如果正确则将标志位ACK置为<span class="number">1</span>，ack=K+<span class="number">1</span>，并将该数据包发送给<span class="built_in">Server</span>，<span class="built_in">Server</span>检查ack是否为K+<span class="number">1</span>，ACK是否为<span class="number">1</span>，如果正确则连接建立成功，<span class="built_in">Client</span>和<span class="built_in">Server</span>进入ESTABLISHED状态，完成三次握手，随后<span class="built_in">Client</span>与<span class="built_in">Server</span>之间可以开始传输数据了。</span><br><span class="line"></span><br><span class="line">理解总结：</span><br><span class="line"><span class="number">1.</span>客户端发起连接请求，等待服务端确定</span><br><span class="line"><span class="number">2.</span>服务端确认连接请求</span><br><span class="line"><span class="number">3.</span>客户端收到确认后，再次发送数据包验证（验证正确，连接成功，完成三次握手）</span><br></pre></td></tr></table></figure><h5 id="tcp-四次挥手图解"><a href="#tcp-四次挥手图解" class="headerlink" title="tcp 四次挥手图解"></a>tcp 四次挥手图解</h5><p><img src="https://upload-images.jianshu.io/upload_images/3365001-e77fdb8210af7052.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tcp四次挥手.png"></p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">客户端主动关闭（三次挥手）：</span><br><span class="line">（<span class="number">1</span>）第一次挥手：客户端发送一个FIN，用来关闭客户端到服务的数据传送。</span><br><span class="line">（<span class="number">2</span>）第二次挥手：服务端发送一个ACK，用来关闭服务端到客户端的数据传送。</span><br><span class="line">（<span class="number">3</span>) 第三次挥手：客户端收到ACK后，接着发送一个ACK给服务端，确认序号为收到序号+<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">服务端主动关闭（四次挥手）：</span><br><span class="line">（<span class="number">1</span>）第一次挥手：server发送一个FIN，用来关闭server到client的数据传送。</span><br><span class="line">（<span class="number">2</span>) 第二次挥手：client收到FIN后，发送一个ACK给server，确认序号为收到序号+<span class="number">1</span>。</span><br><span class="line">（<span class="number">3</span>）第三次挥手：client发送一个FIN，用来关闭Client到Server的数据传送。</span><br><span class="line">（<span class="number">4</span>) 第四次挥手：Server收到FIN后，接着发送一个ACK给Client，确认序号为收到序号+<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">理解总结：</span><br><span class="line"><span class="number">1.</span>服务端 close()（我要关闭连接了）</span><br><span class="line"><span class="number">2.</span>客户端收到后发送一条消息（别急，事情还没处理完...）</span><br><span class="line"><span class="number">3.</span>客户端处理完成后 close()（可以关闭连接了）</span><br><span class="line"><span class="number">4.</span>服务端接着发送一个 ACK 给 Client（连接已关闭！四次挥手完成）</span><br></pre></td></tr></table></figure><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p>1.tcp 客户端</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">from socket import *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建socket</span></span><br><span class="line">tcp_client_socket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目的信息</span></span><br><span class="line">server_ip = input(<span class="string">"请输入服务器ip:"</span>)</span><br><span class="line">server_port = int(input(<span class="string">"请输入服务器port:"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接服务器</span></span><br><span class="line">tcp_client_socket.connect((server_ip, server_port))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示用户输入数据</span></span><br><span class="line">send_data = input(<span class="string">"请输入要发送的数据："</span>)</span><br><span class="line"></span><br><span class="line">tcp_client_socket.send(send_data.encode(<span class="string">"gbk"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收对方发送过来的数据，最大接收1024个字节</span></span><br><span class="line">recvData = tcp_client_socket.recv(1024)</span><br><span class="line"><span class="section">print('接收到的数据为:', recvData.decode('gbk'))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭套接字</span></span><br><span class="line">tcp_client_socket.close()</span><br></pre></td></tr></table></figure><p>2.tcp 服务端</p><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">步骤：</span></span><br><span class="line"><span class="string">    1.socket创建一个套接字</span></span><br><span class="line"><span class="string">    2.bind绑定ip和port</span></span><br><span class="line"><span class="string">    3.listen使套接字变为可以被动链接</span></span><br><span class="line"><span class="string">    4.accept等待客户端的链接</span></span><br><span class="line"><span class="string">    5.recv/send接收发送数据</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">from socket import *</span><br><span class="line"></span><br><span class="line"><span class="meta"># 创建socket</span></span><br><span class="line">tcp_server_socket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="meta"># 本地信息</span></span><br><span class="line">address = (<span class="string">''</span>, <span class="number">7788</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta"># 绑定</span></span><br><span class="line">tcp_server_socket.bind(address)</span><br><span class="line"></span><br><span class="line"><span class="meta"># 使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收别人的链接了</span></span><br><span class="line">tcp_server_socket.listen(<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务</span></span><br><span class="line"><span class="meta"># client_socket用来为这个客户端服务</span></span><br><span class="line"><span class="meta"># tcp_server_socket就可以省下来专门等待其他新客户端的链接</span></span><br><span class="line">client_socket, clientAddr = tcp_server_socket.accept()</span><br><span class="line"></span><br><span class="line"><span class="meta"># 接收对方发送过来的数据</span></span><br><span class="line">recv_data = client_socket.recv(<span class="number">1024</span>)  # 接收<span class="number">1024</span>个字节</span><br><span class="line">print(<span class="string">'接收到的数据为:'</span>, recv_data.decode(<span class="string">'gbk'</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta"># 发送一些数据到客户端</span></span><br><span class="line">client_socket.send(<span class="string">"thank you !"</span>.encode(<span class="string">'gbk'</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta"># 关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了，如果还需要服务，只能再次重新连接</span></span><br><span class="line">client_socket.close()</span><br></pre></td></tr></table></figure><h3 id="八、TCP-与-UDP-的不同点"><a href="#八、TCP-与-UDP-的不同点" class="headerlink" title="八、TCP 与 UDP 的不同点"></a>八、TCP 与 UDP 的不同点</h3><p><strong>TCP：</strong></p><ul><li>面向连接（确认有创建三方交握，连接已创建才作传输。）</li><li>有序数据传输</li><li>重发丢失的数据包</li><li>舍弃重复的数据包</li><li>无差错的数据传输</li><li>阻塞/流量控制</li></ul><p><strong>UDP 通信模型（类似于写信/发短信/广播/视频聊天）</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-66f6ee5be9f9df0f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="udp通信模型.jpg"></p><p><strong>TCP 通信模型（类似于打电话）</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-55244b661df4c1a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP通信模型.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UDP 和 TCP 及 socket 介绍；&lt;/li&gt;
&lt;li&gt;网络七层协议(四/五层模型)；&lt;/li&gt;
&lt;li&gt;IP 地址与端口；&lt;/li&gt;
&lt;li&gt;Python3 编码转换；&lt;/li&gt;
&lt;li&gt;Socket 套接字；&lt;/li&gt;
&lt;li&gt;UDP 协议；&lt;/li&gt;
&lt;li&gt;TCP 协议。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="udp" scheme="http://jovelin.cn/tags/udp/"/>
    
      <category term="tcp" scheme="http://jovelin.cn/tags/tcp/"/>
    
      <category term="socket" scheme="http://jovelin.cn/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>反问学习法（what、why、where），十万个为什么</title>
    <link href="http://jovelin.cn/2018/07/06/%E5%8F%8D%E9%97%AE%E5%AD%A6%E4%B9%A0%E6%B3%95%EF%BC%88what%E3%80%81why%E3%80%81where%EF%BC%89%EF%BC%8C%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88/"/>
    <id>http://jovelin.cn/2018/07/06/反问学习法（what、why、where），十万个为什么/</id>
    <published>2018-07-06T02:13:37.000Z</published>
    <updated>2018-07-18T11:49:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/3365001-b563404345271200.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="why.jpg"></p><p>不知道你们有没有这样的感受，就是当学完了一个知识点，可能知道怎么用、知道写代码的步骤（像套模板一样，按照案例、步骤一步步码出来），反正就是代码我能写出来，但是这个知识点是什么？为什么用它？在哪里使用这个知识点？往往就不是很清楚，有点印象、模模糊糊，理解不透彻。</p><a id="more"></a><p>平常工作的话，知道怎么用、知道怎么实现该功能，反正能完成任务即可，管它那么多！</p><p>那么问题来了，既然平常工作都没什么问题，还管它那么多干啥呢干啥呢。。</p><p><strong>原因有两点：</strong></p><p>一、深度掌握（用起来得心应手）</p><p>不只是照抄搬运，不是所有事情 copy 就能实现，要合理利用以前写过的案例，实现过的项目功能，懂得哪些地方能抄，也要懂得想改哪里就改哪里（就像一个人物换了个皮肤，相同点还是不变的，不同点就需要自己去发现去改造了，比如：变好看了，攻击变强了。。）</p><p>二、面试</p><p>大家都知道一个完整的面试包括三个流程（1、笔试 2、技术面试 3、hr面谈）</p><p>当然也有不用笔试的，2轮技术面试的也有，没有 hr 面谈的也大有存在，CTO 直接就能决定你的薪资，这也是小公司和大公司的一种差异</p><p>1.笔试：也就类似我们平常的考试，选择题、大题都有，只不过是综合的罢了（基础）</p><p>2.技术面谈：</p><ol><li>就你写的技术进行提问（一般有三种掌握程度，了解/熟练/精通）</li><li><p>项目上的提问（实现的过程、某个难点技术、碰到的 bug、团队开发遇到的问题都有。。）</p><p> 这就不仅仅是 知道怎么用、知道怎么实现该功能 就能过关了，和下面演示的 3个W反问 有关系了。</p></li><li><p>hr 面谈（恭喜你基本已经被录用了，谈工资这一块了，砍价、福利。。）</p></li></ol><blockquote><p>知识点分类：</p><p>1.死知识（不用死记硬背，API 文档、笔记、博客查阅即可） </p><p>2.理解性知识（理解实现原理，懂得框架，实现时灵活运用）</p></blockquote><p><strong>以 socket 知识点为例：</strong></p><p>———socket———</p><p>what<br>是什么？（概念、理解）</p><p>socket(简称 套接字 也称为插口–流对象) 是进程间通信的一种方式</p><p>why<br>为什么用？（好处，特点即不同点）</p><p>是实现tcp和udp的底层技术，实现 不同主机间 的进程间通信</p><p>where<br>在哪使用？（案例、实战）</p><p>网络程序发送、接收数据（发短信、打电话、广播）</p><p>————end————</p><blockquote><p>人生苦短，我用 Python，为何你要用 Python？———杠精</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3365001-b563404345271200.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;why.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;不知道你们有没有这样的感受，就是当学完了一个知识点，可能知道怎么用、知道写代码的步骤（像套模板一样，按照案例、步骤一步步码出来），反正就是代码我能写出来，但是这个知识点是什么？为什么用它？在哪里使用这个知识点？往往就不是很清楚，有点印象、模模糊糊，理解不透彻。&lt;/p&gt;
    
    </summary>
    
      <category term="学习方法" scheme="http://jovelin.cn/categories/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="学习方法" scheme="http://jovelin.cn/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux 终端命令</title>
    <link href="http://jovelin.cn/2018/07/03/Linux%20%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/"/>
    <id>http://jovelin.cn/2018/07/03/Linux 终端命令/</id>
    <published>2018-07-03T01:00:01.000Z</published>
    <updated>2018-07-28T02:50:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux-终端命令"><a href="#Linux-终端命令" class="headerlink" title="Linux 终端命令"></a>Linux 终端命令</h3><h4 id="01-终端命令格式"><a href="#01-终端命令格式" class="headerlink" title="01. 终端命令格式"></a>01. 终端命令格式</h4><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">command <span class="string">[-options]</span> <span class="string">[parameter]</span></span><br><span class="line">    command：命令名，相应功能的英文单词或单词的缩写</span><br><span class="line">    <span class="string">[-options]</span>：选项，可用来对命令进行控制，也可以省略</span><br><span class="line">    <span class="string">[parameter]</span>：传给命令的参数，可以是 零个、一个 或者 多个</span><br></pre></td></tr></table></figure><h4 id="02-查阅命令帮助信息"><a href="#02-查阅命令帮助信息" class="headerlink" title="02. 查阅命令帮助信息"></a>02. 查阅命令帮助信息</h4><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="number">2.1</span> <span class="comment">--help</span></span><br><span class="line">    <span class="keyword">command</span> --<span class="title">help</span></span><br><span class="line">    显示 <span class="keyword">command</span> 命令的帮助信息</span><br><span class="line"></span><br><span class="line"><span class="number">2.2</span> man</span><br><span class="line">    man <span class="keyword">command</span></span><br><span class="line">    查阅 <span class="keyword">command</span> 命令的使用手册</span><br><span class="line">    </span><br><span class="line">    man 是 manual 的缩写，是 Linux 提供的一个手册，包含了绝大部分的命令、函数的详细使用说明</span><br><span class="line"></span><br><span class="line">    使用 man 时的操作键：</span><br><span class="line">        空格键：显示手册页的下一屏</span><br><span class="line">        Enter 键：一次滚动手册页的一行</span><br><span class="line">        b：回滚一屏</span><br><span class="line">        f：前滚一屏</span><br><span class="line">        q：退出</span><br><span class="line">        /<span class="built_in">word</span>：搜索 <span class="built_in">word</span> 字符串</span><br></pre></td></tr></table></figure><h3 id="Linux-基本命令-一"><a href="#Linux-基本命令-一" class="headerlink" title="Linux 基本命令(一)"></a>Linux 基本命令(一)</h3><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">Linux 文件或者目录名称最长可以有 265 个字符，“.”代表当前目录，“..”代表上一级目录，以“.”开头的文件为隐藏文件，需要用 -a 参数才能显示。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 查看文件信息：<span class="keyword">ls</span></span><br><span class="line">    -a  显示指定目录下所有子目录与文件，包括隐藏文件</span><br><span class="line">    -<span class="keyword">l</span>以列表方式显示文件的详细信息</span><br><span class="line">    -<span class="keyword">h</span>配合 -<span class="keyword">l</span> 以人性化的方式显示文件大小（字节大小以 K 显示）</span><br><span class="line">    </span><br><span class="line">    $ <span class="keyword">ls</span> -a</span><br><span class="line">    $ <span class="keyword">ls</span> -<span class="keyword">l</span></span><br><span class="line">    $ <span class="keyword">ls</span> -<span class="keyword">l</span> -<span class="built_in">h</span></span><br><span class="line">    $ <span class="keyword">ls</span> -alh</span><br><span class="line">    </span><br><span class="line">2. 清屏：<span class="keyword">clear</span></span><br><span class="line">    <span class="keyword">clear</span> 作用为清除终端上的显示(类似于 DOS 的 cls 清屏功能)，也可使用快捷键：Ctrl + <span class="keyword">L</span></span><br><span class="line"></span><br><span class="line">3. 切换工作目录： <span class="keyword">cd</span></span><br><span class="line">    <span class="keyword">cd</span>    切换到当前用户的主目录(/home/用户目录)，用户登陆的时候，默认的目录就是用户的主目录。</span><br><span class="line">    <span class="keyword">cd</span> ~切换到当前用户的主目录(/home/用户目录)</span><br><span class="line">    <span class="keyword">cd</span> .切换到当前目录</span><br><span class="line">    <span class="keyword">cd</span> ..切换到上级目录</span><br><span class="line">    <span class="keyword">cd</span> -可进入上次所在的目录</span><br><span class="line">    </span><br><span class="line">4. 显示当前路径：<span class="keyword">pwd</span></span><br><span class="line">    </span><br><span class="line">5. 创建目录：<span class="keyword">mkdir</span></span><br><span class="line">    通过<span class="keyword">mkdir</span>命令可以创建一个新的目录。参数 -p 可递归创建目录。</span><br><span class="line">    </span><br><span class="line">    $ <span class="keyword">mkdir</span> newdir1</span><br><span class="line">    $ <span class="keyword">mkdir</span> -p newdir2/a/b/c</span><br><span class="line">    </span><br><span class="line">6. 删除文件：<span class="keyword">rm</span></span><br><span class="line">    可通过<span class="keyword">rm</span>删除文件或目录。使用<span class="keyword">rm</span>命令要小心，因为文件删除后不能恢复。</span><br><span class="line">    为了防止文件误删，可以在<span class="keyword">rm</span>后使用-i参数以逐个确认要删除的文件。</span><br><span class="line">    </span><br><span class="line">    -i以进行交互式方式执行</span><br><span class="line">    -f强制删除，忽略不存在的文件，无需提示</span><br><span class="line">    -r递归地删除目录下的内容，删除文件夹时必须加此参数</span><br><span class="line">    </span><br><span class="line">    $ <span class="keyword">rm</span> -<span class="keyword">if</span> newfile.txt</span><br><span class="line">    $ <span class="keyword">rm</span> -<span class="keyword">ir</span> newdir1</span><br><span class="line">    </span><br><span class="line">7. 拷贝：cp</span><br><span class="line">    cp 命令的功能是将给出的文件或目录复制到另一个文件或目录中，相当于 DOS 下的 <span class="keyword">copy</span> 命令。</span><br><span class="line">    </span><br><span class="line">    -a该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录，简单而言，保持文件原有属性。</span><br><span class="line">    -f已经存在的目标文件而不提示</span><br><span class="line">    -i交互式复制，在覆盖目标文件之前将给出提示要求用户确认</span><br><span class="line">    -r若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名。</span><br><span class="line">    -v显示拷贝进度</span><br><span class="line">    </span><br><span class="line">    $ cp -ivr newdir1 newdir2</span><br><span class="line">    </span><br><span class="line">8. mv：移动、重命名</span><br><span class="line">    用户可以使用mv命令来移动文件或目录，也可以给文件或目录重命名。</span><br><span class="line">    </span><br><span class="line">    -f禁止交互式操作，如有覆盖也不会给出提示</span><br><span class="line">    -i确认交互方式操作，如果mv操作将导致对已存在的目标文件的覆盖，系统会询问是否重写，要求用户回答以避免误覆盖文件</span><br><span class="line">    -v显示移动进度</span><br><span class="line">    </span><br><span class="line">    $ mv -iv newdir1 newdir3</span><br><span class="line">    </span><br><span class="line">9. 创建文件: touch</span><br><span class="line">    用户可以通过touch来创建一个空的文件</span><br><span class="line">    </span><br><span class="line">    $ touch hello.txt</span><br><span class="line">    </span><br><span class="line">10. 查看文件树状图：tree</span><br><span class="line">    通过使用 tree 命令来查看我们的文件树状图，那么如果我们的电脑里面没有安装tree的软件的话，那么就会执行命令失败，出现如下的问题：-bash: tree: command not found</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">Mac</span> 上安装 tree 安装包：</span><br><span class="line">    $ brew install tree</span><br><span class="line"></span><br><span class="line">11. echo</span><br><span class="line">    echo 命令用于在 <span class="keyword">shell</span> 中打印 <span class="keyword">shell</span> 变量的值，或者直接输出指定的字符串。</span><br><span class="line">    </span><br><span class="line">12. gedit</span><br><span class="line">    gedit 命令可以打开 linux 下记事本，类似 windows 下的 notepad (txt-记事本)</span><br></pre></td></tr></table></figure><h3 id="Linux-基本命令-二"><a href="#Linux-基本命令-二" class="headerlink" title="Linux 基本命令(二)"></a>Linux 基本命令(二)</h3><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">1. 输出重定向命令：&gt;</span><br><span class="line">    Linux 允许将命令执行结果重定向到一个文件，本应显示在终端上的内容保存到指定文件中。</span><br><span class="line">    </span><br><span class="line">    # <span class="keyword">test</span>.txt 如果不存在，则创建，存在则覆盖其内容</span><br><span class="line">        $ <span class="keyword">ls</span> &gt; <span class="keyword">test</span>.txt</span><br><span class="line">        $ echo 111 &gt; <span class="keyword">test</span>.txt</span><br><span class="line">        $ tree &gt; <span class="keyword">test</span>.txt</span><br><span class="line">    </span><br><span class="line">    注意：&gt;输出重定向会覆盖原来的内容，&gt;&gt;输出重定向则会追加到文件的尾部。 </span><br><span class="line"></span><br><span class="line">2. 查看或者合并文件内容：<span class="keyword">cat</span></span><br><span class="line"></span><br><span class="line">    # 查看文件所有内容,并全部显示</span><br><span class="line">    $ <span class="keyword">cat</span> 文件</span><br><span class="line"># 1.txt 2.txt文件内容保存到3.txt</span><br><span class="line">    $ <span class="keyword">cat</span> 1.txt 2.txt &gt; 3.txt</span><br><span class="line"># 1.txt 2.txt文件内容追加到3.txt</span><br><span class="line">    $ <span class="keyword">cat</span> 1.txt 2.txt &gt;&gt; 3.txt</span><br><span class="line"></span><br><span class="line">3. 分屏显示：<span class="keyword">more</span></span><br><span class="line">    分屏显示文件内容,每次只显示一页</span><br><span class="line"></span><br><span class="line"><span class="keyword">more</span> 文件名</span><br><span class="line"></span><br><span class="line">f/空格：翻到下一页</span><br><span class="line">b：翻到上一页</span><br><span class="line">回车：显示下一行</span><br><span class="line">q：退出当前显示</span><br><span class="line"><span class="keyword">h</span>：查看帮助</span><br><span class="line"></span><br><span class="line">4. 管道：|</span><br><span class="line">一个命令的输出可以通过管道做为另一个命令的输入</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">ls</span> /bin | <span class="keyword">more</span></span><br><span class="line"></span><br><span class="line">查看 bin 目录下的文件信息，让显示在终端的数据保存在管道里面，然后通过 <span class="keyword">more</span> 分屏显示管道里面的数据</span><br><span class="line">经常和 grep/xargs 连用</span><br><span class="line"></span><br><span class="line">$ grep -i '-' 1.txt | <span class="keyword">more</span></span><br><span class="line"></span><br><span class="line">5. 文本搜索：grep</span><br><span class="line">    Linux 系统中 grep 命令是一种强大的文本搜索工具，grep 允许对文本文件进行模式查找。</span><br><span class="line">    如果找到匹配模式，grep 打印包含模式的所有行。</span><br><span class="line">    </span><br><span class="line">    grep [-选项] '搜索内容串' 文件名</span><br><span class="line">    </span><br><span class="line">    -v显示不包含匹配文本的所有行（相当于求反）</span><br><span class="line">    -<span class="keyword">n</span>显示匹配行及行号</span><br><span class="line">    -i忽略大小写</span><br><span class="line">    </span><br><span class="line">    grep 常用正则表达式：</span><br><span class="line"></span><br><span class="line">    ^a  行首,搜寻以 a 开头的行；grep -<span class="keyword">n</span> '^a' 1.txt</span><br><span class="line">    ke$  行尾,搜寻以 ke 结束的行；grep -<span class="keyword">n</span> 'ke$' 1.txt</span><br><span class="line">    [Ss]  匹配 [] 里中一系列字符中的一个；grep -<span class="keyword">n</span> '[Ss]igna' 1.txt</span><br><span class="line">    .  匹配一个非换行符的字符；grep -<span class="keyword">n</span> '<span class="keyword">e</span>.<span class="keyword">e</span>' 1.txt</span><br><span class="line">    </span><br><span class="line">6. 建立链接文件：<span class="built_in">ln</span></span><br><span class="line">    1. 软链接</span><br><span class="line">    适合做快捷方式</span><br><span class="line">    源文件删除,软链接失效</span><br><span class="line">    </span><br><span class="line">    $ ln -s 源文件/文件夹 软链接名</span><br><span class="line">    </span><br><span class="line">    软链接文件和源文件不在同一个目录，源文件要使用绝对路径</span><br><span class="line">    软链接可以对文件或文件夹进行操作</span><br><span class="line">    创建软链接,文件/目录硬链接数不会增加</span><br><span class="line"></span><br><span class="line">2. 硬链接</span><br><span class="line">    适合做数据备份</span><br><span class="line">    源文件删除,硬链接不失效</span><br><span class="line">    </span><br><span class="line">    $ ln 源文件 硬链接名</span><br><span class="line">    </span><br><span class="line">    硬链接只能对文件进行操作</span><br><span class="line">    创建硬链接,文件的硬链接数会增加</span><br><span class="line">    </span><br><span class="line">7. 查找文件：find</span><br><span class="line">    find 命令功能非常强大，通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件。</span><br><span class="line">    </span><br><span class="line">    find ./ -name <span class="keyword">test</span>.<span class="keyword">sh</span>查找当前目录下所有名为<span class="keyword">test</span>.<span class="keyword">sh</span>的文件</span><br><span class="line">    find ./ -name '*.<span class="keyword">sh</span>'查找当前目录下所有后缀为.<span class="keyword">sh</span>的文件</span><br><span class="line">    find ./ -name '[A-Z]*'查找当前目录下所有以大写字母开头的文件</span><br><span class="line">    find /tmp -size 2M    查找在/tmp 目录下等于2M的文件</span><br><span class="line">    find /tmp -size +2M    查找在/tmp 目录下大于2M的文件</span><br><span class="line">    find /tmp -size -2M    查找在/tmp 目录下小于2M的文件</span><br><span class="line">    find ./ -size +4k -size -5M    查找当前目录下大于4k，小于5M的文件</span><br><span class="line">    find ./ -perm 777    查找当前目录下权限为 777 的文件或目录</span><br><span class="line">    find 目录 -<span class="keyword">type</span> f/<span class="keyword">d</span>     查找指定目录下的文件/文件夹</span><br><span class="line"></span><br><span class="line">8. 归档管理：tar</span><br><span class="line">1. 归档+打包</span><br><span class="line">tar</span><br><span class="line">归档：tar -cvf <span class="keyword">test</span>.tar *.txt</span><br><span class="line">        把所有.txt文件打包为<span class="keyword">test</span>.tar</span><br><span class="line">解档：tar -xvf <span class="keyword">test</span>.tar -C指定文件夹</span><br><span class="line">        将<span class="keyword">test</span>.tar解档到指定目录</span><br><span class="line">gzip</span><br><span class="line">压缩：gzip -r <span class="keyword">test</span>.tar <span class="keyword">test</span>.tar.gz</span><br><span class="line">将<span class="keyword">test</span>.tar压缩为<span class="keyword">test</span>.tar.gzip</span><br><span class="line">解压：gzip -<span class="keyword">d</span> <span class="keyword">test</span>.tar.gz <span class="keyword">test</span>.tar</span><br><span class="line">将<span class="keyword">test</span>.tar.gz解压为<span class="keyword">test</span>.tar</span><br><span class="line">bzip2</span><br><span class="line">压缩：bzip2 -r <span class="keyword">test</span>.tar <span class="keyword">test</span>.tar.bz2</span><br><span class="line">将<span class="keyword">test</span>.tar压缩为<span class="keyword">test</span>.tar.bz2</span><br><span class="line">解压：bzip2 -<span class="keyword">d</span> <span class="keyword">test</span>.tar.bz2 <span class="keyword">test</span>.tar</span><br><span class="line">将<span class="keyword">test</span>.tar.bz2解压为<span class="keyword">test</span>.tar</span><br><span class="line">2. gzip格式</span><br><span class="line">tar 归档+压缩：tar -zcvf <span class="keyword">test</span>.tar.gz *.txt</span><br><span class="line">所有.txt后缀的文件压缩为<span class="keyword">test</span>.tar.gz</span><br><span class="line">tar 解档+解压：tar -zxvf <span class="keyword">test</span>.tar.gz -C 指定文件夹</span><br><span class="line">解压<span class="keyword">test</span>.tar.gz到指定的文件夹</span><br><span class="line"></span><br><span class="line">3. bzip2格式</span><br><span class="line">tar 归档+压缩：tar -jcvf <span class="keyword">test</span>.tar.bz2 *.html</span><br><span class="line">所有.html后缀的文件压缩为<span class="keyword">test</span>.tar.bz2</span><br><span class="line">tar 解档+解压：tar -jxvf <span class="keyword">test</span>.tar.bz2 -C 指定文件夹</span><br><span class="line">解压<span class="keyword">test</span>.tar.bz2到指定的文件夹</span><br><span class="line">4. <span class="keyword">zip</span>格式</span><br><span class="line"><span class="keyword">zip</span> 压缩：<span class="keyword">zip</span> -r <span class="keyword">test</span>.<span class="keyword">zip</span> *.py</span><br><span class="line"><span class="keyword">zip</span>格式压缩所有.py文件</span><br><span class="line">unzip 解压：unzip -<span class="keyword">d</span> 指定文件夹 <span class="keyword">test</span>.<span class="keyword">zip</span></span><br><span class="line">解压<span class="keyword">test</span>.<span class="keyword">zip</span>到指定文件夹</span><br><span class="line"></span><br><span class="line">常用参数</span><br><span class="line">    -c生成档案文件，创建打包文件</span><br><span class="line">        -v列出归档解档的详细过程，显示进度</span><br><span class="line">        -f指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后</span><br><span class="line">        -t列出档案中包含的文件</span><br><span class="line">        -x解开档案文件</span><br><span class="line">        -<span class="keyword">d</span>解压</span><br><span class="line">        -r压缩所有子目录</span><br><span class="line">        -z  指定压缩包的格式为：<span class="keyword">file</span>.tar.gz</span><br><span class="line"></span><br><span class="line">9. 查看命令位置：<span class="keyword">which</span></span><br><span class="line">    $ <span class="keyword">which</span> <span class="keyword">ls</span></span><br><span class="line">    </span><br><span class="line">10. 修改文件权限：chmod</span><br><span class="line">文件权限</span><br><span class="line">r   可读    数字代号: 4</span><br><span class="line">w   可写    数字代号: 2</span><br><span class="line">x   可执行  数字代号: 1</span><br><span class="line">-   无任何权限  数字代号: 0</span><br><span class="line"></span><br><span class="line">用户</span><br><span class="line"><span class="keyword">u</span>   当前用户(user)</span><br><span class="line"><span class="keyword">g</span>   同组用户(group)</span><br><span class="line">o   其他用户(other)</span><br><span class="line">a所有用户(all)</span><br><span class="line"></span><br><span class="line">设置权限</span><br><span class="line">+添加权限</span><br><span class="line">-删除权限</span><br><span class="line">=设置权限</span><br><span class="line"></span><br><span class="line">字母法设置权限</span><br><span class="line">chmod <span class="keyword">u</span>/<span class="keyword">g</span>/o/a +/-/= rwx 文件</span><br><span class="line">chmod a= 1.txt</span><br><span class="line">所有用户没有权限</span><br><span class="line">chmod a=rwx 1.txt</span><br><span class="line">所有用户都有全部权限</span><br><span class="line">chmod <span class="keyword">u</span>+x 1.txt</span><br><span class="line">给当前用户添加可执行的权限</span><br><span class="line"></span><br><span class="line">数字法设置权限</span><br><span class="line">chmod 777 文件名</span><br><span class="line">给所有用户添加全部权限</span><br><span class="line">chmod 751 文件名</span><br><span class="line">给当前用户rwx权限,本组用户rx权限,其他用户x权限</span><br><span class="line"></span><br><span class="line">11. 切换账号</span><br><span class="line">切换到管理员账号</span><br><span class="line">sudo -<span class="built_in">s</span></span><br><span class="line">切换到其他账号</span><br><span class="line"><span class="keyword">su</span> 其他账号名</span><br><span class="line"></span><br><span class="line">12. 设置用户密码：passwd</span><br><span class="line">sudo passwd 新密码</span><br><span class="line"></span><br><span class="line">13. 退出登录账户：<span class="keyword">exit</span></span><br><span class="line"></span><br><span class="line">14. 查看登录用户：who</span><br><span class="line">who     查看当前系统登录的所有用户名</span><br><span class="line">who -q  只显示用户登录的账号和登录的用户数量</span><br><span class="line">who -<span class="keyword">u</span>  只显示列标题</span><br><span class="line">whoami  只显示当前用户登录的用户名</span><br><span class="line"></span><br><span class="line">15. 关机重启</span><br><span class="line">shutdown</span><br><span class="line">shutdown -r now</span><br><span class="line">重启系统,并给其他用户提示</span><br><span class="line">shutdown -<span class="keyword">h</span> now</span><br><span class="line">立刻关机</span><br><span class="line">shutdown -<span class="keyword">h</span> 20:25</span><br><span class="line">系统在今天的20:25 关机</span><br><span class="line">shutdown -<span class="keyword">h</span> +10</span><br><span class="line">系统再过十分钟,自动关机</span><br><span class="line">shutdown -c</span><br><span class="line">取消关机</span><br><span class="line"></span><br><span class="line">init</span><br><span class="line">init 0  系统关机</span><br><span class="line">init 6  系统重启</span><br><span class="line"></span><br><span class="line">reboot</span><br><span class="line">重新启动系统</span><br></pre></td></tr></table></figure><h3 id="软件操作的相关命令"><a href="#软件操作的相关命令" class="headerlink" title="软件操作的相关命令"></a>软件操作的相关命令</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> update  更新源</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install package 安装包</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> <span class="builtin-name">remove</span> package 删除包</span><br><span class="line"></span><br><span class="line">sudo apt-cache search package 搜索软件包</span><br><span class="line"></span><br><span class="line">sudo apt-cache show package  获取包的相关信息，如说明、大小、版本等</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install package --reinstall   重新安装包</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> -f install   修复安装</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> <span class="builtin-name">remove</span> package --purge 删除包，包括配置文件等</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> build-dep package 安装相关的编译环境</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span><span class="built_in"> upgrade </span>更新已安装的包</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> dist-upgrade 升级系统</span><br><span class="line"></span><br><span class="line">sudo apt-cache depends package 了解使用该包依赖那些包</span><br><span class="line"></span><br><span class="line">sudo apt-cache rdepends package 查看该包被哪些包依赖</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> source package  下载该包的源代码</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> clean &amp;&amp; sudo apt-<span class="builtin-name">get</span> autoclean 清理无用的包</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> check 检查是否有损坏的依赖</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="1-必须学会使用的"><a href="#1-必须学会使用的" class="headerlink" title="1.必须学会使用的"></a>1.必须学会使用的</h4><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">命令行安装工具：（例如: tree/greenlet/gevent.<span class="string">..</span>）</span><br><span class="line">sudo apt-get install 包名</span><br><span class="line">sudo gedit 文件名</span><br><span class="line"></span><br><span class="line">基本命令：<span class="keyword">cd</span> <span class="keyword">ls</span></span><br></pre></td></tr></table></figure><h4 id="2-大纲要求会的-以后上班有可能用的到"><a href="#2-大纲要求会的-以后上班有可能用的到" class="headerlink" title="2.大纲要求会的(以后上班有可能用的到)"></a>2.大纲要求会的(以后上班有可能用的到)</h4><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">a</span>. <span class="keyword">cp</span>/rm/<span class="built_in">mkdir</span>/mv/touch/<span class="keyword">find</span></span><br><span class="line"><span class="keyword">b</span>. putty/filezilla 等远程操控及文件传输软件的使用</span><br><span class="line"><span class="keyword">c</span>. <span class="keyword">vim</span> 能够修改内容（最简单形式）</span><br><span class="line">d. 命令 | <span class="keyword">grep</span> 内容：从前面命令中获取指定内容</span><br><span class="line"><span class="keyword">e</span>. passwd/who/<span class="keyword">ln</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Linux-终端命令&quot;&gt;&lt;a href=&quot;#Linux-终端命令&quot; class=&quot;headerlink&quot; title=&quot;Linux 终端命令&quot;&gt;&lt;/a&gt;Linux 终端命令&lt;/h3&gt;&lt;h4 id=&quot;01-终端命令格式&quot;&gt;&lt;a href=&quot;#01-终端命令格式&quot; c
      
    
    </summary>
    
      <category term="Linux" scheme="http://jovelin.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://jovelin.cn/tags/Linux/"/>
    
      <category term="Linux 命令" scheme="http://jovelin.cn/tags/Linux-%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>
