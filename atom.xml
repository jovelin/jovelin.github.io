<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jovelin&#39;s Blog</title>
  
  <subtitle>Python The old farmer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jovelin.cn/"/>
  <updated>2018-07-28T02:45:25.000Z</updated>
  <id>http://jovelin.cn/</id>
  
  <author>
    <name>曹永林</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python miniweb 框架</title>
    <link href="http://jovelin.cn/2018/07/26/Python%20miniweb%20%E6%A1%86%E6%9E%B6/"/>
    <id>http://jovelin.cn/2018/07/26/Python miniweb 框架/</id>
    <published>2018-07-26T01:00:01.000Z</published>
    <updated>2018-07-28T02:45:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>web 开发各个节点关系图；</li><li>资源分类；</li><li>路由；</li><li>shell 脚本。</li></ol></blockquote><a id="more"></a><h1 id="miniweb-框架"><a href="#miniweb-框架" class="headerlink" title="miniweb 框架"></a>miniweb 框架</h1><h3 id="一、web-开发各个节点关系图"><a href="#一、web-开发各个节点关系图" class="headerlink" title="一、web 开发各个节点关系图"></a>一、web 开发各个节点关系图</h3><p><img src="https://upload-images.jianshu.io/upload_images/3365001-d7c1e7dfb5b1f5f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="web 开发各个节点关系.png"></p><h3 id="二、资源分类"><a href="#二、资源分类" class="headerlink" title="二、资源分类"></a>二、资源分类</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 静态资源： 不需要经常变化的资源文件：常用的： 图片,css,js,早期html文件</span><br><span class="line"><span class="number">2.</span> 动态资源： 经常需要变化的资源</span><br><span class="line">依据用户的请求方式不同，请求时间不同，产生的数据会发送相应的变化</span><br><span class="line">数据一般来自数据库中的数据</span><br><span class="line"><span class="number">3.</span> 模板资源： 不存储任何用户数据的文件，一个'空文件',也是一个静态资源，但是会结合其他的数据，形成动态资源</span><br><span class="line">        比如说从数据库中查询出的数据，再往模板文件中添加，形成动态资源</span><br><span class="line">        </span><br><span class="line"><span class="number">3.1</span> 替换模板的作用：</span><br><span class="line">   模板网页 + 动态数据 = 动态网页</span><br><span class="line">实现步骤：</span><br><span class="line"><span class="number">1.</span> 访问数据库，获取动态数据</span><br><span class="line"><span class="number">2.</span> 读取模板文件</span><br><span class="line"><span class="number">3.</span> 通过正则表达式，把动态数据替换到模板页面中，形成一个新的动态页面</span><br><span class="line"><span class="number">4.</span> 返回新的动态页面内容(响应体)</span><br></pre></td></tr></table></figure><h3 id="三、路由"><a href="#三、路由" class="headerlink" title="三、路由"></a>三、路由</h3><p>web 开发过程中的路由概念图</p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-df04976fb4a66a83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="web 开发过程中的路由概念.png"></p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 请求路径 --&gt; 对应的执行函数</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 装饰器装饰路由</span><br><span class="line">装饰器工厂  向装饰器传参   @route(xxx)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 通过装饰器实现 mini_frame 中的路由器功能 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备一个装饰器工厂；通过装饰器的方式自动装配路由列表：[("/index.py", index)]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">route</span><span class="params">(url)</span></span>:  <span class="comment"># 装饰器工厂函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">w1</span><span class="params">(func)</span></span>:  <span class="comment"># 装饰器函数</span></span><br><span class="line">        <span class="comment"># url ---&gt; /index.py</span></span><br><span class="line">        <span class="comment"># func --&gt; index  即执行index()(被装饰函数)函数的地址</span></span><br><span class="line">        print(<span class="string">"添加装饰"</span>)</span><br><span class="line">        g_route_list.append((url,func))  <span class="comment"># ("/index.py", index)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">            print(<span class="string">"正在执行拓展功能..."</span>)</span><br><span class="line">            func()</span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line">    <span class="keyword">return</span> w1</span><br><span class="line"></span><br><span class="line">@route(<span class="string">"/index.py"</span>)</span><br><span class="line"><span class="comment"># <span class="doctag">@w</span>1  # 本质上 index = w1(index)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">pass</span><br></pre></td></tr></table></figure><h3 id="四、shell-脚本"><a href="#四、shell-脚本" class="headerlink" title="四、shell 脚本"></a>四、shell 脚本</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. xxx<span class="selector-class">.sh</span>   多个 linux 命令一起执行</span><br><span class="line">    设置执行权限</span><br><span class="line">        $ chmod <span class="number">777</span> xxx.sh</span><br><span class="line">    </span><br><span class="line">    run.sh</span><br><span class="line">        sudo python3 Web<span class="selector-class">.py</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. readme<span class="selector-class">.txt</span>  使用说明文档</span><br><span class="line">    运行步骤：</span><br><span class="line">        终端命令：./run.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;web 开发各个节点关系图；&lt;/li&gt;
&lt;li&gt;资源分类；&lt;/li&gt;
&lt;li&gt;路由；&lt;/li&gt;
&lt;li&gt;shell 脚本。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="Python 高级" scheme="http://jovelin.cn/tags/Python-%E9%AB%98%E7%BA%A7/"/>
    
      <category term="miniweb" scheme="http://jovelin.cn/tags/miniweb/"/>
    
  </entry>
  
  <entry>
    <title>Python 高级提升(三)</title>
    <link href="http://jovelin.cn/2018/07/24/Python%20%E9%AB%98%E7%BA%A7%E6%8F%90%E5%8D%87(%E4%B8%89)/"/>
    <id>http://jovelin.cn/2018/07/24/Python 高级提升(三)/</id>
    <published>2018-07-24T01:00:01.000Z</published>
    <updated>2018-07-28T02:12:24.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>代码编写两大原则；</li><li>闭包；</li><li>装饰器。</li></ol></blockquote><a id="more"></a><h3 id="一-代码编写两大原则"><a href="#一-代码编写两大原则" class="headerlink" title="一. 代码编写两大原则"></a>一. 代码编写两大原则</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>开放封闭原则</span><br><span class="line"><span class="code">    封闭：已实现的功能代码块</span></span><br><span class="line"><span class="code">    开放：对扩展开放</span></span><br><span class="line"><span class="code">    对已经实现的功能代码不允许被修改，但可以被扩展</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="bullet">2. </span>高内聚低耦合原则</span><br><span class="line"><span class="code">    高内聚：针对的是模块内部；</span></span><br><span class="line"><span class="code">    描述的是内部各个元素结合的密切程度，一般一个模块就做一件事情</span></span><br><span class="line"><span class="code">    低耦合：针对的是模块之间；模块之间关联度尽量少一点</span></span><br></pre></td></tr></table></figure><h3 id="二、闭包"><a href="#二、闭包" class="headerlink" title="二、闭包"></a>二、闭包</h3><h4 id="1-函数名"><a href="#1-函数名" class="headerlink" title="1. 函数名"></a>1. 函数名</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>函数名是一个引用函数代码空间的对象，这个对象在被赋值的时候也可以引用其他空间</span><br><span class="line"><span class="bullet">2. </span>可以把函数名当做参数来使用</span><br></pre></td></tr></table></figure><h4 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2. 闭包"></a>2. 闭包</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">闭包好比是一个轻量级的实例对象</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 闭包的结构</span><br><span class="line"><span class="number">1.</span> 外部函数：外部函数返回内部函数的引用</span><br><span class="line"><span class="number">2.</span> 内部函数：内部函数使用了外部函数的参数或者的变量</span><br><span class="line">把这种结构的整体称为闭包</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 闭包与普通函数的区别</span><br><span class="line"><span class="number">1.</span> 普通函数能保存功能，但是不能保存传送给函数的数据(局部变量)</span><br><span class="line"><span class="number">2.</span> 闭包能保存功能，也可以保存数据</span><br><span class="line">   </span><br><span class="line">提示：</span><br><span class="line">    假如内部函数要修改外部函数的变量，则需先声明 </span><br><span class="line">    在 python3 中使用 <span class="keyword">nonlocal</span> 关键字(好比函数使用全局变量，使用 <span class="keyword">global</span> 关键字)</span><br></pre></td></tr></table></figure><h4 id="3-闭包的语法格式"><a href="#3-闭包的语法格式" class="headerlink" title="3. 闭包的语法格式"></a>3. 闭包的语法格式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 闭包的语法格式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="comment"># 处理业务</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"内部函数使用了外部函数的参数：%d"</span> % num)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">f1 = func(<span class="number">100</span>)  <span class="comment"># f1---&gt;inner--&gt;内部函数的定义</span></span><br><span class="line"></span><br><span class="line">f1()</span><br></pre></td></tr></table></figure><h3 id="三、装饰器"><a href="#三、装饰器" class="headerlink" title="三、装饰器"></a>三、装饰器</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 在不改变函数的定义和调用的前提下，给函数扩展功能，这就是装饰器</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 装饰器的语法格式</span><br><span class="line">    <span class="comment"># 装饰器函数 本质就是闭包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">w1</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment"># 验证1</span></span><br><span class="line">        print(<span class="string">"正在验证..."</span>)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@w1  # 本质就是  f1 = w1(f1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span> <span class="comment"># 被装饰的函数</span></span><br><span class="line">    print(<span class="string">"查账"</span>)</span><br><span class="line"></span><br><span class="line">f1()</span><br></pre></td></tr></table></figure><h4 id="2-装饰器装饰不同类型的函数"><a href="#2-装饰器装饰不同类型的函数" class="headerlink" title="2. 装饰器装饰不同类型的函数"></a>2. 装饰器装饰不同类型的函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 装饰器装饰不同类型的函数</span><br><span class="line">a&gt; 装饰器装饰的函数没参数，没返回值</span><br><span class="line">b&gt; 装饰器装饰的函数有参数，没返回值</span><br><span class="line">c&gt; 装饰器装饰的函数没参数，有返回值</span><br><span class="line">d&gt; 装饰器装饰的函数有参数，有返回值</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 万能装饰器，无|有参数(多个)，无|有返回值</span><br><span class="line"><span class="comment"># 装饰器函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">w1</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"正在执行身份验证..."</span>)  <span class="comment"># 拓展功能</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)  <span class="comment"># 执行被装饰函数</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被装饰的函数</span></span><br><span class="line"><span class="meta">@w1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">"被装饰的函数：查账"</span>)</span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"value"</span></span><br></pre></td></tr></table></figure><h4 id="3-多个装饰器装饰一个函数"><a href="#3-多个装饰器装饰一个函数" class="headerlink" title="3. 多个装饰器装饰一个函数"></a>3. 多个装饰器装饰一个函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">""" </span></span><br><span class="line"><span class="string">多个装饰器装饰一个函数的分析：</span></span><br><span class="line"><span class="string">参照对象：被装饰的函数</span></span><br><span class="line"><span class="string">    1. 装饰时，由里到外</span></span><br><span class="line"><span class="string">    2. 执行的，由外到里</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="meta">@sms_veri  # 本质  f1=sms_veri(f1)  func---&gt; f1(被装饰函数的内存空间)</span></span><br><span class="line"><span class="meta">@pwd_veri  # 本质  f1=pwd_veri(f1)  func---&gt; f1(被装饰函数的内存空间)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span>  <span class="comment"># 被装饰的函数</span></span><br><span class="line">    print(<span class="string">"被装饰函数：转账功能"</span>)</span><br><span class="line">f1()</span><br></pre></td></tr></table></figure><h4 id="4-带有额外参数的装饰器函数"><a href="#4-带有额外参数的装饰器函数" class="headerlink" title="4. 带有额外参数的装饰器函数"></a>4. 带有额外参数的装饰器函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">小结：通过装饰器工厂来实现带额外参数的装饰器函数</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(flag)</span>:</span> <span class="comment"># 装饰器的工厂函数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span> <span class="comment"># 装饰器函数</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">                <span class="keyword">if</span> flag==<span class="number">1</span>:</span><br><span class="line">                    print(<span class="string">"正在执行身份验证功能..."</span>)</span><br><span class="line">                func() <span class="comment"># 执行被装饰的函数</span></span><br><span class="line">            <span class="keyword">return</span> inner</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @outer(1)  # outer(0)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"被装饰函数：转账功能"</span>)</span><br><span class="line">    </span><br><span class="line">    f1()</span><br></pre></td></tr></table></figure><h4 id="5-类装饰器"><a href="#5-类装饰器" class="headerlink" title="5. 类装饰器"></a>5. 类装饰器</h4><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 以定义类的方式实现装饰器</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类装饰器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="title">object</span>):</span></span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, func)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">self</span>.func = func</span><br><span class="line">            print(<span class="string">"添加身份验证的装饰功能"</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(<span class="keyword">self</span>, *args, **kwargs)</span></span><span class="symbol">:</span></span><br><span class="line">            print(<span class="string">"正在身份验证..."</span>)</span><br><span class="line">            <span class="keyword">self</span>.func()         </span><br><span class="line">    </span><br><span class="line">    @Person  <span class="comment"># check = Person(check) </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">()</span></span>:  <span class="comment"># 被装饰的函数</span></span><br><span class="line">        print(<span class="string">"我是被装饰的函数...支付功能..."</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 目前的 check 起始就是 Person 类的实例对象</span></span><br><span class="line">    <span class="comment"># 实例对象()：表示该对象是可调用的，所有需要对创建该对象的类添加 __call__ 魔法方法</span></span><br><span class="line">    pay()</span><br></pre></td></tr></table></figure><h3 id="四、装饰器总结"><a href="#四、装饰器总结" class="headerlink" title="四、装饰器总结"></a>四、装饰器总结</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>装饰器函数只有一个参数就是被装饰的函数的引用</span><br><span class="line"><span class="bullet">2. </span>装饰器能够将一个函数的功能在不修改代码和调用的情况下进行扩展</span><br><span class="line"><span class="bullet">3. </span>在函数定义的上方 @装饰器函数名，即可直接使用装饰器对下面的函数进行装饰</span><br><span class="line"><span class="bullet">4. </span>装饰器的使用场景</span><br><span class="line"><span class="code">引入日志</span></span><br><span class="line"><span class="code">函数执行时间统计</span></span><br><span class="line"><span class="code">执行函数前预备处理</span></span><br><span class="line"><span class="code">执行函数后清理功能</span></span><br><span class="line"><span class="code">权限校验等场景</span></span><br><span class="line"><span class="code">缓存</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码编写两大原则；&lt;/li&gt;
&lt;li&gt;闭包；&lt;/li&gt;
&lt;li&gt;装饰器。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="Python 高级" scheme="http://jovelin.cn/tags/Python-%E9%AB%98%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python 高级提升(二)</title>
    <link href="http://jovelin.cn/2018/07/22/Python%20%E9%AB%98%E7%BA%A7%E6%8F%90%E5%8D%87(%E4%BA%8C)/"/>
    <id>http://jovelin.cn/2018/07/22/Python 高级提升(二)/</id>
    <published>2018-07-22T01:00:01.000Z</published>
    <updated>2018-07-28T02:12:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>可变参数的装包与拆包；</li><li>属性和方法；</li><li>魔法属性、方法；</li><li>property 属性；</li><li>with 与 上下文管理。</li></ol></blockquote><a id="more"></a><h3 id="一、可变参数的装包与拆包"><a href="#一、可变参数的装包与拆包" class="headerlink" title="一、可变参数的装包与拆包"></a>一、可变参数的装包与拆包</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 装包，针对的是形参中的 *<span class="keyword">args</span>、**kwargs</span><br><span class="line">    通过<span class="string">'*'</span>告诉 <span class="keyword">python</span> 解析器 把调用者传递过来的没有变量接收的未命名参数，装在 <span class="keyword">args</span> 这个元组中</span><br><span class="line">    通过<span class="string">'**'</span>告诉 <span class="keyword">python</span> 解析器 把调用者传递过来的命名参数，装在kwargs这个字典中</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>. 拆包，针对的是函数体中的 *<span class="keyword">args</span>、**kwargs</span><br><span class="line">    函数体里的 <span class="keyword">args</span> 依然是那个元组，但是 *<span class="keyword">args</span> 的含义就是把元组中的数据进行拆包，也就是把元组中的数据拆成单个数据</span><br><span class="line">    kwargs 同理可知</span><br></pre></td></tr></table></figure><h3 id="二、属性和方法"><a href="#二、属性和方法" class="headerlink" title="二、属性和方法"></a>二、属性和方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 类属性与实例属性</span><br><span class="line">    <span class="number">1.</span> 类属性存放在类对象的内存中，在内存中只保存一份</span><br><span class="line">    <span class="number">2.</span> 实例属性存放在实例对象的内存中，在每个实例对象中都单独保存一份</span><br><span class="line">    <span class="number">3.</span> 如果每个实例对象需要具有相同值的属性，那么就定义类属性</span><br><span class="line">  </span><br><span class="line"><span class="number">2.</span> 静态方法，类方法，实例方法</span><br><span class="line">    <span class="number">1.</span> 方法定义： </span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">static_fun</span><span class="params">()</span>:</span></span><br><span class="line"><span class="string">"""静态方法"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">class_fun</span><span class="params">(cls)</span>:</span>  </span><br><span class="line"><span class="string">"""类方法"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_fun</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""实例方法"""</span></span><br><span class="line"></span><br><span class="line">    <span class="number">2.</span> 对比</span><br><span class="line">    相同点：对于所有的方法而言，均属于类，所以在内存中也只保存一份</span><br><span class="line">不同点：方法调用者不同、调用方法时自动传入的参数不同。</span><br></pre></td></tr></table></figure><h3 id="三、魔法属性、方法"><a href="#三、魔法属性、方法" class="headerlink" title="三、魔法属性、方法"></a>三、魔法属性、方法</h3><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">魔法属性和魔法方法是 Python 内置的一些属性和方法，代表着特殊意义，</span><br><span class="line">命名时会在前后加两个下划线，在执行特定操作时，系统会自动调用它</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="variable">__doc__</span></span><br><span class="line"><span class="variable">__doc__</span>：表示类的描述信息</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. <span class="variable">__module__</span>,<span class="variable">__class__</span></span><br><span class="line">    <span class="variable">__module__</span>：表示当前操作的对象或者类在哪个模块</span><br><span class="line">    <span class="variable">__class__</span>：表示当前操作的对象的类是什么</span><br><span class="line">   </span><br><span class="line"><span class="number">3</span>. <span class="variable">__dict__</span>,<span class="variable">__str__</span></span><br><span class="line">    <span class="variable">__dict__</span>：显示类或对象中的所有属性</span><br><span class="line">    <span class="variable">__str__</span>：如果类中重写了 <span class="variable">__str__</span> 方法，那么在打印对象时，输出该方法的返回值</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. <span class="variable">__init__</span>,<span class="variable">__del__</span></span><br><span class="line">    <span class="variable">__init__</span>：当类初始化对象时，自动执行该方法</span><br><span class="line">    <span class="variable">__del__</span>：当对象在内存中被销毁时，自动执行该方法</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>. <span class="variable">__call__</span>  </span><br><span class="line">    <span class="variable">__call__</span>：对象后面加 ()，会自动执行该魔法方法</span><br><span class="line">    提示：必须在创建对象的类中添加 <span class="variable">__call__</span>() 方法，表示类的实例对象是能被 callable 调用的</span><br></pre></td></tr></table></figure><h3 id="四、property-属性"><a href="#四、property-属性" class="headerlink" title="四、property 属性"></a>四、property 属性</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="keyword">property</span><span class="title"> </span>属性初体验</span><br><span class="line">    一种用起来像是使用的实例属性一样的特殊属性，可以对应于某个方法，<span class="keyword">property</span><span class="title"> </span>属性本质还是方法</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">property</span><span class="title"> </span>属性的定义和调用注意点：</span><br><span class="line">    <span class="number">1</span>. 定义时，在实例方法的基础上添加 @<span class="keyword">property</span><span class="title"> </span>装饰器；并且方法仅有一个 self 参数</span><br><span class="line">    <span class="number">2</span>. 调用时，无需括号</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. <span class="keyword">property</span><span class="title"> </span>属性的好处</span><br><span class="line">将一个属性的操作方法封装为一个属性，用户用起来就和操作普通属性完全一致,非常简单</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 通过装饰器的方式定义 <span class="keyword">property</span><span class="title"> </span>属性</span><br><span class="line">    <span class="number">1</span>. 使用装饰器方式定义 <span class="keyword">property</span><span class="title"> </span>属性</span><br><span class="line">    - @<span class="keyword">property</span><span class="title"></span></span><br><span class="line">        取得属性值，修饰的方法有且仅有一个 self 参数</span><br><span class="line">    - @方法名.setter</span><br><span class="line">        设置属性值，修饰的方法，只能传一个参数</span><br><span class="line">    - @方法名.deleter</span><br><span class="line">        删除属性，修饰的方法有且仅有一个 self 参数</span><br><span class="line">    </span><br><span class="line">    <span class="number">2</span>. 访问 <span class="keyword">property</span><span class="title"> </span>属性的三种方式</span><br><span class="line">    temp = obj.price  <span class="comment"># 获取 property 属性</span></span><br><span class="line">    obj.price = new_price  <span class="comment"># 修改 property 属性</span></span><br><span class="line">    del obj.price  <span class="comment"># 删除 property 属性(很少使用)</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. 通过类属性方式定义 <span class="keyword">property</span><span class="title"> </span>属性</span><br><span class="line">price = <span class="keyword">property</span><span class="title"></span>(get_price, set_price, del_price, <span class="string">"描述信息"</span>)</span><br><span class="line">     第一个参数是方法名: 获取属性值</span><br><span class="line">     第二个参数是方法名: 设置属性值</span><br><span class="line">     第三个参数是方法名: 删除属性</span><br><span class="line">     第四个参数是字符串: 该属性的描述信息，通过类名.属性名.__doc__调用</span><br><span class="line">     </span><br><span class="line">    obj.price  <span class="comment"># 获取 property 属性值</span></span><br><span class="line">    obj.price = new_price  <span class="comment"># 设置 property 属性值</span></span><br><span class="line">    obj.del_price()  <span class="comment"># 删除 property 属性(很少使用)</span></span><br><span class="line">    Obj.price.__doc__调用  <span class="comment"># 通过类名.属性名.__doc__调用</span></span><br></pre></td></tr></table></figure><h3 id="五、with-与-上下文管理"><a href="#五、with-与-上下文管理" class="headerlink" title="五、with 与 上下文管理"></a>五、with 与 上下文管理</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">with</span> 使用：</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"/home/python/Desktop/hello.txt"</span>, <span class="string">'w'</span>) <span class="keyword">as</span> <span class="built_in">file</span>:</span><br><span class="line">        <span class="built_in">file</span>.<span class="built_in">write</span>(<span class="string">'hello with'</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 上下文管理器        </span><br><span class="line">    上下文：context，也称为上下文环境，好比教室环境</span><br><span class="line">       上文</span><br><span class="line">       正文：讲课，主业务</span><br><span class="line">       下文</span><br><span class="line"></span><br><span class="line">上下文管理：</span><br><span class="line">任何实现了 __enter__() 和 __exit__() 方法的对象</span><br><span class="line">都可称之为上下文管理器，上下文管理器可以使用 <span class="keyword">with</span> 简化操作</span><br><span class="line">    __enter__()：初始化资源对象，且返回资源对象</span><br><span class="line">    __exit__()：业务执行完后，在该方法做善后、清理方面的工作</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 装饰器的方式</span><br><span class="line">import contextlib</span><br><span class="line"></span><br><span class="line">@contextlib.contextmanager</span><br><span class="line">def my_open(path, mode):</span><br><span class="line">f = <span class="built_in">open</span>(path, mode)</span><br><span class="line">yield f</span><br><span class="line">f.<span class="built_in">close</span>()</span><br><span class="line"></span><br><span class="line">小结： <span class="keyword">with</span> 语法用于简化资源操作的后续清除操作，是 <span class="keyword">try</span>/<span class="keyword">finally</span> 的替代方法，实现原理建立在上下文管理器之上</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可变参数的装包与拆包；&lt;/li&gt;
&lt;li&gt;属性和方法；&lt;/li&gt;
&lt;li&gt;魔法属性、方法；&lt;/li&gt;
&lt;li&gt;property 属性；&lt;/li&gt;
&lt;li&gt;with 与 上下文管理。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="Python 高级" scheme="http://jovelin.cn/tags/Python-%E9%AB%98%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python 高级提升(一)</title>
    <link href="http://jovelin.cn/2018/07/21/Python%20%E9%AB%98%E7%BA%A7%E6%8F%90%E5%8D%87(%E4%B8%80)/"/>
    <id>http://jovelin.cn/2018/07/21/Python 高级提升(一)/</id>
    <published>2018-07-21T01:00:01.000Z</published>
    <updated>2018-07-28T02:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>GIL (全局解释器锁)；</li><li>赋值、浅拷贝、深拷贝；</li><li>import 导入模块；</li><li>多继承以及 MRO 顺序。</li></ol></blockquote><a id="more"></a><h3 id="一、GIL-全局解释器锁"><a href="#一、GIL-全局解释器锁" class="headerlink" title="一、GIL (全局解释器锁)"></a>一、GIL (全局解释器锁)</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 单线程、多线程、多进程执行分析</span><br><span class="line">   双核 cpu</span><br><span class="line">     - 单线程： 一个 cpu <span class="number">100</span>% 使用，另一个空闲</span><br><span class="line">     - 两个线程： 两个 cpu 各自使用 <span class="number">50</span>%</span><br><span class="line">     - 两个进程： 两个 cpu 各自使用 <span class="number">100</span>%</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> GIL 概念：</span><br><span class="line">GIL，全局解释器锁(global interpreter lock)，它不是 python 语言的特性，而是 python 默认的解析器 cpython 的特性</span><br><span class="line">cpython 要求每个线程必须先获取 GIL 锁，才能执行线程中的代码</span><br><span class="line"></span><br><span class="line">目的：解决多线程同时竞争解析器程序的全局变量而出现的线程安全问题</span><br><span class="line">不足：在多线程中不能充分利用多核 cpu</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 如何解决 GIL 问题：</span><br><span class="line"><span class="number">1.</span> 换解析器 ，把 cpython 换成其他的，比如 jpython</span><br><span class="line"><span class="number">2.</span> 针对多线程执行的业务，用其他语言代码，比如 c++，java 来代替，python 就是胶水语言</span><br><span class="line"><span class="number">3.</span> 多进程+多协程方案</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 面试题：</span><br><span class="line">描述 Python GIL 的概念，以及它对 python 多线程的影响？一个单线程抓取网页的程序，与一个多线程抓取网页的程序哪个性能更高，并解释原因。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> GIL，全局解释器锁(global interpreter lock)，它是 cpython 解析器的特性，不是 python 的特性 ，它要求线程在执行前，需要获取GIL锁，</span><br><span class="line"><span class="number">2.</span> 由于 GIL 的存在，会影响多线程不能利用多核 CPU 资源，通过多进程方式可利用多个 CPU 资源</span><br><span class="line"><span class="number">3.</span> 线程释放 GIL 锁的情况：</span><br><span class="line">在 IO 操作等可能会引起阻塞的 system call 之前，可以暂时释放 GIL，但在执行完毕后，必须重新获取 GIL</span><br><span class="line">Python <span class="number">3.</span>x 使用计时器（执行时间达到阈值后，当前线程释放 GIL）</span><br><span class="line"><span class="number">4.</span> 多线程爬取比单线程性能有提升，因为遇到 IO 阻塞会自动释放 GIL 锁，这样在线程阻塞情况下，可以执行其他线程中的代码</span><br></pre></td></tr></table></figure><h3 id="二、赋值、浅拷贝、深拷贝"><a href="#二、赋值、浅拷贝、深拷贝" class="headerlink" title="二、赋值、浅拷贝、深拷贝"></a>二、赋值、浅拷贝、深拷贝</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">赋值是对多个对象指向同一个内存空间，多个对象共同操作同一个数据</span><br><span class="line">深拷贝与浅拷贝是对内存数据的复制，目的是能够单独操作数据</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 赋值</span><br><span class="line">对象之间赋值本质上是对象之间内存地址的引用传递</span><br><span class="line">也就是多个对象指向同一个内存空间</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 浅拷贝</span><br><span class="line"><span class="number">1</span>. 引入 <span class="keyword">copy</span><span class="bash"> 模块</span></span><br><span class="line"><span class="bash">2. copy.copy(object)</span></span><br><span class="line"><span class="bash">    object: 要拷贝的对象</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">小结：浅拷贝是对象的第一层(顶层)的拷贝</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">3. 深拷贝</span></span><br><span class="line"><span class="bash">深拷贝</span></span><br><span class="line"><span class="bash">1. 引入 copy 模块</span></span><br><span class="line"><span class="bash">2. copy.deepcopy(object)</span></span><br><span class="line"><span class="bash">    object: 要拷贝的对象</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">小结：深拷贝是对象的所有层的拷贝</span></span><br><span class="line"><span class="bash">  </span></span><br><span class="line"><span class="bash">4. 不可变类型(元组,数字,字符串)的拷贝</span></span><br><span class="line"><span class="bash">    1&gt; 如果在多层嵌套中都是不可变类型</span></span><br><span class="line"><span class="bash">     浅拷贝与深拷贝都是相同的，都不会单独开辟内存空间，而是引用原来的内存空间</span></span><br><span class="line"><span class="bash"> 2&gt; 如果顶层是不可变类型，但内部元素有嵌入可变类型</span></span><br><span class="line"><span class="bash">     浅拷贝还是不会开辟新的内存空间，而是引用原来的内存空间</span></span><br><span class="line"><span class="bash">     深拷贝会拷贝对象的所有层</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">5. 其他拷贝方式(列表切片、字典中的 copy)</span></span><br><span class="line"><span class="bash">    列表切片、字典中的 copy 都使用浅拷贝</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">面试题：</span></span><br><span class="line"><span class="bash">    如何在内存中复制一个数据</span></span><br><span class="line"><span class="bash">        浅拷贝，深拷贝 copy 模块</span></span><br><span class="line"><span class="bash">    切片操作与字典中的拷贝属于哪种拷贝:</span></span><br><span class="line"><span class="bash">        浅拷贝</span></span><br></pre></td></tr></table></figure><h4 id="三、import-导入模块"><a href="#三、import-导入模块" class="headerlink" title="三、import 导入模块"></a>三、import 导入模块</h4><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">import</span> 搜索路径</span><br><span class="line">a&gt; 查看搜索路径</span><br><span class="line">sys.path # 系统预设的搜索路径</span><br><span class="line"></span><br><span class="line">b&gt; 设置搜索路径</span><br><span class="line">    sys.path.append(<span class="string">"/python/a"</span>)</span><br><span class="line">    sys.path.insert(<span class="number">0</span>,<span class="string">"/python/b"</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 重新导入模块</span><br><span class="line">热更新： 服务没有停止，再更新模块</span><br><span class="line"><span class="keyword">import</span> imp</span><br><span class="line"> imp.reload(load_test)</span><br><span class="line">   load_test:模块名</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 多模块开发时引用其它模块共享变量的问题 </span><br><span class="line">  <span class="number">1.</span> <span class="keyword">import</span> <span class="keyword">module</span> 方式  </span><br><span class="line">  本地不会创建新变量，操作的是目标模块的变量</span><br><span class="line"> <span class="number">2.</span> <span class="keyword">from</span> <span class="keyword">module</span> <span class="keyword">import</span> * 方式</span><br><span class="line"> 在本地创建一个与目标模块相同的变量名，并且与目标模块变量指向同一个内存空间</span><br><span class="line"></span><br><span class="line">面试题: <span class="keyword">import</span> <span class="keyword">module</span> 与 <span class="keyword">from</span> <span class="keyword">module</span> <span class="keyword">import</span> * 两种模块导入有何区别</span><br><span class="line"></span><br><span class="line"> <span class="number">1.</span> <span class="keyword">import</span> <span class="keyword">module</span> 引用共享变量时，要使用 <span class="keyword">module</span>.变量名，而 <span class="keyword">from</span> <span class="keyword">module</span> <span class="keyword">import</span> * 直接使用变量名即可</span><br><span class="line"> <span class="number">2.</span> <span class="keyword">import</span> <span class="keyword">module</span> 方式  </span><br><span class="line"> 本地不会创建新变量，操作的是目标模块的变量</span><br><span class="line">  <span class="number">3.</span> <span class="keyword">from</span> <span class="keyword">module</span> <span class="keyword">import</span> * 方式</span><br><span class="line">在本地创建一个与目标模块相同的变量名，并且与目标模块变量指向同一个内存空间</span><br></pre></td></tr></table></figure><h3 id="四、多继承以及-MRO-顺序"><a href="#四、多继承以及-MRO-顺序" class="headerlink" title="四、多继承以及 MRO 顺序"></a>四、多继承以及 MRO 顺序</h3><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 单继承</span><br><span class="line">子类调用父类的方法的方式：</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>. super().__init__()</span><br><span class="line">  <span class="number">2</span>. Parent.__init__(<span class="keyword">self</span>)</span><br><span class="line">  <span class="number">3</span>. super(类名,<span class="keyword">self</span>).__init__()</span><br><span class="line"></span><br><span class="line"> 单继承中，使用父类名与super调用父类的方法没有差异，是一样的</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 多继承中使用父类名调用父类的方法</span><br><span class="line">出现问题： 父类的方法会调用多次</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 多继承中使用 super() 调用父类的方法</span><br><span class="line">在多继承中，建议使用 super() 来调用父类的方法，而不用父类名的方式</span><br><span class="line"></span><br><span class="line">- mro顺序： <span class="function"><span class="keyword">Method</span> <span class="title">Resolution</span> <span class="title">Order</span> :</span></span><br><span class="line">    方法解决顺序，方法解析顺序</span><br><span class="line">    用于描述在Python多继承中子类调用多个父类相同方法的顺序 </span><br><span class="line">内部通过C3算法去解析</span><br><span class="line">- 类名.__mro__ : 用元组的形式存放子类调用多个父类相同方法的顺序（mro算法执行的结果）</span><br><span class="line"></span><br><span class="line">- super()与类名.__mro__的关系：</span><br><span class="line"># (&lt;<span class="keyword">class</span> <span class="string">'__main__.Grandson'</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">'__main__.Son1'</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">'__main__.Son2'</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">'__main__.Parent'</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">'object'</span>&gt;)</span><br><span class="line"></span><br><span class="line"> super(类名，<span class="keyword">self</span>)就是依照这个顺序确定要调用的是哪个父类的方法</span><br><span class="line">    通过<span class="keyword">self</span>确定mro顺序</span><br><span class="line">    通过类名找到当前类在mro中的位置，再返回下一个类作为super调用的父类</span><br><span class="line"></span><br><span class="line">小结： </span><br><span class="line">   <span class="number">1</span>. 单继承中，super().__init__相对于类名.__init__，基本无差别</span><br><span class="line">   <span class="number">2</span>. 多继承中，super() 能保证每个父类的方法只会执行一次，而使用类名的方法会导致方法被执行多次</span><br><span class="line">      多继承中建议使用super()</span><br><span class="line">   <span class="number">2</span>. super() 内部是通过 mro 算法来确定调用哪个父类的方法</span><br></pre></td></tr></table></figure><h3 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. vim -On one<span class="selector-class">.py</span>  two<span class="selector-class">.py</span> </span><br><span class="line">在vim中分屏显示多个文件</span><br><span class="line"><span class="number">2</span>.Htop命令： </span><br><span class="line">显示的内容比<span class="attribute">top</span>命令更加丰富，用于监视进程的资源占用率的情况</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GIL (全局解释器锁)；&lt;/li&gt;
&lt;li&gt;赋值、浅拷贝、深拷贝；&lt;/li&gt;
&lt;li&gt;import 导入模块；&lt;/li&gt;
&lt;li&gt;多继承以及 MRO 顺序。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="Python 高级" scheme="http://jovelin.cn/tags/Python-%E9%AB%98%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 高级提升(四)</title>
    <link href="http://jovelin.cn/2018/07/18/MySQL%20%E9%AB%98%E7%BA%A7%E6%8F%90%E5%8D%87(%E5%9B%9B)/"/>
    <id>http://jovelin.cn/2018/07/18/MySQL 高级提升(四)/</id>
    <published>2018-07-17T20:00:01.000Z</published>
    <updated>2018-07-28T01:50:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>视图的作用、特点以及使用；</li><li>事务的 ACID 特性以及使用；</li><li>面试题：对索引的认识以及使用；</li><li>数据库的设计：E-R 模型、三范式。</li></ol></blockquote><a id="more"></a><h3 id="一、视图"><a href="#一、视图" class="headerlink" title="一、视图"></a>一、视图</h3><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">1. 掌握视图的作用、特点以及如何使用</span><br><span class="line"></span><br><span class="line">特点： </span><br><span class="line">    视图是对若干张基本表的引用，一张虚表，查询语句执行的结果</span><br><span class="line">    不存储具体的数据（基本表数据发生了改变，视图也会跟着改变） </span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">    1. <span class="keyword">create</span> <span class="keyword">view</span> 视图名称 <span class="keyword">as</span> <span class="keyword">select</span> ...</span><br><span class="line">    <span class="number">2.</span> <span class="keyword">select</span> * <span class="keyword">from</span> 视图</span><br><span class="line">    <span class="number">3.</span> <span class="keyword">drop</span> <span class="keyword">view</span> 视图名称</span><br><span class="line">    </span><br><span class="line">作用：视图的优缺点（面试：谈一谈对视图的认识）</span><br><span class="line"></span><br><span class="line">a&gt;优点:</span><br><span class="line"><span class="number">1.</span> 简化查询操作</span><br><span class="line">对于复杂的查询，往往是有多个数据表进行关联查询而得到,对于这个复杂的查询结果保存为一个视图，便于下一次查询时简化查询操作</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 逻辑上的独立性，屏蔽了真实表结构更改带来的影响</span><br><span class="line">视图可以使应用程序和数据库表在一定程度上独立。如果没有视图，应用一定是建立在表上的。有了视图之后，程序可以建立在视图之上，从而程序与数据库表被视图分割开来。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 视图能够对机密数据提供一定安全保护</span><br><span class="line">因为视图是虚拟的，物理上是不存在的，只是存储了数据的集合，我们可以将基表中重要的字段信息，可以不通过视图给用户</span><br><span class="line"></span><br><span class="line">b&gt; 不足：</span><br><span class="line">    <span class="number">1.</span> 性能差</span><br><span class="line">对视图(<span class="keyword">select</span>)的查询最终转换为对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，也会花费一定时间</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 额外增加数据库的复杂度</span><br></pre></td></tr></table></figure><h3 id="二、事务"><a href="#二、事务" class="headerlink" title="二、事务"></a>二、事务</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">在Python中，打开一个连接，默认会开启事务，针对增删改，需要事务的提交 conn.commit()</span><br><span class="line"></span><br><span class="line">遇到的问题？</span><br><span class="line">银行转账分为2部分</span><br><span class="line">1. A账号转出1000元</span><br><span class="line">2. B账号转入1000元</span><br><span class="line">两部分操作是不可分割的，要么一起成功，要么一起失败</span><br><span class="line">解决方案： 使用事务</span><br><span class="line"></span><br><span class="line">1. 事务是什么</span><br><span class="line"></span><br><span class="line">所谓事务,它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的执行单位</span><br><span class="line"></span><br><span class="line">2. 事务的ACID特性 (面试题：事务的ACID是什么)</span><br><span class="line">   </span><br><span class="line"><span class="meta">a&gt;</span><span class="bash"> 原子性(Atomic)： 语句不可分割，要么同时执行，要么同时不执行</span></span><br><span class="line"><span class="meta">b&gt;</span><span class="bash"> 一致性(Consistency): 数据库总是从一个一致性的状态转换到另一个一致性的状态</span></span><br><span class="line"><span class="meta">c&gt;</span><span class="bash"> 隔离性(Isolation)：通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的</span></span><br><span class="line"><span class="meta">d&gt;</span><span class="bash"> 持久性(Durability)</span></span><br><span class="line">    一旦事务提交，则其所做的修改会永久保存到数据库</span><br><span class="line">   </span><br><span class="line">3. mysql事务的使用</span><br><span class="line"></span><br><span class="line">1. 开启事务命令</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启事务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> start transaction;</span></span><br><span class="line">begin;  </span><br><span class="line">2. 提交事务命令</span><br><span class="line">    commit；</span><br><span class="line">3. 事务回滚命令</span><br><span class="line">rollback;</span><br><span class="line"></span><br><span class="line">4. 事务的提示：</span><br><span class="line"></span><br><span class="line">1. innodb引擎支持事务(默认的引擎)，MyISAM不支持事务</span><br><span class="line">2. 使用终端操作数据库(也就是mysql的客户端)的时候 也是默认开始事物的，只是在回车确认操作的时候 终端会默认执行commit 所以我们不需要手动commit。但假如手动调用begin时，就需要手动调用commit提交事务</span><br><span class="line">3. 使用python操作数据库的时候 默认开启事务的 </span><br><span class="line">4. 但是python对数据库进行增删改的时候 需要手动commit</span><br></pre></td></tr></table></figure><h3 id="三、索引"><a href="#三、索引" class="headerlink" title="三、索引"></a>三、索引</h3><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">遇到问题1：</span><br><span class="line">    如何快速查字典的单词，快速找一本书中的某章节的具体内容？</span><br><span class="line">遇到问题2：</span><br><span class="line">    当数据库中数据量很大时，查找数据会变得很慢，如何优化查询？</span><br><span class="line">解决方案：使用索引</span><br><span class="line"></span><br><span class="line">1. 什么是索引</span><br><span class="line">索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</span><br><span class="line">索引就好比是一本书前面的目录，能加快数据库的查询速度</span><br><span class="line"></span><br><span class="line">2. 索引原理(了解)</span><br><span class="line">    思想： 不断缩小查找范围</span><br><span class="line">    内部具体实现方案： B+Tree实现</span><br><span class="line">        数据分析： 数据结构</span><br><span class="line">        线性表，二叉树，三叉数， 队列， 栈 </span><br><span class="line"></span><br><span class="line">3. 索引的使用</span><br><span class="line">a&gt; 查看索引</span><br><span class="line">show <span class="keyword">index</span> <span class="keyword">from</span> 表名;</span><br><span class="line">show <span class="keyword">index</span> <span class="keyword">from</span> goods;</span><br><span class="line"></span><br><span class="line">b&gt; 创建索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> 索引名称 <span class="keyword">on</span> 表名(字段名称(长度))</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> name_index <span class="keyword">on</span> goods(name(<span class="number">150</span>));</span><br><span class="line"></span><br><span class="line">c&gt; 删除索引</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> 索引名称 <span class="keyword">on</span> 表名;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> name_index <span class="keyword">on</span> goods;</span><br><span class="line"></span><br><span class="line">4. 索引优化查询测试</span><br><span class="line">1. 创建表 t_news(新闻)表</span><br><span class="line">   <span class="keyword">create</span> table t_news(<span class="built_in">title</span> varchar(<span class="number">10</span>));</span><br><span class="line">2. 通过python程序向t_news表添加10万条记录</span><br><span class="line"><span class="number">3.</span> 测试有无索引的查询效率</span><br><span class="line"><span class="keyword">set</span> profiling=<span class="number">1</span>; # 开启时间检测</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_news <span class="keyword">where</span> <span class="built_in">title</span>=<span class="string">'ha-80000'</span>; # 建立索引之前执行查询</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> title_index <span class="keyword">on</span> t_news(<span class="built_in">title</span>(<span class="number">10</span>)); # 创建索引之后执行查询</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_news <span class="keyword">where</span> <span class="built_in">title</span>=<span class="string">'ha-80000'</span>; </span><br><span class="line">show profiles; # 显示执行简表</span><br><span class="line"></span><br><span class="line">5. 索引注意点(面试题:谈谈你对索引的认识):</span><br><span class="line">    1. 索引最主要解决的问题:当数据量较大时,且这些数据不需要经常修改,使用索引来加快查询速度</span><br><span class="line">2. 对于比较小的表，查询开销不会很大，也没有必要建立另外的索引</span><br><span class="line">3. 建立太多的索引将会影响更新和插入的速度，因为它需要同样更新每个索引文件</span><br><span class="line">4. 对于一个经常需要更新和插入的表格，就没有必要为一个很少使用的where字句单独建立索引了 </span><br><span class="line">5. 建立索引会占用磁盘空间</span><br></pre></td></tr></table></figure><h3 id="四、数据库的设计"><a href="#四、数据库的设计" class="headerlink" title="四、数据库的设计"></a>四、数据库的设计</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">E-R模型：实体关系模型</span><br><span class="line">    1. 一对一</span><br><span class="line">    2. 一对多</span><br><span class="line">    3. 多对一</span><br><span class="line">    4. 多对多</span><br><span class="line">    </span><br><span class="line">三范式</span><br><span class="line">    1NF： 列不能再分割</span><br><span class="line">    2NF： 基于1NF，有主键，非主键要依赖主键</span><br><span class="line">    3NF ：基于2NF，不能传递依赖主键</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. E-R模型(Entity-Relationship Model)</span><br><span class="line"></span><br><span class="line">关系型数据库是建立在实体关系模型(E-R模型)基础之上,再开展数据库的分析与设计</span><br><span class="line">        基于面向对象思想的分析与设计</span><br><span class="line">        </span><br><span class="line">        面向对象的分析与设计：</span><br><span class="line">            1. 同学  2. 老师  3. 班级  4. 教室</span><br><span class="line">            实体-关系模型 </span><br><span class="line"></span><br><span class="line">在项目开发中，一般会先设计好数据库，数据库开发一般是项目开发的第一步</span><br><span class="line"><span class="meta">a&gt;</span><span class="bash"> 实体(Entry)</span></span><br><span class="line">实体设计就好比定义一个类一样，指定从哪些方面来描述对象，一个实体可以转换为数据库中的一个表</span><br><span class="line"></span><br><span class="line"><span class="meta">b&gt;</span><span class="bash"> 关系(Relationship)</span></span><br><span class="line">描述两个实体之间的对应规则</span><br><span class="line">1. 一对一：</span><br><span class="line">一个萝卜一个坑</span><br><span class="line">学生与指纹</span><br><span class="line">员工和工资卡</span><br><span class="line"></span><br><span class="line">2. 一对多</span><br><span class="line">班级与学生</span><br><span class="line">客户与订单</span><br><span class="line">部门与员工</span><br><span class="line"></span><br><span class="line">3. 多对一</span><br><span class="line">学生与班级</span><br><span class="line">员工与部门</span><br><span class="line"></span><br><span class="line">4. 多对多关系</span><br><span class="line">  学生与社团</span><br><span class="line">  运动员与比赛项目</span><br><span class="line"></span><br><span class="line">2. 三范式:</span><br><span class="line"></span><br><span class="line">为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式</span><br><span class="line">数据库的范式越高，则数据冗余越少，但是会导致查询效率降低，一般数据库设计满足第三范式，就很好了</span><br><span class="line"></span><br><span class="line"><span class="meta">a&gt;</span><span class="bash"> 第一范式 1NF </span></span><br><span class="line">强调的是列的原子性，即列不能够再分成其他几列 </span><br><span class="line"></span><br><span class="line"><span class="meta">b&gt;</span><span class="bash"> 第二范式</span></span><br><span class="line">首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键</span><br><span class="line">   依据主键能够推导出其他字段的信息</span><br><span class="line"></span><br><span class="line"><span class="meta">c&gt;</span><span class="bash"> 第三范式</span></span><br><span class="line">首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;视图的作用、特点以及使用；&lt;/li&gt;
&lt;li&gt;事务的 ACID 特性以及使用；&lt;/li&gt;
&lt;li&gt;面试题：对索引的认识以及使用；&lt;/li&gt;
&lt;li&gt;数据库的设计：E-R 模型、三范式。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/categories/Python/MySQL/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 与 Python 交互(五)</title>
    <link href="http://jovelin.cn/2018/07/18/MySQL%20%E4%B8%8E%20Python%20%E4%BA%A4%E4%BA%92(%E4%BA%94)/"/>
    <id>http://jovelin.cn/2018/07/18/MySQL 与 Python 交互(五)/</id>
    <published>2018-07-17T20:00:01.000Z</published>
    <updated>2018-07-28T01:52:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>Python 与 MySQL 的交互流程；</li><li>Connection 连接对象；</li><li>Cursor 对象；</li><li>sql 语句的参数化。</li></ol></blockquote><a id="more"></a><h3 id="一、Python-操作-MySQL-步骤-重点"><a href="#一、Python-操作-MySQL-步骤-重点" class="headerlink" title="一、Python 操作 MySQL 步骤(重点)"></a>一、Python 操作 MySQL 步骤(重点)</h3><h4 id="1-Python-与-MySQL-的交互"><a href="#1-Python-与-MySQL-的交互" class="headerlink" title="1. Python 与 MySQL 的交互"></a>1. Python 与 MySQL 的交互</h4><p><img src="https://upload-images.jianshu.io/upload_images/3365001-a63383fefa17d1f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Python与Mysql的交互.png"></p><h4 id="2-Python-访问数据库流程"><a href="#2-Python-访问数据库流程" class="headerlink" title="2. Python 访问数据库流程"></a>2. Python 访问数据库流程</h4><blockquote><p>提示：引入pymysql模块，通过该模块的api来访问mysql数据库(查看源码)</p></blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>创建一个Connection连接对象</span><br><span class="line"><span class="bullet">2. </span>通过Connection连接对象取得游标Cursor对象</span><br><span class="line"><span class="bullet">3. </span>通过游标执行Sql语句</span><br><span class="line"><span class="bullet">4. </span>通过游标获取执行结果</span><br><span class="line"><span class="bullet">5. </span>依据业务处理执行结果</span><br><span class="line"><span class="bullet">6. </span>关闭游标</span><br><span class="line"><span class="bullet">7. </span>关闭连接</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/3365001-8b8f1ca7bcda9100.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用Python DB API访问数据库流程.jpg"></p><h4 id="3-连接数据库对象"><a href="#3-连接数据库对象" class="headerlink" title="3. 连接数据库对象"></a>3. 连接数据库对象</h4><blockquote><p>快速写入conn连接代码的快捷技巧： <a href="http://note.youdao.com/noteshare?id=e7cdc06d7c2773263936a4b45c5e31a8" target="_blank" rel="noopener">PyCharm 快速输入技巧：Live Templates（自定义代码扩展）</a></p></blockquote><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">conn = pymysql.connect(参数列表)</span><br><span class="line">参数host：连接的mysql主机，如果本机是<span class="string">'localhost'</span></span><br><span class="line">参数port：连接的mysql主机的端口，默认是<span class="number">3306</span></span><br><span class="line">参数database：数据库的名称</span><br><span class="line">参数<span class="keyword">user</span>：连接的用户名</span><br><span class="line">参数password：连接的密码</span><br><span class="line">参数charset：通信采用的编码方式，推荐使用utf8</span><br><span class="line"></span><br><span class="line">conn.cursor()  <span class="comment"># 返回Cursor对象，用于执行sql语句并获得结果</span></span><br><span class="line">conn.commit()  <span class="comment"># 提交事务,当涉及增删改时，需要保存数据(持久化)到数据库中</span></span><br><span class="line">conn.close()  <span class="comment"># 关闭连接</span></span><br></pre></td></tr></table></figure><h4 id="4-Cursor-对象"><a href="#4-Cursor-对象" class="headerlink" title="4. Cursor 对象"></a>4. Cursor 对象</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cs_tuple = conn.cursor()  <span class="comment"># 默认为元组游标</span></span><br><span class="line"></span><br><span class="line">cs_tuple.close()  <span class="comment"># 关闭</span></span><br><span class="line">cs_tuple.execute(operation [, parameters ])  <span class="comment"># 执行语句，返回受影响的行数，主要用于执行select、insert、update、delete语句，也可以执行create、alter、drop等语句</span></span><br><span class="line">cs_tuple.fetchone()  <span class="comment"># 执行查询语句时，获取查询结果集的第一个行数据，返回一个元组</span></span><br><span class="line">cs_tuple.fetchall()  <span class="comment"># 执行查询时，获取结果集的所有行，一行构成一个元组，再将这些元组装入一个元组返回</span></span><br></pre></td></tr></table></figure><h4 id="5-Cursor-对表的增删改查"><a href="#5-Cursor-对表的增删改查" class="headerlink" title="5. Cursor 对表的增删改查"></a>5. Cursor 对表的增删改查</h4><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line">    Cursor：是一个生成器/迭代器</span><br><span class="line">    <span class="number">1</span>. cs1 = conn.<span class="built_in">cursor</span>()  # 取得元组Cursor</span><br><span class="line">    <span class="number">2</span>. cs1 = conn.<span class="built_in">cursor</span>(<span class="built_in">cursor</span>=pymysql.cursors.DictCursor)  # 取得字典Cursor，结果集是以字典的形式呈现的</span><br><span class="line">    <span class="number">3</span>. 对数据库进行增删改时，需要执行connection.commit()提交命令，把修改的数据持久化到数据库中(没有 commit 前是在内存中进行操作的)</span><br><span class="line">  </span><br><span class="line">查询</span><br><span class="line">    cs1.<span class="keyword">execute</span>(sql, <span class="keyword">args</span>)</span><br><span class="line">    <span class="built_in">cursor</span>.fetchone()  # 从结果集中抓取单条记录</span><br><span class="line">    <span class="built_in">cursor</span>.fetchall()  # 从结果集中抓取全部记录</span><br><span class="line">    </span><br><span class="line">    item = cs_dict.fetchone()  # 从结果集抓取一条数据，默认从第一个位置开始（抓取一次，游标下移一位，全部抓取完后，后面再抓取数据就为空）</span><br><span class="line">    <span class="keyword">print</span>(item[<span class="string">"name"</span>], item[<span class="string">"price"</span>])  # 字典</span><br><span class="line"></span><br><span class="line">增删改</span><br><span class="line">    <span class="built_in">cursor</span>.<span class="keyword">execute</span>(sql, <span class="keyword">args</span>)</span><br><span class="line">    conn.commit()</span><br></pre></td></tr></table></figure><h4 id="6-sql-语句的参数化"><a href="#6-sql-语句的参数化" class="headerlink" title="6. sql 语句的参数化"></a>6. sql 语句的参数化</h4><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 目的：通过sql参数化可以防止用户通过sql注入方式盗取数据</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 出现的问题：</span><br><span class="line"></span><br><span class="line">query_name = input(<span class="string">"请输入要查询的名称:"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户输入的值如下：</span></span><br><span class="line">query_name = <span class="string">' or 1 or '</span></span><br><span class="line">query_name = <span class="string">' or 1=1 or '</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sql字符串格式化后，会出现查询条件恒为True，即把所有数据都查询出来</span></span><br><span class="line">sql = <span class="string">"select * from goods WHERE name='%s'"</span> % sname  </span><br><span class="line">sql= select * <span class="built_in">from</span> goods WHERE name=<span class="string">''</span> <span class="keyword">or</span> <span class="number">1</span> <span class="keyword">or</span> <span class="string">''</span></span><br><span class="line">sql = select * <span class="built_in">from</span> goods WHERE name=<span class="string">''</span> <span class="keyword">or</span> <span class="number">1</span>=<span class="number">1</span> <span class="keyword">or</span> <span class="string">''</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行sql语句</span></span><br><span class="line">cs1.execute(sql)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 解决办法:</span><br><span class="line"></span><br><span class="line">sname=input(<span class="string">"请输入要查询的名称:"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不用开发者自己拼接字符串</span></span><br><span class="line">    sql = <span class="string">"select * from goods WHERE name=%s"</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">params</span> = [sname]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把sname作为sql参数传入到execute中，由sql的api来过滤一些特殊的字符</span></span><br><span class="line">affect_num = cs1.execute(sql, <span class="built_in">params</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 模糊查询</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- like</span></span><br><span class="line">    sql = <span class="string">"select * from goods WHERE name like %s"</span></span><br><span class="line">    <span class="built_in">params</span> = [<span class="string">'%%%s%%'</span>%key_name]  <span class="comment"># %笔记本%，注意：% 需要转义， _不需要转义</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- rlike</span></span><br><span class="line">    sql = <span class="string">"select * from goods WHERE name rlike %s"</span>  <span class="comment"># 正则实现模糊查询</span></span><br><span class="line">    <span class="built_in">params</span> = [query_key]  <span class="comment"># 正则</span></span><br><span class="line">    </span><br><span class="line">    affect_rows = cs1.execute(sql, <span class="built_in">params</span>)</span><br><span class="line">    print(<span class="string">"影响的行数:"</span>, affect_rows)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Python 与 MySQL 的交互流程；&lt;/li&gt;
&lt;li&gt;Connection 连接对象；&lt;/li&gt;
&lt;li&gt;Cursor 对象；&lt;/li&gt;
&lt;li&gt;sql 语句的参数化。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/categories/Python/MySQL/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 外键使用(三)</title>
    <link href="http://jovelin.cn/2018/07/18/MySQL%20%E5%A4%96%E9%94%AE%E4%BD%BF%E7%94%A8(%E4%B8%89)/"/>
    <id>http://jovelin.cn/2018/07/18/MySQL 外键使用(三)/</id>
    <published>2018-07-17T19:00:01.000Z</published>
    <updated>2018-07-28T01:49:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>外键概念；</li><li>外键的创建和删除使用；</li><li>面试题：在目前主流的数据库设计中，为什么越来越少使用到外键约束？</li></ol></blockquote><a id="more"></a><h3 id="外键的概念和使用"><a href="#外键的概念和使用" class="headerlink" title="外键的概念和使用"></a>外键的概念和使用</h3><h5 id="1-外键概念："><a href="#1-外键概念：" class="headerlink" title="1. 外键概念："></a>1. 外键概念：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前表的某个字段是另一个的主键</span><br></pre></td></tr></table></figure><h5 id="2-创建外键"><a href="#2-创建外键" class="headerlink" title="2. 创建外键:"></a>2. 创建外键:</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表时就添加</span></span><br><span class="line">foreign key(brand_id) references goods_brands(id)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建完表后添加</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> goods <span class="keyword">add</span> foreign <span class="keyword">key</span>(brand_id) <span class="keyword">references</span> goods_brands(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure><h5 id="3-删除外键"><a href="#3-删除外键" class="headerlink" title="3. 删除外键:"></a>3. 删除外键:</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> goods <span class="keyword">drop</span> foreign <span class="keyword">key</span> goods_ibfk_1;</span><br></pre></td></tr></table></figure><h5 id="4-涉及外键的面试"><a href="#4-涉及外键的面试" class="headerlink" title="4. 涉及外键的面试"></a>4. 涉及外键的面试</h5><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">在目前主流的数据库设计中，为什么越来越少使用到外键约束？</span><br><span class="line"></span><br><span class="line">    原因： 会极大的降低表更新的效率</span><br><span class="line">如何替代 <span class="string">'通过外键约束实现数据有效性验证'</span></span><br><span class="line">解决思想： 可在数据录入时验证<span class="comment">(UI 层、表示层、前端页面)</span>，或者在业务层面<span class="comment">(python代码)</span>去验证，而不要数据库层面去验证。</span><br><span class="line"></span><br><span class="line">M<span class="attr">VC 三层模型：</span></span><br><span class="line"><span class="attr">    1</span>. UI 层（表示层）</span><br><span class="line">    <span class="number">2.</span> 业务逻辑层</span><br><span class="line">    <span class="number">3.</span> 数据库层</span><br></pre></td></tr></table></figure><blockquote><p>Mysql 增加、删除外键详细：<a href="https://blog.csdn.net/qq_34988341/article/details/78305892" target="_blank" rel="noopener">https://blog.csdn.net/qq_34988341/article/details/78305892</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;外键概念；&lt;/li&gt;
&lt;li&gt;外键的创建和删除使用；&lt;/li&gt;
&lt;li&gt;面试题：在目前主流的数据库设计中，为什么越来越少使用到外键约束？&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/categories/Python/MySQL/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 命令语句(二)</title>
    <link href="http://jovelin.cn/2018/07/18/MySQL%20%E5%91%BD%E4%BB%A4%E8%AF%AD%E5%8F%A5(%E4%BA%8C)/"/>
    <id>http://jovelin.cn/2018/07/18/MySQL 命令语句(二)/</id>
    <published>2018-07-17T18:00:01.000Z</published>
    <updated>2018-07-28T02:04:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>使用命令行启动、登录 MySQL 数据库；</li><li>数据库、数据表和数据(记录)的增删查改；</li><li>数据(记录)的高级查询；</li><li>数据库的备份与恢复。</li></ol></blockquote><a id="more"></a><h3 id="一、基本命令行"><a href="#一、基本命令行" class="headerlink" title="一、基本命令行"></a>一、基本命令行</h3><h4 id="1-MySQL-服务器操作"><a href="#1-MySQL-服务器操作" class="headerlink" title="1. MySQL 服务器操作"></a>1. MySQL 服务器操作</h4><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">启动: sudo service mysql start</span><br><span class="line">查看: <span class="keyword">ps</span> -aux | <span class="keyword">grep</span> <span class="string">'mysql'</span></span><br><span class="line">停止: sudo service mysql <span class="keyword">stop</span></span><br><span class="line">重启：sudo service mysql restart</span><br></pre></td></tr></table></figure><!-- more --><h4 id="2-MySQL-客户端操作"><a href="#2-MySQL-客户端操作" class="headerlink" title="2. MySQL 客户端操作"></a>2. MySQL 客户端操作</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">登录: mysql -u root -p</span><br><span class="line">退出: <span class="keyword">exit</span><span class="regexp">/quit</span></span><br></pre></td></tr></table></figure><h4 id="3-数据库操作"><a href="#3-数据库操作" class="headerlink" title="3. 数据库操作"></a>3. 数据库操作</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">数据库操作：使用、查看、创建、删除</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 使用数据库</span></span><br><span class="line">    <span class="keyword">use</span> db_xxx;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 查看所有数据库</span></span><br><span class="line">    <span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 查看当前数据库</span></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">database</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 创建</span></span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">database</span> db_xxx <span class="keyword">charset</span>=utf8;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 查看创建语句</span></span><br><span class="line">    <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">database</span> db_xxx;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 删除</span></span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">database</span> db_xxx;</span><br></pre></td></tr></table></figure><h4 id="4-数据表操作"><a href="#4-数据表操作" class="headerlink" title="4. 数据表操作"></a>4. 数据表操作</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">数据表操作：查看、创建、修改、删除</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 查看</span></span><br><span class="line">    <span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 创建</span></span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> 数据表名字 (字段 类型 约束[, 字段 类型 约束]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 修改</span></span><br><span class="line">    <span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span>|<span class="keyword">modify</span>|<span class="keyword">change</span>|<span class="keyword">drop</span> 列名 类型及约束;</span><br><span class="line">        <span class="comment">-- 添加字段 </span></span><br><span class="line">        <span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 类型;</span><br><span class="line">        <span class="comment">-- 修改字段：不重命名版</span></span><br><span class="line">        <span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">modify</span> 列名 类型及约束;</span><br><span class="line">        <span class="comment">-- 修改字段：重命名版</span></span><br><span class="line">        <span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">change</span> 原名 新名 类型及约束;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 删除</span></span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br></pre></td></tr></table></figure><h4 id="5-数据-记录-的增删改查curd"><a href="#5-数据-记录-的增删改查curd" class="headerlink" title="5. 数据(记录)的增删改查curd"></a>5. 数据(记录)的增删改查curd</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">对数据表中数据的操作：增加、删除、修改和基本查询</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 新增</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> 表名(列<span class="number">1</span>,...) <span class="keyword">values</span>(值<span class="number">1</span>,...)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 删除</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 修改</span></span><br><span class="line">    <span class="keyword">update</span> 表名 <span class="keyword">set</span> 列<span class="number">1</span>=值<span class="number">1</span>,列<span class="number">2</span>=值<span class="number">2.</span>.. <span class="keyword">where</span> 条件;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 基本查询</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><h3 id="二、高级查询"><a href="#二、高级查询" class="headerlink" title="二、高级查询"></a>二、高级查询</h3><h4 id="1-基本查询"><a href="#1-基本查询" class="headerlink" title="1.基本查询"></a>1.基本查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1. 查询所有字段、指定字段的数据</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> students;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">name</span>,age <span class="keyword">from</span> students;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 消除重复行命令distinct</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> gender <span class="keyword">from</span> students;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. as给字段、表起别名</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> s.name <span class="keyword">as</span> <span class="string">'姓名'</span>,s.age <span class="keyword">as</span> <span class="string">'年龄'</span> <span class="keyword">from</span> students <span class="keyword">as</span> s;</span><br></pre></td></tr></table></figure><h4 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2.条件查询"></a>2.条件查询</h4><figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">where</span>后跟比较运算符、逻辑运算符</span><br><span class="line"></span><br><span class="line">    比较运算符：&gt;   &lt;   &gt;=  &lt;=  =   !=</span><br><span class="line">    逻辑运算符：<span class="keyword">and</span> <span class="keyword">or</span> <span class="keyword">not</span> </span><br><span class="line"></span><br><span class="line">    -- 优先级：<span class="keyword">not</span>&gt;<span class="keyword">and</span>&gt;<span class="keyword">or</span>，如果同时出现并希望先算<span class="keyword">or</span>，需要结合()使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 模糊查询<span class="keyword">like</span>和范围查询<span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">    name <span class="keyword">like</span> <span class="comment">'%杰'</span></span><br><span class="line">        % ： 代表任意个字符</span><br><span class="line">        _ : 代表一个字符</span><br><span class="line">    </span><br><span class="line">    id  <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 空判断<span class="keyword">is</span> null和非空判断<span class="keyword">is</span> <span class="keyword">not</span> null</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> height <span class="keyword">is</span> null;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span>  height <span class="keyword">is</span> <span class="keyword">not</span> null;</span><br></pre></td></tr></table></figure><h4 id="3-排序"><a href="#3-排序" class="headerlink" title="3. 排序"></a>3. 排序</h4><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">放在 <span class="keyword">from</span>、<span class="keyword">where</span>、<span class="keyword">group</span> <span class="keyword">by</span>之后</span><br><span class="line"></span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> 列<span class="number">1</span> <span class="keyword">asc</span> ，列<span class="number">2</span> <span class="keyword">desc</span>；</span><br><span class="line">    <span class="keyword">desc</span>: 降序</span><br><span class="line">    <span class="keyword">asc</span>：升序，默认</span><br></pre></td></tr></table></figure><h4 id="4-聚合函数"><a href="#4-聚合函数" class="headerlink" title="4. 聚合函数"></a>4. 聚合函数</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">count</span><span class="params">(*)</span></span>\count(列)：总数 </span><br><span class="line"><span class="function"><span class="title">max</span><span class="params">(列)</span></span>: 最大值</span><br><span class="line"><span class="function"><span class="title">min</span><span class="params">(列)</span></span>: 最小值</span><br><span class="line"><span class="function"><span class="title">sum</span><span class="params">(列)</span></span>：求和</span><br><span class="line"><span class="function"><span class="title">avg</span><span class="params">(列)</span></span>：求平均</span><br></pre></td></tr></table></figure><blockquote><p>round(avg(price),2) : 四舍五入, 保留两位小数</p></blockquote><h4 id="5-分组查询"><a href="#5-分组查询" class="headerlink" title="5. 分组查询"></a>5. 分组查询</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">group by + group_concat(字段名)/聚合函数/having</span><br><span class="line"></span><br><span class="line">更精细化统计</span><br><span class="line">   <span class="built_in"> group </span>by： 分组</span><br><span class="line">    group_concat： 拼接字符串，拼接字段名</span><br><span class="line">    聚合函数： 最大，最小，平均，计数，求和</span><br><span class="line">    having： 对分组后的结果集进一步筛选</span><br><span class="line"></span><br><span class="line">注意1: </span><br><span class="line">    select 列中只能存放分组函数(比如聚合函数)，或是出现在group by子句中的分组标签</span><br><span class="line">    </span><br><span class="line">注意2：</span><br><span class="line">    where: 对源数据做条件筛选，不能接聚合函数</span><br><span class="line">    having: 是对分组之后的数据做进一步的筛选操作, 有having就一定有group by, 有<span class="built_in"> group </span>by 不一定有having，接聚合函数</span><br></pre></td></tr></table></figure><h4 id="6-分页查询"><a href="#6-分页查询" class="headerlink" title="6. 分页查询"></a>6. 分页查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">limit [<span class="keyword">start</span>],<span class="keyword">count</span> </span><br><span class="line"></span><br><span class="line">    <span class="number">1.</span> 放在查询语句的最后</span><br><span class="line">    <span class="number">2.</span> <span class="keyword">start</span>=(page<span class="number">-1</span>)*<span class="keyword">count</span></span><br></pre></td></tr></table></figure><h4 id="7-连接查询"><a href="#7-连接查询" class="headerlink" title="7. 连接查询"></a>7. 连接查询</h4><figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">inner <span class="built_in">join</span> <span class="keyword">on</span> : 内连接(结果仅包含符合连接条件的两表中的行)</span><br><span class="line"></span><br><span class="line"><span class="built_in">left</span> <span class="built_in">join</span> <span class="keyword">on</span> : 左连接(完全显示左表所有的行，如果左表中某行 在右表中没有匹配的行，则右表该行显示<span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">right</span> <span class="built_in">join</span> <span class="keyword">on</span> : 右连接(与左连接相反)</span><br></pre></td></tr></table></figure><h4 id="8-子查询"><a href="#8-子查询" class="headerlink" title="8. 子查询"></a>8. 子查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查询中嵌套查询：</span><br><span class="line">分为三种：</span><br><span class="line">    1.标量子查询: 子查询的结果为一个值(一行一列)</span><br><span class="line">    2.列子查询：  子查询的结果为一个列(一列多行)</span><br><span class="line">    3.表子查询:   子查询的结果为一个表(多行多列)</span><br><span class="line">    </span><br><span class="line">例子：</span><br><span class="line">    1. 查出高于平均身高的信息</span><br><span class="line">        1. (<span class="keyword">select</span> <span class="keyword">avg</span>(height) <span class="keyword">from</span> students) // 结果：<span class="number">172</span></span><br><span class="line">    <span class="number">2.</span> <span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> height&gt;(<span class="keyword">select</span> <span class="keyword">avg</span>(height) <span class="keyword">from</span> students);</span><br><span class="line">    </span><br><span class="line">2. 查出能够对应上班级号的学生信息</span><br><span class="line">    1. (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> classes)  // 结果：<span class="keyword">list</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="number">2.</span> <span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> cls_id <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> classes);</span><br><span class="line">  </span><br><span class="line">3. 查询编号小于6的男性同学的姓名</span><br><span class="line">    1. (<span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> <span class="keyword">id</span>&lt;<span class="number">6</span>) // 结果：一张表</span><br><span class="line">    <span class="number">2.</span> <span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> <span class="keyword">id</span>&lt;<span class="number">6</span>) <span class="keyword">as</span> s  <span class="keyword">where</span> gender=<span class="string">'男'</span>;</span><br></pre></td></tr></table></figure><h4 id="9-自关联查询"><a href="#9-自关联查询" class="headerlink" title="9. 自关联查询"></a>9. 自关联查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">通俗讲，就是自己关联自己,再通过内连接实现数据查询</span><br><span class="line"></span><br><span class="line">1. 向areas插入记录</span><br><span class="line">    source areas.sql;</span><br><span class="line">提示：areas.sql 文件要存放在 mysql 登录的目录中</span><br><span class="line"></span><br><span class="line">2. 查询广东省中的所有城市</span><br><span class="line">    第一种方式(两条sql语句)：</span><br><span class="line">        1. 查广东省的id</span><br><span class="line">        <span class="keyword">select</span> aid  <span class="keyword">from</span> areas <span class="keyword">where</span> atitle=<span class="string">'广东省'</span>; // 440000 </span><br><span class="line"></span><br><span class="line">        2. 再把省的id作为pid，查出对应的城市信息</span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> areas <span class="keyword">where</span> pid=<span class="number">440000</span>;</span><br><span class="line"></span><br><span class="line">    第二种方式(子查询)：</span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> areas <span class="keyword">where</span> pid=(<span class="keyword">select</span> aid <span class="keyword">from</span> areas <span class="keyword">where</span> atitle=<span class="string">'广东省'</span>);</span><br><span class="line"></span><br><span class="line">    第三种方式(自关联)： </span><br><span class="line">        <span class="keyword">select</span> city.* <span class="keyword">from</span> areas <span class="keyword">as</span> city <span class="keyword">inner</span> <span class="keyword">join</span> areas <span class="keyword">as</span> province <span class="keyword">on</span> city.pid=province.aid <span class="keyword">where</span> province.atitle=<span class="string">'广东省'</span>;</span><br></pre></td></tr></table></figure><h3 id="三、查询总结"><a href="#三、查询总结" class="headerlink" title="三、查询总结"></a>三、查询总结</h3><ul><li><strong>查询的完整格式 （^_^ 不要被吓到 其实很简单 ! _ !）</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> select_expr [,select_expr,...] [      </span><br><span class="line">      <span class="keyword">FROM</span> tb_name</span><br><span class="line">      [<span class="keyword">WHERE</span> 条件判断]</span><br><span class="line">      [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &#123;col_name | postion&#125; [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>], ...] </span><br><span class="line">      [<span class="keyword">HAVING</span> <span class="keyword">WHERE</span> 条件判断]</span><br><span class="line">      [<span class="keyword">ORDER</span> <span class="keyword">BY</span> &#123;col_name|expr|postion&#125; [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>], ...]</span><br><span class="line">      [ <span class="keyword">LIMIT</span> &#123;[<span class="keyword">offset</span>,]rowcount | <span class="keyword">row_count</span> <span class="keyword">OFFSET</span> <span class="keyword">offset</span>&#125;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li><strong>完整的select语句</strong></li></ul><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">select distinct *</span><br><span class="line">    <span class="keyword">from</span> tb_name</span><br><span class="line">    where <span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">   <span class="built_in"> group </span>by <span class="built_in">..</span>. having <span class="built_in">..</span>.</span><br><span class="line">    order by <span class="built_in">..</span>.</span><br><span class="line">    limit start,count</span><br></pre></td></tr></table></figure><ul><li><strong>执行顺序</strong></li></ul><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tb_name</span><br><span class="line">    where <span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">   <span class="built_in"> group </span>by <span class="built_in">..</span>.</span><br><span class="line">    select distinct *</span><br><span class="line">    having <span class="built_in">..</span>.</span><br><span class="line">    order by <span class="built_in">..</span>.</span><br><span class="line">    limit start,count</span><br></pre></td></tr></table></figure><blockquote><p>实际使用中，只是语句中某些部分的组合，而不是全部</p></blockquote><h3 id="四、备份-还原"><a href="#四、备份-还原" class="headerlink" title="四、备份/还原"></a>四、备份/还原</h3><h5 id="1-备份"><a href="#1-备份" class="headerlink" title="1. 备份"></a>1. 备份</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>冷备份： 数据库停止再备份</span><br><span class="line"></span><br><span class="line"><span class="bullet">2. </span>热备份： 很多情况数据库运行时备份</span><br><span class="line"></span><br><span class="line"><span class="code">    逻辑备份，备份的是数据库相关的sql语句</span></span><br><span class="line"><span class="code">    适合中小型数据的备份</span></span><br><span class="line"></span><br><span class="line"><span class="code">    mysqldump –uroot –p 数据库名 &gt; python.sql;</span></span><br></pre></td></tr></table></figure><h5 id="2-还原"><a href="#2-还原" class="headerlink" title="2. 还原"></a>2. 还原</h5><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">1. 创建新数据库</span><br><span class="line"></span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">database</span> 新数据库名 charset=utf8;</span><br><span class="line"></span><br><span class="line">2. 从sql文件中导入数据</span><br><span class="line"></span><br><span class="line">    mysql -uroot –p 新数据库名 &lt; python.sql</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用命令行启动、登录 MySQL 数据库；&lt;/li&gt;
&lt;li&gt;数据库、数据表和数据(记录)的增删查改；&lt;/li&gt;
&lt;li&gt;数据(记录)的高级查询；&lt;/li&gt;
&lt;li&gt;数据库的备份与恢复。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/categories/Python/MySQL/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/tags/MySQL/"/>
    
      <category term="MySQL 命令" scheme="http://jovelin.cn/tags/MySQL-%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 数据库(一)</title>
    <link href="http://jovelin.cn/2018/07/18/MySQL%20%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%B8%80)/"/>
    <id>http://jovelin.cn/2018/07/18/MySQL 数据库(一)/</id>
    <published>2018-07-17T17:00:01.000Z</published>
    <updated>2018-07-28T02:04:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>关系型数据库 与 RDBMS；</li><li>SQL 和 MySQL 的介绍；</li><li>数据类型与约束。</li></ol></blockquote><a id="more"></a><h3 id="一、数据库介绍"><a href="#一、数据库介绍" class="headerlink" title="一、数据库介绍"></a>一、数据库介绍</h3><h4 id="1-数据存储"><a href="#1-数据存储" class="headerlink" title="1. 数据存储"></a>1. 数据存储</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据库是由一些特殊的文件组成，用来存储数据</span><br></pre></td></tr></table></figure><h4 id="2-数据库分类"><a href="#2-数据库分类" class="headerlink" title="2. 数据库分类"></a>2. 数据库分类</h4><ul><li>关系型数据库</li><li>非关系型数据库</li></ul><!-- more --><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 关系型数据库</span><br><span class="line"></span><br><span class="line">    建立在关系模型基础上的数据库，通俗讲这种数据库由多个表组成，表与表存在一定的关系</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>. 主要的几种关系型数据库</span><br><span class="line"></span><br><span class="line">    oracle：在大型项目中使用,银行,电信等项目</span><br><span class="line">    mysql：web时代使用最广泛的关系型数据库</span><br><span class="line">    <span class="keyword">ms</span> <span class="title">sql</span> server：在微软的项目中使用</span><br><span class="line">    sqlite：轻量级数据库，主要应用在移动平台</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 关系型数据库核心的元素</span><br><span class="line"></span><br><span class="line">    数据行（记录）</span><br><span class="line">    数据列（字段）</span><br><span class="line">    数据表（数据行的集合）</span><br><span class="line">    数据库（数据表的集合）</span><br><span class="line">    主键（特殊的字段，用来唯一标识记录的唯一性）</span><br></pre></td></tr></table></figure><h4 id="3-RDBMS"><a href="#3-RDBMS" class="headerlink" title="3. RDBMS"></a>3. RDBMS</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">1. RDBMS：Relational Database Management System</span><br><span class="line"></span><br><span class="line">    关系型数据库管理系统，用于管理数据库</span><br><span class="line"></span><br><span class="line">2. RDBMS 与关系型数据库的关系</span><br><span class="line">    </span><br><span class="line">    通过 RDBMS 实现对数据库的增删改查</span><br></pre></td></tr></table></figure><h4 id="4-SQL"><a href="#4-SQL" class="headerlink" title="4. SQL"></a>4. SQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SQL(Structured Query Language) 结构化查询语言，是一种用来操作RDBMS的数据库语言，当前关系型数据库都支持使用SQL语言进行操作，</span><br><span class="line">也就是说可以通过 SQL 操作 oracle,sql server,mysql,sqlite 等等所有的关系型的数据库。</span><br><span class="line"></span><br><span class="line">- DQL：数据查询语言，用于对数据进行查询，如<span class="keyword">select</span></span><br><span class="line">- DML：数据操作语言，对数据进行增加、修改、删除，如<span class="keyword">insert</span>、udpate、<span class="keyword">delete</span></span><br><span class="line">- <span class="keyword">DDL</span>：数据定义语言，进行数据库、表的管理等，如<span class="keyword">create</span>、<span class="keyword">drop</span></span><br><span class="line"></span><br><span class="line">- TPL：事务处理语言，对事务进行处理，包括<span class="keyword">begin</span> <span class="keyword">transaction</span>、<span class="keyword">commit</span>、<span class="keyword">rollback</span></span><br><span class="line">- DCL：数据控制语言，进行授权与权限回收，如<span class="keyword">grant</span>、<span class="keyword">revoke</span></span><br><span class="line">- CCL：指针控制语言，通过控制指针完成表的操作，如<span class="keyword">declare</span> <span class="keyword">cursor</span></span><br></pre></td></tr></table></figure><blockquote><p>提示： sql语句不区分大小写，每条sql语句后面加;    </p></blockquote><h4 id="5-MySQL"><a href="#5-MySQL" class="headerlink" title="5. MySQL"></a>5. MySQL</h4><ul><li>MySQL 官方网站：<a href="https://www.mysql.com/" target="_blank" rel="noopener">www.mysql.com</a></li></ul><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">MySQL 是一个关系型数据库管理系统，最早由瑞典 MySQL AB 公司开发，后来被Sun公司收购，</span><br><span class="line">Sun公司后来又被 <span class="keyword">Oracle </span>公司收购，目前属于 <span class="keyword">Oracle </span>旗下产品</span><br><span class="line"></span><br><span class="line">MySQL 对跨平台支持性好，提供了多种主流语言调用的API</span><br><span class="line"></span><br><span class="line">MySQL 市场占有率高，且开源，免费，是中小型项目首选的关系型数据库系统</span><br></pre></td></tr></table></figure><h4 id="6-数据库引擎"><a href="#6-数据库引擎" class="headerlink" title="6. 数据库引擎"></a>6. 数据库引擎</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InnoDB，MyISAM 数据库引擎</span><br><span class="line"></span><br><span class="line">mysql 创建表时，默认是InnoDB引擎</span><br><span class="line"></span><br><span class="line">两种类型有什么区别：</span><br><span class="line">MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。 </span><br><span class="line">MyISAM类型的表强调的是性能，其执行速度比InnoDB类型更快，但是不提供事务等高级特性，而InnoDB提供事务支持,行级锁，高并发。</span><br><span class="line">一般开发中默认使用的是innodb引擎</span><br></pre></td></tr></table></figure><p><br></p><h3 id="二、数据类型与约束"><a href="#二、数据类型与约束" class="headerlink" title="二、数据类型与约束"></a>二、数据类型与约束</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 数据类型：</span><br><span class="line">   使用数据类型的原则是：够用就行，尽量使用取值范围小的，而不用大的，这样可以更多的节省存储空间</span><br><span class="line"></span><br><span class="line">   <span class="number">1.</span> int： 整形</span><br><span class="line"><span class="number">2.</span> bit：位（<span class="number">0</span> | <span class="number">1</span>）</span><br><span class="line"><span class="number">2.</span> decimal： 浮点数  # dicemal(<span class="number">5</span>,<span class="number">2</span>) # 总位数<span class="number">5</span>位，小数位<span class="number">2</span>位</span><br><span class="line"><span class="number">3.</span> varchar： 可变字符类型 # 可节省存储空间</span><br><span class="line"><span class="number">4.</span> enum： 枚举类型 # gender enum(<span class="string">"男"</span>,<span class="string">"女"</span>) 注意：有中文时，数据库编码必须支持中文（utf<span class="number">-8</span> 可以，latin1 不行）</span><br><span class="line"><span class="number">5.</span> datetime： 日期时间类型</span><br><span class="line"><span class="number">6.</span> tinyint： 非贪婪整形</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 数据约束：</span><br><span class="line"><span class="number">1.</span> 主键： primary <span class="type">key</span>(id)</span><br><span class="line"><span class="number">2.</span> 自增： auto_increment</span><br><span class="line"><span class="number">2.</span> 非空： not null</span><br><span class="line"><span class="number">3.</span> 唯一值： unique</span><br><span class="line"><span class="number">4.</span> 缺省值： <span class="section">default</span></span><br><span class="line"><span class="number">5.</span> 外键： foreign <span class="type">key</span> </span><br><span class="line"><span class="number">6.</span> 无符号： unsigned</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关系型数据库 与 RDBMS；&lt;/li&gt;
&lt;li&gt;SQL 和 MySQL 的介绍；&lt;/li&gt;
&lt;li&gt;数据类型与约束。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/categories/Python/MySQL/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Python HTTP 协议与 web 静态服务器</title>
    <link href="http://jovelin.cn/2018/07/15/Python%20HTTP%20%E5%8D%8F%E8%AE%AE%E4%B8%8E%20web%20%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://jovelin.cn/2018/07/15/Python HTTP 协议与 web 静态服务器/</id>
    <published>2018-07-15T12:08:35.000Z</published>
    <updated>2018-07-28T02:31:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>浏览器请求的基本流程；</li><li>浏览器请求的 URL；</li><li>请求报文格式；</li><li>响应报文格式；</li><li>网络响应状态码；</li><li>长连接和短连接。</li></ol></blockquote><a id="more"></a><h1 id="HTTP-超文本传输协议"><a href="#HTTP-超文本传输协议" class="headerlink" title="HTTP 超文本传输协议"></a>HTTP 超文本传输协议</h1><p><strong>超文本传输协议（HyperText Transfer Protocol）是一种应用层协议。</strong></p><p>HTTP是万维网的数据通信的基础。设计HTTP最初的目的是为了提供一种发布和接收HTML页面&lt;网页&gt;的方法。</p><ul><li>1989年蒂姆·伯纳斯-李在CERN研发</li><li>1999年公布现今广泛使用的HTTP 1.1版(RFC2616)</li></ul><h3 id="一、浏览器请求的基本流程"><a href="#一、浏览器请求的基本流程" class="headerlink" title="一、浏览器请求的基本流程"></a>一、浏览器请求的基本流程</h3><p><img src="https://upload-images.jianshu.io/upload_images/3365001-07b4a469d55b38bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="mini-web服务器工作流程"></p><h3 id="二、浏览器请求的-URL"><a href="#二、浏览器请求的-URL" class="headerlink" title="二、浏览器请求的 URL"></a>二、浏览器请求的 URL</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> www.baidu.com: 网站(网址)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   url(统一资源定位符):</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   完整版: http://www.baidu.com:80/aaa/bbb/index.html?username=aaa&amp;password=123</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       http/https: https是http加密后进行传输;(https收费...)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       端口: http: 80;    https: 443;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       /aaa/bbb/index.html: 请求的资源路径;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       username=aaa&amp;password=123: 传输的内容;(请求体...GET)</span></span><br></pre></td></tr></table></figure><h3 id="三、请求报文格式总结"><a href="#三、请求报文格式总结" class="headerlink" title="三、请求报文格式总结"></a>三、请求报文格式总结</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 总结: 请求报文格式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.请求行;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     GET / HTTP/1.1\r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.请求头;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     头属性: 属性值\r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     Host: www.baidu.com\r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.空行;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     \r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.请求体;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     username=jovelin&amp;password=123456</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 请求报文格式分析:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.请求行(request line)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   格式: 请求方式 资源路径 协议及版本号\r\n</span></span><br><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">   GET: 常用请求方式GET/POST;   (GET/POST/PUT/DELETE...)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       GET:  获取(从服务器获取信息的时候用...)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       POST: 发送(向服务器存储信息的时候用...)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   /: /aaa/bbb/index.html; 想要访问的页面/图片/音频...(明天要用...)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   HTTP/1.1: 协议及版本号</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   空行: \r\n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.请求头(request header)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   格式: 头属性: 头信息\r\n</span></span><br><span class="line">Host: www.baidu.com\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       Host: 主机;(记住...)</span></span><br><span class="line">Connection: keep-alive\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       Connection: 链接;(长连接)</span></span><br><span class="line">Upgrade-Insecure-Requests: 1\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       提示服务端我可以解析https;</span></span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       User-Agent: 用户代理;(浏览器及系统版本...)</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       Accept: 接收!</span></span><br><span class="line">Accept-Encoding: gzip, deflate, br\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       压缩: 数据压缩算法;</span></span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       语言: 中文;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.空行;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     \r\n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.请求体;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     username=jovelin&amp;password=123456</span></span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/3365001-28c36634d5de588c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="请求报文格式总结"></p><h3 id="四、响应报文格式总结"><a href="#四、响应报文格式总结" class="headerlink" title="四、响应报文格式总结"></a>四、响应报文格式总结</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 总结: 响应报文格式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.响应行;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   HTTP/1.1 200 OK\r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.响应头;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   头属性: 头信息\r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   Server: BWS/1.1\r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.换行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   \r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.响应体;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   文本/图片/音频/视频/网页...</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 响应报文格式分析:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.响应行(response line)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   格式: 协议及版本号 状态码 英文解释\r\n</span></span><br><span class="line">HTTP/1.1 200 OK\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       HTTP/1.1: 协议及版本号</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       200 OK: 状态码 英文解释</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.响应头(response header)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   格式: 头属性: 属性值\r\n</span></span><br><span class="line">Connection: Keep-Alive\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">   长连接</span></span><br><span class="line">Content-Encoding: gzip\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">   压缩格式</span></span><br><span class="line">Content-Type: text/html; charset=utf-8\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">   请求体的文本类型;</span></span><br><span class="line">Date: Wed, 14 Mar 2018 09:52:48 GMT\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">   更新时间</span></span><br><span class="line">Server: BWS/1.1\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">   服务器名:(记住,因为简单,以后用)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.空行;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     \r\n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.响应体(response body)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     文本/图片/音频/视频/网页...</span></span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/3365001-31f7768dcb76551e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="响应报文格式总结"></p><h3 id="五、网络响应状态码"><a href="#五、网络响应状态码" class="headerlink" title="五、网络响应状态码"></a>五、网络响应状态码</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>xx 成功  <span class="number">200</span> OK  （发送成功）</span><br><span class="line"><span class="number">3</span>xx 重定向 </span><br><span class="line"><span class="number">302</span> Moved Temporarily/<span class="number">302</span> Found   解释作用(暂时跳转)  <span class="number">301</span>/<span class="number">2</span>/<span class="number">3</span>/<span class="number">4</span>/<span class="number">7</span></span><br><span class="line"><span class="number">307</span> Internal Redirect（内部重定向）</span><br><span class="line"><span class="symbol">Location:</span> https:<span class="comment">//www.baidu.com</span></span><br><span class="line"><span class="number">4</span>xx 客户端错误 <span class="number">404</span> Not Found（客户端发送的页面没找打）</span><br><span class="line"><span class="symbol">http:</span><span class="comment">//help.xunlei.com/online/stat_inst.php?pid=0000&amp;thunderver=5.8.14.706&amp;thundertype=4&amp;peerid=000C294E4AE1J3J4</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//video.baomihua.com/play_error/-30001</span></span><br><span class="line"><span class="number">5</span>xx 服务器错误 <span class="number">503</span> Service Unavailable（服务器不能使用）</span><br></pre></td></tr></table></figure><h3 id="六、长连接和短连接"><a href="#六、长连接和短连接" class="headerlink" title="六、长连接和短连接"></a>六、长连接和短连接</h3><p><br></p><p><strong>TCP长/短连接 好比 地铁卡/单程票</strong></p><p><br></p><p>在HTTP/1.0中, 默认使用的是短连接.也就是说, 浏览器和服务器每进行一次HTTP操作, 就建立一次连接, 但任务结束就中断连接.如果客户端浏览器访问的某个HTML或其他类型的 Web 页中包含有其他的Web资源，如js文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p><p>但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码:</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Connection</span>:<span class="meta">keep</span>-alive</span><br></pre></td></tr></table></figure><p>在真正的读写操作之前，server与client之间必须建立一个连接，</p><p>当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，</p><p>连接的建立通过三次握手，释放则需要四次握手，</p><p>所以说每个连接的建立都是需要资源消耗和时间消耗的。</p><h4 id="TCP-短连接"><a href="#TCP-短连接" class="headerlink" title="TCP 短连接"></a>TCP 短连接</h4><p><strong>短连接一般只会在 client/server 间传递一次读写操作！</strong></p><ol><li>client 向 server 发起连接请求</li><li>server 接到请求，双方建立连接</li><li>client 向 server 发送消息</li><li>server 回应 client</li><li>一次读写完成，此时双方任何一个都可以发起 close 操作 (一般都是 client 先发起 close 操作。当然也不排除有特殊的情况。)</li></ol><h4 id="TCP-长连接"><a href="#TCP-长连接" class="headerlink" title="TCP 长连接"></a>TCP 长连接</h4><ol><li>client 向 server 发起连接</li><li>server 接到请求，双方建立连接</li><li>client 向 server 发送消息</li><li>server 回应 client</li><li>一次读写完成，连接不关闭</li><li>后续读写操作…</li><li>长时间操作之后 client 发起关闭请求</li></ol><h4 id="TCP长-短连接的优点和缺点"><a href="#TCP长-短连接的优点和缺点" class="headerlink" title="TCP长/短连接的优点和缺点"></a>TCP长/短连接的优点和缺点</h4><p>长连接可以省去较多的TCP建立和关闭的操作，节约时间。但是如果用户量太大容易造成服务器负载过高最终导致服务不可用。</p><p>短连接对于服务器来说实现起来较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但是如果用户访问量很大, 往往可能在很短时间内需要创建大量的连接，造成服务器响应速度过慢。</p><p><strong>总之：</strong></p><p>小的WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源来让套接字 保持存活-keep alive，</p><p>对于中大型WEB网站一般都采用长连接，好处是响应用户请求的时间更短，用户体验更好，虽然更耗硬件资源一些，但这都不是事儿。另外，数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误。</p><h3 id="七、案例"><a href="#七、案例" class="headerlink" title="七、案例"></a>七、案例</h3><p>1.模拟服务器(服务端)</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 需求: 获取请求报文的格式;</span></span><br><span class="line"></span><br><span class="line">import <span class="built_in">socket</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tcp_socket = <span class="built_in">socket</span>.<span class="built_in">socket</span>(<span class="built_in">socket</span>.AF_INET, <span class="built_in">socket</span>.SOCK_STREAM)</span><br><span class="line">    tcp_socket.setsockopt(<span class="built_in">socket</span>.SOL_SOCKET, <span class="built_in">socket</span>.SO_REUSEADDR, True)</span><br><span class="line">    tcp_socket.bind((<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>))</span><br><span class="line">    tcp_socket.listen(<span class="number">128</span>)</span><br><span class="line">    print(<span class="string">"服务已开启..."</span>)</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        service_client_socket, ip_port = tcp_socket.accept()</span><br><span class="line">        print(ip_port, <span class="string">"已连接..."</span>)</span><br><span class="line">        data_bin = service_client_socket.recv(<span class="number">5000</span>)</span><br><span class="line">        print(<span class="string">"二进制数据："</span>, data_bin)</span><br><span class="line">        print(<span class="string">"解析后数据："</span>, data_bin.decode())</span><br><span class="line">        service_client_socket.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><p>2.模拟浏览器(客户端)</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 需求: 获取响应报文的格式内容并保存;</span></span><br><span class="line"></span><br><span class="line">import <span class="built_in">socket</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建TCP连接</span></span><br><span class="line">    tcp_socket = <span class="built_in">socket</span>.<span class="built_in">socket</span>(<span class="built_in">socket</span>.AF_INET, <span class="built_in">socket</span>.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># DNS解析 和 连接HTTP服务器</span></span><br><span class="line">    tcp_socket.connect((<span class="string">"www.baidu.com"</span>, <span class="number">80</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 组包 发送HTTP请求报文</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求行</span></span><br><span class="line">    request_line = <span class="string">"GET / HTTP/1.1\r\n"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求头</span></span><br><span class="line">    request_header = <span class="string">"Host: www.baidu.com\r\n"</span></span><br><span class="line">    request_data = request_line + request_header + <span class="string">"\r\n"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送请求</span></span><br><span class="line">    tcp_socket.<span class="built_in">send</span>(request_data.encode())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收响应报文</span></span><br><span class="line">    response_data = tcp_socket.recv(<span class="number">4096</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对响应报文进行解析 -- 切割</span></span><br><span class="line">    response_str_data = response_data.decode()</span><br><span class="line">    <span class="comment"># print(response_data)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># '\r\n\r\n'之后的数据就是响应体数据</span></span><br><span class="line">    index = response_str_data.find(<span class="string">"\r\n\r\n"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 切割出的数据就是文件数据</span></span><br><span class="line">    html_data = response_str_data[index + <span class="number">4</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># data_file = open("index.html", "wb")</span></span><br><span class="line">    <span class="comment"># data_file.write(html_data.encode())</span></span><br><span class="line">    <span class="comment"># data_file.close()</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"index.html"</span>, <span class="string">"wb"</span>) <span class="keyword">as</span> <span class="built_in">file</span>:</span><br><span class="line">        <span class="built_in">file</span>.<span class="built_in">write</span>(html_data.encode())</span><br><span class="line">        <span class="comment"># 如果是长连接,还有很多内容没有收到,需要死循环接收</span></span><br><span class="line">        <span class="keyword">while</span> True:</span><br><span class="line">            <span class="comment"># 后面在获取到的响应内容,就不包含响应行和响应头了</span></span><br><span class="line">            data_bin = tcp_socket.recv(<span class="number">4096</span>)</span><br><span class="line">            <span class="keyword">if</span> data_bin:</span><br><span class="line">                <span class="built_in">file</span>.<span class="built_in">write</span>(data_bin)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭套接字</span></span><br><span class="line">    tcp_socket.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><ol start="3"><li>web 静态服务器</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebServer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Web 服务器类"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ip, port)</span>:</span></span><br><span class="line">        <span class="comment"># 创建套接字</span></span><br><span class="line">        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        <span class="comment"># 设置套接字复用地址</span></span><br><span class="line">        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 绑定IP地址和端口</span></span><br><span class="line">        self.socket.bind((ip, port))</span><br><span class="line">        <span class="comment"># 设置被动套接字</span></span><br><span class="line">        self.socket.listen(<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startup</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""等待客户端连接"""</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="comment"># 等待被连接</span></span><br><span class="line">            service_client_socket, ip_port = self.socket.accept()</span><br><span class="line">            print(ip_port, <span class="string">"连接成功."</span>, end=<span class="string">"\n\n"</span>)</span><br><span class="line">            <span class="comment"># 处理请求</span></span><br><span class="line">            gevent.spawn(self.client_handler, service_client_socket)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">client_handler</span><span class="params">(self, service_client_socket)</span>:</span></span><br><span class="line">        <span class="string">"""处理客户端请求"""</span></span><br><span class="line">        request_data_bin = service_client_socket.recv(<span class="number">4096</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> request_data_bin:</span><br><span class="line">            print(<span class="string">'客户端已经断开连接.'</span>, end=<span class="string">"\n\n"</span>)</span><br><span class="line">            service_client_socket.close()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"客户端请求报文："</span>, request_data_bin, end=<span class="string">"\n\n"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 解析 HTTP 文本</span></span><br><span class="line">        my_http = self.parse_http(request_data_bin.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取固定页面数据</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response_line = <span class="string">'HTTP/1.1 200 OK\r\n'</span></span><br><span class="line">            response_header = <span class="string">'Server: PythonWebServer1.0\r\n'</span></span><br><span class="line">            file = open(<span class="string">'./static'</span> + my_http[<span class="string">'url'</span>], <span class="string">'rb'</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            response_line = <span class="string">'HTTP/1.1 404 NOT FOUND\r\n'</span></span><br><span class="line">            response_header = <span class="string">'Server: PythonWebServer1.0\r\n'</span></span><br><span class="line">            file = open(<span class="string">'./static/404.html'</span>, <span class="string">'rb'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取文件内容</span></span><br><span class="line">        response_content = file.read()</span><br><span class="line">        file.close()</span><br><span class="line">        <span class="comment"># 拼接响应报文</span></span><br><span class="line">        response_data = (response_line + response_header + <span class="string">'\r\n'</span>).encode(<span class="string">'utf-8'</span>) + response_content</span><br><span class="line">        <span class="comment"># 发送响应报文</span></span><br><span class="line">        service_client_socket.send(response_data)</span><br><span class="line">        <span class="comment"># 关闭套接字</span></span><br><span class="line">        service_client_socket.close()</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"\n"</span>, <span class="string">"-"</span> * <span class="number">100</span>, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_http</span><span class="params">(request_data)</span>:</span></span><br><span class="line">        <span class="string">"""解析 HTTP 文本"""</span></span><br><span class="line"></span><br><span class="line">        my_http = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 分成多行</span></span><br><span class="line">        request_headers = request_data.split(<span class="string">'\r\n'</span>)</span><br><span class="line">        request_lines = request_headers[<span class="number">0</span>].split(<span class="string">' '</span>)</span><br><span class="line">        print(<span class="string">"request_lines: "</span>, request_lines, end=<span class="string">"\n\n"</span>)</span><br><span class="line"></span><br><span class="line">        my_http[<span class="string">'method'</span>] = request_lines[<span class="number">0</span>]</span><br><span class="line">        my_http[<span class="string">'url'</span>] = request_lines[<span class="number">1</span>]</span><br><span class="line">        my_http[<span class="string">'version'</span>] = request_lines[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 未指定页面时 默认访问 index.html</span></span><br><span class="line">        <span class="keyword">if</span> my_http[<span class="string">'url'</span>] == <span class="string">"/"</span>:</span><br><span class="line">            my_http[<span class="string">'url'</span>] = <span class="string">"/index.html"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> header <span class="keyword">in</span> request_headers[<span class="number">1</span>:]:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> header:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Host: www.baidu.com</span></span><br><span class="line">            lines = header.split(<span class="string">':'</span>)</span><br><span class="line">            my_http[lines[<span class="number">0</span>]] = lines[<span class="number">1</span>][<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"my_http: "</span>, my_http, end=<span class="string">"\n\n"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> my_http</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">port_handler</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""指定端口"""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 默认设置端口为 8888</span></span><br><span class="line">    port = <span class="number">8888</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 获取外部传递过来的参数;</span></span><br><span class="line">    <span class="comment"># # 1.尽量值传递一个参数过来</span></span><br><span class="line">    <span class="comment"># #   ctrl+z: 退出页面,但是程序没有退出;(该端口还可以使用)</span></span><br><span class="line">    <span class="comment"># #   ctrl+c: 退出页面,也退出程序;</span></span><br><span class="line">    <span class="comment"># # print(sys.argv[1])</span></span><br><span class="line">    <span class="comment"># if not len(sys.argv) == 2:</span></span><br><span class="line">    <span class="comment">#     print('输入的格式错误,正确的格式应该是: python3 文件名.py 端口号')</span></span><br><span class="line">    <span class="comment">#     return</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># # 2.如果传递过来端口号,里面有非数字;(也不行)</span></span><br><span class="line">    <span class="comment"># if not sys.argv[1].isdigit():</span></span><br><span class="line">    <span class="comment">#     print('端口号, 必须是整数!!!')</span></span><br><span class="line">    <span class="comment">#     return</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># # 3.取值范围: [0-65535]</span></span><br><span class="line">    <span class="comment"># if not 0 &lt;= int(sys.argv[1]) &lt;= 65535:</span></span><br><span class="line">    <span class="comment">#     print('端口号必须在: [0-65535]之间!!!')</span></span><br><span class="line">    <span class="comment">#     return</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># # 4.如果全部通过,那么要把端口号,传递到程序中</span></span><br><span class="line">    <span class="comment"># # 获取用户指定的绑定端口</span></span><br><span class="line">    <span class="comment"># port = int(sys.argv[1])</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> port</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 服务器 IP，默认为本机 IP</span></span><br><span class="line">    server_ip = <span class="string">""</span></span><br><span class="line">    <span class="comment"># 服务器 端口</span></span><br><span class="line">    server_port = port_handler()</span><br><span class="line">    web_server = WebServer(server_ip, server_port)</span><br><span class="line">    web_server.startup()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;浏览器请求的基本流程；&lt;/li&gt;
&lt;li&gt;浏览器请求的 URL；&lt;/li&gt;
&lt;li&gt;请求报文格式；&lt;/li&gt;
&lt;li&gt;响应报文格式；&lt;/li&gt;
&lt;li&gt;网络响应状态码；&lt;/li&gt;
&lt;li&gt;长连接和短连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="HTTP" scheme="http://jovelin.cn/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Python 中 exit() 的用法</title>
    <link href="http://jovelin.cn/2018/07/15/Python%20%E4%B8%AD%20exit()%20%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://jovelin.cn/2018/07/15/Python 中 exit() 的用法/</id>
    <published>2018-07-14T16:22:31.000Z</published>
    <updated>2018-07-28T02:03:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Python 中 exit() 的用法总结</strong>：</p><ol><li><p><strong>sys.exit(n)  退出程序引发 SystemExit 异常，可以捕获异常执行些清理工作</strong>。</p><p> n 默认值为 0，表示正常退出，其他都是非正常退出。还可以 sys.exit(“sorry, goodbye!”);</p><p> 一般 <strong>主程序中</strong> 使用此退出。</p></li></ol><a id="more"></a><ol><li><p><strong>os._exit(n)，直接退出，不抛异常， 不执行相关清理工作</strong>。</p><p> 常用在 <strong>子进程</strong> 的退出。</p></li><li><p><strong>exit()/quit()，跑出 SystemExit 异常</strong>。</p><p> 一般在 <strong>交互式 shell 中</strong> 退出时使用。</p></li><li><p><strong>exit(0) 有什么功能</strong>？</p><p> 在很多类型的操作系统里，exit(0) 可以中断某个程序，而其中的数字参数则用来表示程序是否是碰到错误而中断。</p><p> exit(1) 表示发生了错误，而 exit(0) 则表示程序是正常退出的。</p><p> 这和我们学的布尔逻辑  0==False 正好相反，不过你可以用不一样的数字表示不同的错误结果。</p><p> 比如你可以用 exit(100) 来表示另一种和 exit(2) 或 exit(1) 不同的错误。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Python 中 exit() 的用法总结&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;sys.exit(n)  退出程序引发 SystemExit 异常，可以捕获异常执行些清理工作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; n 默认值为 0，表示正常退出，其他都是非正常退出。还可以 sys.exit(“sorry, goodbye!”);&lt;/p&gt;
&lt;p&gt; 一般 &lt;strong&gt;主程序中&lt;/strong&gt; 使用此退出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="exit 方法" scheme="http://jovelin.cn/tags/exit-%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python 正则表达式</title>
    <link href="http://jovelin.cn/2018/07/12/Python%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://jovelin.cn/2018/07/12/Python 正则表达式/</id>
    <published>2018-07-12T07:21:00.000Z</published>
    <updated>2018-07-28T02:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>定义；</li><li>常用的元字符；</li><li>常用的限定符（量词）；</li><li>分组；</li><li>正则高级 API（4个）；</li><li>r 的作用；</li><li>贪婪/非贪婪。</li></ol></blockquote><a id="more"></a><h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。</p><p><strong>简而言之：正则表达式就是记录文本规则的代码。</strong></p><!-- more --><p>特点: </p><p>操作字符串</p><p>1.更快的方式操作字符串；(表单校验，数据匹配…)</p><p>2.普通字符串操作无法做到的，或者很难做的正则很容易搞定！！！</p><p>使用场景：</p><p>1.表单校验</p><p>2.api 里面也需要正则</p><p><strong>正则表达式代码体验</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python 解释器为我们提供了一个使用正则的模块，这个模块叫做re(regex)</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 1.match()：匹配 -&gt; object</span></span><br><span class="line">    <span class="comment"># group()：通过匹配后，可以使用group()获取内容</span></span><br><span class="line">    obj = re.match(<span class="string">r"jovelin"</span>, <span class="string">"jovelin"</span>)</span><br><span class="line">    print(obj.group())  <span class="comment"># -&gt; jovelin</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.如果被匹配的内容多余正则；(只返回开头匹配的部分)</span></span><br><span class="line">    obj = re.match(<span class="string">r"jovelin"</span>, <span class="string">"jovelin.cn"</span>)</span><br><span class="line">    print(obj.group())  <span class="comment"># -&gt; jovelin</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.如果开头部分，没有匹配的内容； 那么返回None</span></span><br><span class="line">    obj = re.match(<span class="string">r"jovelin"</span>, <span class="string">"www.jovelin.cn"</span>)</span><br><span class="line">    print(obj)  <span class="comment"># -&gt; None</span></span><br><span class="line"></span><br><span class="line">    print(<span class="keyword">None</span>, type(<span class="keyword">None</span>))  <span class="comment"># -&gt; None &lt;class 'NoneType'&gt;</span></span><br></pre></td></tr></table></figure><h3 id="二、常用的元字符"><a href="#二、常用的元字符" class="headerlink" title="二、常用的元字符"></a>二、常用的元字符</h3><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:left">匹配除换行符(\n)以外的任意字符</td></tr><tr><td style="text-align:center">[]</td><td style="text-align:left">匹配 [ ] 中列举的字符</td></tr><tr><td style="text-align:center">\w 与 \W</td><td style="text-align:left">匹配字母或数字或下划线或汉字(单词) / 反义(非单词)</td></tr><tr><td style="text-align:center">\s 与 \S</td><td style="text-align:left">匹配任意的空白符 / 反义(非空白)</td></tr><tr><td style="text-align:center">\d 与 \D</td><td style="text-align:left">匹配数字 [0-9] / 反义(非数字)</td></tr><tr><td style="text-align:center">\b 与 \B</td><td style="text-align:left">匹配单词的开始或结束 / 反义</td></tr><tr><td style="text-align:center">^</td><td style="text-align:left">匹配字符串的开始</td></tr><tr><td style="text-align:center">$</td><td style="text-align:left">匹配字符串的结束</td></tr></tbody></table><p><strong>代码演示：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># . 匹配任意1个字符（除了 \n）</span></span><br><span class="line">print(re.match(<span class="string">r'a.b'</span>, <span class="string">'a\nb'</span>))  <span class="comment"># -&gt; None</span></span><br><span class="line"><span class="comment">#  - 在 [] 里代表范围</span></span><br><span class="line">print(re.match(<span class="string">r'a[a-c]c'</span>, <span class="string">'abc'</span>).group())  <span class="comment"># -&gt; abc</span></span><br><span class="line"><span class="comment"># 在 [] 里面也想使用 - 那么需要 \ 转义</span></span><br><span class="line">print(re.match(<span class="string">r'a[a\-c]c'</span>, <span class="string">'a-c'</span>).group())  <span class="comment"># -&gt; a-c</span></span><br><span class="line"><span class="comment"># \b用法 与 ^ $ 相似，不过 \b 只匹配单词，\B 只匹配非单词</span></span><br><span class="line">print(re.match(<span class="string">r"\b\w+\b"</span>, <span class="string">"0_9_a_z_A_Z汉字"</span>).group())  <span class="comment"># -&gt; 0_9_a_z_A_Z</span></span><br><span class="line">print(re.match(<span class="string">r"\B\W+\B"</span>, <span class="string">"!@#$%^&amp;*"</span>).group())  <span class="comment"># -&gt; !@#$%^&amp;*</span></span><br><span class="line"><span class="comment"># ^匹配字符串开头</span></span><br><span class="line"><span class="comment"># $匹配字符串结尾</span></span><br><span class="line">print(re.match(<span class="string">r'[\w\W]*$'</span>, <span class="string">'0_9_a_z_A_Z汉字!@#$%^&amp;* \n\t'</span>).group())  <span class="comment"># -&gt; 0_9_a_z_A_Z汉字!@#$%^&amp;* </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意: ^ 如果出现在 [] 中，代表的是取反!   (想要使用 ^,可以转义 \)</span></span><br><span class="line">print(re.match(<span class="string">r'^[\^]$'</span>, <span class="string">'^'</span>).group())  <span class="comment"># -&gt; ^</span></span><br><span class="line">print(re.match(<span class="string">r'^[^^]$'</span>, <span class="string">'^'</span>))  <span class="comment"># -&gt; None</span></span><br><span class="line">print(re.match(<span class="string">r'^[^47]$'</span>, <span class="string">'47'</span>))  <span class="comment"># -&gt; 47</span></span><br></pre></td></tr></table></figure><h3 id="三、常用的限定符（量词）"><a href="#三、常用的限定符（量词）" class="headerlink" title="三、常用的限定符（量词）"></a>三、常用的限定符（量词）</h3><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:left">说明</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:left">重复零次或更多次</td><td style="text-align:left">&gt;=0</td></tr><tr><td style="text-align:center">+</td><td style="text-align:left">重复一次或更多次</td><td style="text-align:left">&gt;=1</td></tr><tr><td style="text-align:center">?</td><td style="text-align:left">重复零次或一次</td><td style="text-align:left">0 or 1</td></tr><tr><td style="text-align:center">{n}</td><td style="text-align:left">重复n次</td><td style="text-align:left">==n</td></tr><tr><td style="text-align:center">{n,}</td><td style="text-align:left">重复n次或更多次</td><td style="text-align:left">&gt;=n</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:left">重复n到m次</td><td style="text-align:left">n&lt;=X&lt;=m</td></tr></tbody></table><p><strong>代码演示：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># * 匹配前一个字符出现0次或者无限次，即可有可无 (&gt;=0)</span></span><br><span class="line">print(re.match(<span class="string">r'a*b'</span>, <span class="string">'b'</span>).group())  <span class="comment"># -&gt; b</span></span><br><span class="line"><span class="comment"># + 匹配前一个字符出现1次或者无限次，即至少有1次 (&gt;=1)</span></span><br><span class="line">print(re.match(<span class="string">r'a+b'</span>, <span class="string">'b'</span>))  <span class="comment"># -&gt; None，必须要 1 个 a</span></span><br><span class="line"><span class="comment"># &#123;n&#125; 匹配前一个字符出现n次 == n                           (== n)</span></span><br><span class="line">print(re.match(<span class="string">r'a&#123;2&#125;b'</span>, <span class="string">'ab'</span>))  <span class="comment"># -&gt; None，必须要 2 个 a</span></span><br><span class="line"><span class="comment"># &#123;n,m&#125; 匹配前一个字符出现: n次&lt;= 前一个字符 &lt;=m次 (n&lt;=X&lt;=m)</span></span><br><span class="line">print(re.match(<span class="string">r'a&#123;2,5&#125;b'</span>, <span class="string">'ab'</span>))  <span class="comment"># -&gt; None，a 的次数必须是 2&lt;=a&lt;=5</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>案例</strong>：</p><p>1.校验手机号</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMobileNumber</span><span class="params">(tel)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    校验手机号是否正确</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> re.match(<span class="string">r"^[1-][34578-]\d&#123;9&#125;$"</span>, tel) <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(isMobileNumber(<span class="string">"18819950820"</span>))</span><br></pre></td></tr></table></figure><p>2.校验邮箱</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">邮箱名称部分为： [a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)&#123;0,4&#125;</span></span><br><span class="line"><span class="string">域名部分： [a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+</span></span><br><span class="line"><span class="string">连起来 ^[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)&#123;0,4&#125;@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)&#123;1,2&#125;$</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isEmail</span><span class="params">(email)</span>:</span></span><br><span class="line">    <span class="string">"""校验邮箱是否正确"""</span></span><br><span class="line">    <span class="keyword">if</span> re.match(<span class="string">r"^[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)&#123;0,4&#125;@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)&#123;1,2&#125;$"</span>, email) <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(isEmail(<span class="string">"jovelin@163.com"</span>))</span><br><span class="line">print(isEmail(<span class="string">"jovelin.dev@gmail.com"</span>))</span><br><span class="line">print(isEmail(<span class="string">"jovelin@163.com.cn"</span>))</span><br><span class="line">print(isEmail(<span class="string">"jovelin.dev@gmail.com.cn"</span>))</span><br></pre></td></tr></table></figure><h3 id="四、分组"><a href="#四、分组" class="headerlink" title="四、分组"></a>四、分组</h3><p>用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作。</p><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">(abc)</td><td style="text-align:left">将括号中字符作为一个分组</td></tr><tr><td style="text-align:center">竖线</td><td style="text-align:left">匹配左右任意一个表达式</td></tr><tr><td style="text-align:center">\num</td><td style="text-align:left">引用分组num匹配到的字符串</td></tr><tr><td style="text-align:center">(?P<name>)</name></td><td style="text-align:left">分组起别名</td></tr><tr><td style="text-align:center">(?P=name)</td><td style="text-align:left">引用别名为name分组匹配到的字符串</td></tr></tbody></table><p>代码演示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># (abc) 将括号中字符作为一个分组</span></span><br><span class="line">print(re.match(<span class="string">r'(aaa)bbb(ccc)'</span>, <span class="string">'aaabbbccc'</span>).group())</span><br><span class="line"><span class="comment"># 一个括号就是一个分组； group()：参数代表分组的编号；写 0 或者不写时，获取全部；</span></span><br><span class="line">print(re.match(<span class="string">r'(aaa)bbb(ccc)'</span>, <span class="string">'aaabbbccc'</span>).group())</span><br><span class="line">print(re.match(<span class="string">r'(aaa)bbb(ccc)'</span>, <span class="string">'aaabbbccc'</span>).group(<span class="number">0</span>))</span><br><span class="line">print(re.match(<span class="string">r'(aaa)bbb(ccc)'</span>, <span class="string">'aaabbbccc'</span>).group(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 竖线 | 匹配左右任意一个表达式（和 [] 相似）</span></span><br><span class="line">print(re.match(<span class="string">r'aaa(xxx|yyy|zzz)bbb'</span>, <span class="string">'aaaxxxbbb'</span>).group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># \num 引用分组 num 匹配到的字符串</span></span><br><span class="line"><span class="comment">#       前后保证一致，要使用到分组！</span></span><br><span class="line">print(re.match(<span class="string">r'^&lt;(\w+)&gt;\w+&lt;/\1&gt;$'</span>, <span class="string">'&lt;html&gt;nihao&lt;/html&gt;'</span>).group())</span><br><span class="line">print(re.match(<span class="string">r'^&lt;(\w+)&gt;&lt;(\w+)&gt;\w+&lt;/\2&gt;&lt;/\1&gt;$'</span>, <span class="string">'&lt;html&gt;&lt;div&gt;nihao&lt;/div&gt;&lt;/html&gt;'</span>).group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># (?P&lt;name&gt;正则)  分组起别名</span></span><br><span class="line"><span class="comment"># (?P=name)      引用别名为name分组匹配到的字符串</span></span><br><span class="line">print(re.match(<span class="string">r'^&lt;(?P&lt;re1&gt;\w+)&gt;&lt;(?P&lt;re2&gt;\w+)&gt;\w+&lt;/(?P=re2)&gt;&lt;/(?P=re1)&gt;$'</span>, <span class="string">'&lt;html&gt;&lt;div&gt;jovelin&lt;/div&gt;&lt;/html&gt;'</span>).group())</span><br></pre></td></tr></table></figure><h3 id="五、正则高级-API（4个）"><a href="#五、正则高级-API（4个）" class="headerlink" title="五、正则高级 API（4个）"></a>五、正则高级 API（4个）</h3><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">search()</td><td style="text-align:left">搜索字符串中符合正则表达式的内容 -&gt; 只返回第一个</td></tr><tr><td style="text-align:center">findall()</td><td style="text-align:left">搜索字符串中符合正则表达式的内容 -&gt; 返回一个列表</td></tr><tr><td style="text-align:center">sub()</td><td style="text-align:left">替换字符串中符合正则的内容 -&gt; 替换后的字符串</td></tr><tr><td style="text-align:center">split()</td><td style="text-align:left">按照指定正则切割字符串 -&gt; 返回列表</td></tr></tbody></table><p>代码演示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.search()</span></span><br><span class="line">print(re.search(<span class="string">r"\d+"</span>, <span class="string">"aaa111bbb222ccc333ddd"</span>).group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.findall()</span></span><br><span class="line">print(re.findall(<span class="string">r"\d+"</span>, <span class="string">"aaa111bbb222ccc333ddd"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.sub()</span></span><br><span class="line">print(re.sub(<span class="string">r"\d+"</span>, <span class="string">"***"</span>, <span class="string">"aaa111bbb222ccc333ddd"</span>))</span><br><span class="line"><span class="comment"># sub(正则, 替换成***, 被操作的字符串, 替换次数)</span></span><br><span class="line">print(re.sub(<span class="string">r"\d+"</span>, <span class="string">"***"</span>, <span class="string">"aaa111bbb222ccc333ddd"</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.split()</span></span><br><span class="line">print(re.split(<span class="string">r"\d+"</span>, <span class="string">"aaa111bbb222ccc333ddd eee"</span>))</span><br><span class="line">print(re.split(<span class="string">r"\d+|\s"</span>, <span class="string">"aaa111bbb222ccc333ddd eee"</span>))</span><br></pre></td></tr></table></figure><h3 id="六、r-的作用"><a href="#六、r-的作用" class="headerlink" title="六、r 的作用"></a>六、r 的作用</h3><p>让程序把正则直接当做正则看；(不是从字符串开始解释)</p><figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line"># c:<span class="symbol">\a</span>aa<span class="symbol">\b</span>bb<span class="symbol">\c</span>cc</span><br><span class="line">print('c:<span class="symbol">\a</span>aa<span class="symbol">\b</span>bb<span class="symbol">\c</span>cc')</span><br><span class="line">print('c:<span class="symbol">\\</span>aaa<span class="symbol">\\</span>bbb<span class="symbol">\\</span>ccc')</span><br><span class="line"></span><br><span class="line"># 问题：在字符串中写 <span class="symbol">\ </span>时会转义，需要写成 <span class="symbol">\\</span></span><br><span class="line"># 不写 r 时 <span class="symbol">\\</span><span class="symbol">\\</span> -&gt; <span class="symbol">\\</span></span><br><span class="line">print(re.match('c:<span class="symbol">\\</span><span class="symbol">\\</span>aaa<span class="symbol">\\</span><span class="symbol">\\</span>bbb<span class="symbol">\\</span><span class="symbol">\\</span>ccc', 'c:<span class="symbol">\\</span>aaa<span class="symbol">\\</span>bbb<span class="symbol">\\</span>ccc').group())</span><br><span class="line"># 写 r 时 <span class="symbol">\\</span> -&gt; <span class="symbol">\\</span></span><br><span class="line">print(re.match(r'c:<span class="symbol">\\</span>aaa<span class="symbol">\\</span>bbb<span class="symbol">\\</span>ccc', 'c:<span class="symbol">\\</span>aaa<span class="symbol">\\</span>bbb<span class="symbol">\\</span>ccc').group())</span><br></pre></td></tr></table></figure><h3 id="七、贪婪-非贪婪"><a href="#七、贪婪-非贪婪" class="headerlink" title="七、贪婪/非贪婪"></a>七、贪婪/非贪婪</h3><p>贪婪：(量词在自己的范围内，取最多…)</p><p>非贪婪：(量词在自己的范围内，取最少… ) </p><p>非贪婪用法：量词后面加?</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'贪婪'</span>, re.match(<span class="string">r'a+'</span>, <span class="string">'aaa'</span>).group())  <span class="comment"># -&gt; aaa</span></span><br><span class="line"><span class="comment"># 量词后面加?</span></span><br><span class="line">print(<span class="string">'非贪婪'</span>, re.match(<span class="string">r'a+?'</span>, <span class="string">'aaa'</span>).group())  <span class="comment"># -&gt; a</span></span><br><span class="line">print(<span class="string">'贪婪'</span>, re.match(<span class="string">r'a&#123;1,2&#125;'</span>, <span class="string">'aaa'</span>).group())  <span class="comment"># -&gt; aa</span></span><br><span class="line"><span class="comment"># 量词后面加?</span></span><br><span class="line">print(<span class="string">'非贪婪'</span>, re.match(<span class="string">r'a&#123;1,3&#125;?'</span>, <span class="string">'aaa'</span>).group())  <span class="comment"># -&gt; a</span></span><br></pre></td></tr></table></figure><blockquote><p>更多参考内容： <a href="http://deerchao.net" target="_blank" rel="noopener">http://deerchao.net</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义；&lt;/li&gt;
&lt;li&gt;常用的元字符；&lt;/li&gt;
&lt;li&gt;常用的限定符（量词）；&lt;/li&gt;
&lt;li&gt;分组；&lt;/li&gt;
&lt;li&gt;正则高级 API（4个）；&lt;/li&gt;
&lt;li&gt;r 的作用；&lt;/li&gt;
&lt;li&gt;贪婪/非贪婪。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="正则表达式" scheme="http://jovelin.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 多任务-线程、进程与协程</title>
    <link href="http://jovelin.cn/2018/07/10/Python%20%E5%A4%9A%E4%BB%BB%E5%8A%A1-%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/"/>
    <id>http://jovelin.cn/2018/07/10/Python 多任务-线程、进程与协程/</id>
    <published>2018-07-09T16:20:12.000Z</published>
    <updated>2018-07-28T02:26:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>多线程；</li><li>多进程；</li><li>进程、线程对比；</li><li>多协程；</li><li>进程、线程、协程对比。</li></ol></blockquote><a id="more"></a><h1 id="Python-多任务-线程、进程与协程"><a href="#Python-多任务-线程、进程与协程" class="headerlink" title="Python 多任务-线程、进程与协程"></a>Python 多任务-线程、进程与协程</h1><p>什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。</p><h3 id="一、线程"><a href="#一、线程" class="headerlink" title="一、线程"></a>一、线程</h3><p>线程是进程的一个实体，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-4cf0e2846bad9723.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="进程和线程.png"></p><h4 id="并行-并发"><a href="#并行-并发" class="headerlink" title="并行/并发"></a>并行/并发</h4><p><img src="https://upload-images.jianshu.io/upload_images/3365001-9365b83598e8f764.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02-CPU及线程介绍.png"></p><p><strong>并发</strong></p><p>指的是任务数多余cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）</p><p><strong>并行</strong></p><p>指的是任务数小于等于cpu核数，即任务真的是一起执行的</p><h4 id="多线程图解"><a href="#多线程图解" class="headerlink" title="多线程图解"></a>多线程图解</h4><p><img src="https://upload-images.jianshu.io/upload_images/3365001-81ffaa2cf10ae661.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03-线程.png"></p><h4 id="共享全局变量与问题"><a href="#共享全局变量与问题" class="headerlink" title="共享全局变量与问题"></a>共享全局变量与问题</h4><p>在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据。</p><p><strong>问题</strong>：</p><p>如果多个线程同时对同一个全局变量操作，会出现资源竞争问题，从而数据结果会不正确。（即线程非安全）</p><h4 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h4><p>同步：单线程（从上到下依次执行顺序）</p><p>异步：多线程（开启多个任务一同执行，互不影响）</p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p><strong>当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制</strong>。</p><p><strong>锁的好处</strong>：</p><ul><li>确保了某段关键代码只能由一个线程从头到尾完整地执行</li></ul><p><strong>锁的坏处</strong>：</p><ul><li>阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了<br>由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁</li></ul><h4 id="死锁（一种-bug）"><a href="#死锁（一种-bug）" class="headerlink" title="死锁（一种 bug）"></a>死锁（一种 bug）</h4><p>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。</p><p><strong>避免死锁</strong></p><ul><li>程序设计时要尽量避免（银行家算法）</li><li>添加超时时间等</li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>1.多线程体验</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python 解释器中有一个模块专门控制线程，实现多任务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        print(<span class="string">"send msg"</span>, i + <span class="number">1</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive_msg</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        print(<span class="string">"receive msg"</span>, i + <span class="number">1</span>)</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建线程对象（target=函数名, name=线程别名, args=参数, kwargs=字典参数）</span></span><br><span class="line">    t1 = threading.Thread(target=send_msg, name=<span class="string">"send"</span>, args=(<span class="number">3</span>,))</span><br><span class="line">    t2 = threading.Thread(target=receive_msg, name=<span class="string">"receive"</span>, kwargs=&#123;<span class="string">"num"</span>: <span class="number">3</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 三个 API</span></span><br><span class="line">    print(threading.enumerate())</span><br><span class="line">    print(threading.current_thread())</span><br><span class="line">    print(threading.active_count())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 守护线程</span></span><br><span class="line">    t1.setDaemon(<span class="keyword">True</span>)</span><br><span class="line">    t2.setDaemon(<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开启线程</span></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 线程等待</span></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"*** main thread ***"</span>)</span><br></pre></td></tr></table></figure><p>2.自定义线程类</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendThread</span>(<span class="title">threading</span>.<span class="title">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, num)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="comment"># threading.Thread.__init__(self)</span></span><br><span class="line">        <span class="keyword">super</span>(SendThread, <span class="keyword">self</span>).__init_<span class="number">_</span>()</span><br><span class="line">        <span class="comment"># super().__init__()</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.num = num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)<span class="symbol">:</span></span><br><span class="line">            print(<span class="string">"send msg"</span>, i + <span class="number">1</span>)</span><br><span class="line">            time.sleep(<span class="number">0</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.send_msg()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiveThread</span>(<span class="title">threading</span>.<span class="title">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive_msg</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)<span class="symbol">:</span></span><br><span class="line">            print(<span class="string">"receive msg"</span>, i + <span class="number">1</span>)</span><br><span class="line">            time.sleep(<span class="number">0</span>.<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.receive_msg()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    t1 = SendThread(<span class="number">3</span>)</span><br><span class="line">    t2 = ReceiveThread()</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"*** main thread ***"</span>)</span><br></pre></td></tr></table></figure><h3 id="二、进程"><a href="#二、进程" class="headerlink" title="二、进程"></a>二、进程</h3><p>运行的程序以及运行时用到的资源这个整体称之为进程，是系统进行资源分配和调度的一个独立单位。</p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-4e2b4618127c7d94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01-进程.png"></p><h4 id="进程间通信-Queue"><a href="#进程间通信-Queue" class="headerlink" title="进程间通信-Queue"></a>进程间通信-Queue</h4><p>进程间通信：运行的程序之间的数据共享。</p><h3 id="三、进程、线程对比"><a href="#三、进程、线程对比" class="headerlink" title="三、进程、线程对比"></a>三、进程、线程对比</h3><p>功能</p><ul><li>进程，能够完成多任务，比如 在一台电脑上能够同时运行多个 QQ。</li><li>线程，能够完成多任务，比如 一个 QQ 中的多个聊天窗口。</li></ul><p>定义的不同</p><ul><li>进程是系统进行资源分配和调度的一个独立单位。</li><li>线程是进程的一个实体，是 CPU  调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</li><li>线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</li></ul><p>区别</p><ul><li>一个程序至少有一个进程，一个进程至少有一个线程。</li><li>线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高。</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率，</li><li>线线程不能够独立执行，必须依存在进程中。</li><li>可以将进程理解为工厂中的一条流水线，而其中的线程就是这个流水线上的工人。</li></ul><p>优缺点</p><ul><li>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。</li></ul><h3 id="四、协程"><a href="#四、协程" class="headerlink" title="四、协程"></a>四、协程</h3><p>协程，又称微线程，纤程。英文名Coroutine。</p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-d37fbaaca0679c6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02-协程.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-8f26f1b69124ba7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03-迭代器和生成器.png"></p><h4 id="greenlet"><a href="#greenlet" class="headerlink" title="greenlet"></a>greenlet</h4><p>为了更好使用协程来完成多任务，python中的greenlet模块对其封装，从而使得切换任务变的更加简单</p><p><strong>安装方式</strong></p><p>使用如下命令安装 greenlet 模块:</p><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">pip3 list: 验证已安装的python第三方插件（如果没有pip3会提示安装）</span><br><span class="line"></span><br><span class="line">sudo pip3 install greenlet</span><br></pre></td></tr></table></figure><h4 id="gevent"><a href="#gevent" class="headerlink" title="gevent"></a>gevent</h4><p>greenlet已经实现了协程，但是这个还的人工切换，是不是觉得太麻烦了，不要捉急，python还有一个比greenlet更强大的并且能够自动切换任务的模块gevent</p><p>其原理是当一个greenlet遇到IO(指的是input output 输入输出，比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。</p><p>由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO</p><p><strong>安装方式</strong></p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip3 <span class="keyword">install</span> gevent</span><br></pre></td></tr></table></figure><h4 id="协程和线程差异"><a href="#协程和线程差异" class="headerlink" title="协程和线程差异"></a>协程和线程差异</h4><p>在实现多任务时, 线程切换从系统层面远不止保存和恢复 CPU 上下文这么简单。</p><p>操作系统为了程序运行的高效性每个线程都有自己缓存 Cache 等等数据，操作系统还会帮你做这些数据的恢复操作。所以线程的切换非常耗性能。</p><p>但是协程的切换只是单纯的操作 CPU 的上下文，所以一秒钟切换个上百万次系统都抗的住。</p><h3 id="五、进程、线程、协程对比"><a href="#五、进程、线程、协程对比" class="headerlink" title="五、进程、线程、协程对比"></a>五、进程、线程、协程对比</h3><ol><li>进程是资源分配的单位</li><li>线程是操作系统调度的单位</li><li>进程切换需要的资源很最大，效率很低</li><li>线程切换需要的资源一般，效率一般（当然了在不考虑GIL的情况下）</li><li>协程切换任务资源很小，效率高</li><li>多进程、多线程根据cpu核数不一样可能是并行的，但是协程是在一个线程中 所以是并发</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多线程；&lt;/li&gt;
&lt;li&gt;多进程；&lt;/li&gt;
&lt;li&gt;进程、线程对比；&lt;/li&gt;
&lt;li&gt;多协程；&lt;/li&gt;
&lt;li&gt;进程、线程、协程对比。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="多任务" scheme="http://jovelin.cn/tags/%E5%A4%9A%E4%BB%BB%E5%8A%A1/"/>
    
      <category term="线程" scheme="http://jovelin.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="进程" scheme="http://jovelin.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="协程" scheme="http://jovelin.cn/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python 网络通信-udp、tcp 与 socket</title>
    <link href="http://jovelin.cn/2018/07/08/Python%20%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1-udp%E3%80%81tcp%20%E4%B8%8E%20socket/"/>
    <id>http://jovelin.cn/2018/07/08/Python 网络通信-udp、tcp 与 socket/</id>
    <published>2018-07-07T16:21:11.000Z</published>
    <updated>2018-07-28T02:21:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：</p><ol><li>UDP 和 TCP 及 socket 介绍；</li><li>网络七层协议(四/五层模型)；</li><li>IP 地址与端口；</li><li>Python3 编码转换；</li><li>Socket 套接字；</li><li>UDP 协议；</li><li>TCP 协议。</li></ol></blockquote><a id="more"></a><h1 id="Python-网络通信"><a href="#Python-网络通信" class="headerlink" title="Python 网络通信"></a>Python 网络通信</h1><h3 id="一、UDP-和-TCP-及-socket-介绍"><a href="#一、UDP-和-TCP-及-socket-介绍" class="headerlink" title="一、UDP 和 TCP 及 socket 介绍"></a>一、UDP 和 TCP 及 socket 介绍</h3><p><strong>注意：udp 和 tcp 都是网络传输的协议，只不过具体传输形式不一样，但功能都是定义网络传输数据规则。</strong></p><p><strong>udp 和 tcp (发短信和打电话)(不同: 是否创建链接)</strong></p><ol><li><p><strong>udp 是用户数据报协议</strong>，UDP(User Datagram Protocol)不能保证数据的准确性和有效性。<br>(数据报:是通过网络传输的数据的基本单元) </p></li><li><p><strong>tcp 是传输控制协议</strong>，TCP(Transmission Control Protocol)能保证数据的准确性和有效性。<br>(和udp差不多依靠socket技术)</p></li><li><p><strong>socket 就是具体实现 tcp 和 udp 的底层技术(也称套接字/流对象)</strong>(不在网络七层协议之列-因为是技术不是协议)</p></li></ol><h3 id="二、网络七层协议-四-五层模型"><a href="#二、网络七层协议-四-五层模型" class="headerlink" title="二、网络七层协议(四/五层模型)"></a>二、网络七层协议(四/五层模型)</h3><p><img src="https://upload-images.jianshu.io/upload_images/3365001-893eb6882ef825ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="七层协议1.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-03725767e52c896a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="七层协议2.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-d812e52bc2dc7743.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络七层协议.png"></p><h3 id="三、IP-地址与端口"><a href="#三、IP-地址与端口" class="headerlink" title="三、IP 地址与端口"></a>三、IP 地址与端口</h3><p>网络通信过程中，之所需要ip、port等，就是为了能够将一个复杂的通信过程进行任务划分，从而保证数据准确无误的传递。</p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-5d9168459fadd31a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ip和端口.png"></p><h4 id="ip-地址"><a href="#ip-地址" class="headerlink" title="ip 地址"></a>ip 地址</h4><p>作用：用来在网络中标记一台电脑，比如 192．168．1．1 在本地局域网上是唯一的。</p><p>注意：IP 地址 127．0．0．1~127．255．255．255 用于回路测试</p><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>端口是通过端口号来标记的，端口号只有整数，范围是从0到65535</p><h5 id="知名端口"><a href="#知名端口" class="headerlink" title="知名端口"></a>知名端口</h5><p>众所周知的端口号，范围从0到1023</p><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">80 </span>端口分配给HTTP服务</span><br><span class="line"><span class="symbol">21 </span>端口分配给FTP服务</span><br></pre></td></tr></table></figure><h5 id="动态端口"><a href="#动态端口" class="headerlink" title="动态端口"></a>动态端口</h5><p>范围是从1024到65535</p><h5 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h5><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">netstat －an 查看端口状态</span><br><span class="line">lsof -<span class="selector-tag">i</span>:port 查看端口占用</span><br></pre></td></tr></table></figure><h3 id="四、Python3-编码转换"><a href="#四、Python3-编码转换" class="headerlink" title="四、Python3 编码转换"></a>四、Python3 编码转换</h3><p>str-&gt;bytes:encode编码</p><p>bytes-&gt;str:decode解码</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding: 在解码编码过程中使用的编码(此处指“编码方案”是名词)</span></span><br><span class="line"><span class="comment"># errors: 错误的处理方案</span></span><br><span class="line">bytes.decode(<span class="attribute">encoding</span>=<span class="string">"utf-8"</span>, <span class="attribute">errors</span>=<span class="string">"strict"</span>)</span><br><span class="line">str.encode(<span class="attribute">encoding</span>=<span class="string">"utf-8"</span>, <span class="attribute">errors</span>=<span class="string">"strict"</span>)</span><br></pre></td></tr></table></figure><p>详细的可以参照官方文档：</p><p><a href="https://docs.python.org/3/library/stdtypes.html?highlight=decode#str.encode" target="_blank" rel="noopener">str.encode()</a></p><p><a href="https://docs.python.org/3/library/stdtypes.html?highlight=decode#bytes.decode" target="_blank" rel="noopener">bytes.decode()</a></p><h3 id="五、Socket-套接字"><a href="#五、Socket-套接字" class="headerlink" title="五、Socket 套接字"></a>五、Socket 套接字</h3><p><strong>socket(简称 套接字也成为插口–流对象)</strong> 是进程间通信的一种方式，它与其他进程间通信的一个主要不同是：</p><p>它能实现不同主机间的进程间通信，我们网络上各种各样的服务大多都是基于 Socket 来完成通信的。</p><p>例如我们每天浏览网页、QQ 聊天、收发 email 等等。</p><h4 id="Socket-反问理解"><a href="#Socket-反问理解" class="headerlink" title="Socket 反问理解"></a>Socket 反问理解</h4><p>———start———</p><p><strong>what 是什么</strong>？（概念、理解）</p><p>socket(简称 套接字 也称为插口–流对象) 是进程间通信的一种方式</p><p><br></p><p><strong>why 为什么用</strong>？（用它的好处，特点/不同点）</p><p>是实现tcp和udp的底层技术，能实现 不同主机间 的进程间通信</p><p><br></p><p><strong>where 在哪使用</strong>？（案例、项目）</p><p>网络程序发送、接收数据（发短信、打电话、广播）</p><p>————end————</p><h3 id="六、UDP-协议"><a href="#六、UDP-协议" class="headerlink" title="六、UDP 协议"></a>六、UDP 协议</h3><p>udp 是用户数据报协议，UDP (User Datagram Protocol) 不能保证数据的准确性和有效性。 (数据报:是通过网络传输的数据的基本单元)</p><p>udp 通信模型中，在通信开始之前，不需要建立相关的链接，只需要发送数据即可，类似于生活中，”写信/发短信”</p><p>python 使用 udp 协议要通过 socket 技术:</p><pre><code>使用步骤：1.引包 2.创建流对象(ipv4, udp) 3.发送(二进制字符串, 元组ip和端口) 4.关闭流对象</code></pre><p>创建 socket 语法</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Address Family：可以选择 AF_INET（用于 Internet 进程间通信） 或者 AF_UNIX（用于同一台机器进程间通信）,实际工作中常用AF_INET</span></span><br><span class="line"><span class="comment"># Type：套接字类型，可以是 SOCK_STREAM（流式套接字，主要用于 TCP 协议）或者 SOCK_DGRAM（数据报套接字，主要用于 UDP 协议）</span></span><br><span class="line"></span><br><span class="line">import <span class="built_in">socket</span></span><br><span class="line">    <span class="built_in">socket</span>.<span class="built_in">socket</span>(AddressFamily, Type)</span><br></pre></td></tr></table></figure><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>1.udp 发送</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.引包</span></span><br><span class="line">import <span class="built_in">socket</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 2.创建流对象(ipv4, udp)</span></span><br><span class="line">    <span class="comment"># socket是一个模块</span></span><br><span class="line">    <span class="comment"># socket.socket是一个类</span></span><br><span class="line">    <span class="comment">#   socket.AF_INET: 这个socket数据传世用ipv4;</span></span><br><span class="line">    <span class="comment">#   socket.SOCK_DGRAM: 这个socket使用udp协议进行数据传输;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># socket对象(套接字);    插口 -- 流对象(就要关闭 -- 发送和接收信息)</span></span><br><span class="line">    udp_socket = <span class="built_in">socket</span>.<span class="built_in">socket</span>(<span class="built_in">socket</span>.AF_INET, <span class="built_in">socket</span>.SOCK_DGRAM)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3.发送(二进制字符串, 元组ip和端口)</span></span><br><span class="line">    str1 = <span class="string">'你好,我是udp协议发送的测试数据...'</span></span><br><span class="line">    tuple1 = (<span class="string">'192.168.1.1'</span>, <span class="number">8888</span>)</span><br><span class="line">    udp_socket.sendto(str1.encode(<span class="string">'utf-8'</span>), tuple1)</span><br><span class="line">    print(tuple1, <span class="string">'发送成功!'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4.关闭流对象</span></span><br><span class="line">    udp_socket.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><p>2.udp 接收（主动接收方需手动绑定端口，发送方才知道发送给谁）</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">socket</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 1.创建套接字对象</span></span><br><span class="line">    udp_socket = <span class="built_in">socket</span>.<span class="built_in">socket</span>(<span class="built_in">socket</span>.AF_INET, <span class="built_in">socket</span>.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 绑定本地的相关信息，如果一个网络程序不绑定，则系统会随机分配</span></span><br><span class="line">    local_addr = (<span class="string">''</span>, <span class="number">8888</span>) <span class="comment">#  ip地址和端口号，ip一般不用写，表示本机的任何一个ip</span></span><br><span class="line">    udp_socket.bind(local_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.数据接收( recvfrom() )</span></span><br><span class="line">    <span class="comment">#       参数: 最多一次性接收1024字节;</span></span><br><span class="line">    <span class="comment">#       返回值: 一个元组(二进制数据, ip及port组成的元组)</span></span><br><span class="line">    <span class="comment">#       recvfrom(): 可以阻塞代码!( 类似input() )</span></span><br><span class="line">    <span class="comment">#       发送和接收数据的时候,udp承受的最大上线为: 64k</span></span><br><span class="line">    str2, tuple2 = udp_socket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    print(str2)</span><br><span class="line">    print(tuple2)</span><br><span class="line">    print(str2.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="comment"># print(str2.decode('gbk'))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4.关闭套接字</span></span><br><span class="line">    udp_socket.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><p>3.udp 聊天器</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">说明：在一个电脑中编写1个程序，有2个功能：</span></span><br><span class="line"><span class="string">    1.获取键盘数据，并将其发送给对方</span></span><br><span class="line"><span class="string">    2.接收数据并显示</span></span><br><span class="line"><span class="string">    并且功能数据进行选择以上的2个功能调用</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(udp_socket)</span>:</span></span><br><span class="line">    <span class="string">"""获取键盘数据，并将其发送给对方"""</span></span><br><span class="line">    <span class="comment"># 1. 从键盘输入数据</span></span><br><span class="line">    msg = input(<span class="string">"\n请输入要发送的数据:"</span>)</span><br><span class="line">    <span class="comment"># 2. 输入对方的ip地址</span></span><br><span class="line">    dest_ip = input(<span class="string">"\n请输入对方的ip地址:"</span>)</span><br><span class="line">    <span class="comment"># 3. 输入对方的port</span></span><br><span class="line">    dest_port = int(input(<span class="string">"\n请输入对方的port:"</span>))</span><br><span class="line">    <span class="comment"># 4. 发送数据</span></span><br><span class="line">    udp_socket.sendto(msg.encode(<span class="string">"utf-8"</span>), (dest_ip, dest_port))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_msg</span><span class="params">(udp_socket)</span>:</span></span><br><span class="line">    <span class="string">"""接收数据并显示"""</span></span><br><span class="line">    <span class="comment"># 1. 接收数据</span></span><br><span class="line">    recv_msg = udp_socket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># 2. 解码</span></span><br><span class="line">    recv_ip = recv_msg[<span class="number">1</span>]</span><br><span class="line">    recv_msg = recv_msg[<span class="number">0</span>].decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    <span class="comment"># 3. 显示接收到的数据</span></span><br><span class="line">    print(<span class="string">"&gt;&gt;&gt;%s:%s"</span> % (str(recv_ip), recv_msg))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 1. 创建套接字</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">    <span class="comment"># 2. 绑定本地信息</span></span><br><span class="line">    udp_socket.bind((<span class="string">""</span>, <span class="number">7890</span>))</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># 3. 选择功能</span></span><br><span class="line">        print(<span class="string">"="</span>*<span class="number">30</span>)</span><br><span class="line">        print(<span class="string">"1:发送消息"</span>)</span><br><span class="line">        print(<span class="string">"2:接收消息"</span>)</span><br><span class="line">        print(<span class="string">"="</span>*<span class="number">30</span>)</span><br><span class="line">        op_num = input(<span class="string">"请输入要操作的功能序号:"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4. 根据选择调用相应的函数</span></span><br><span class="line">        <span class="keyword">if</span> op_num == <span class="string">"1"</span>:</span><br><span class="line">            send_msg(udp_socket)</span><br><span class="line">        <span class="keyword">elif</span> op_num == <span class="string">"2"</span>:</span><br><span class="line">            recv_msg(udp_socket)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"输入有误，请重新输入..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="七、TCP-协议"><a href="#七、TCP-协议" class="headerlink" title="七、TCP 协议"></a>七、TCP 协议</h3><p>TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。</p><p>TCP通信需要经过 <strong>创建连接、数据传送、终止连接</strong> 三个步骤。</p><p>TCP通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，”打电话””</p><h4 id="TCP-特点"><a href="#TCP-特点" class="headerlink" title="TCP 特点"></a>TCP 特点</h4><p><strong>1.面向连接</strong></p><ol><li>通信双方必须先建立连接才能进行数据的传输，双方都必须为该连接分配必要的系统内核资源，以管理连接的状态和连接上的传输。</li><li><strong>TCP不适用于广播的应用程序，基于广播的应用程序请使用UDP协议。</strong></li></ol><p><strong>2.可靠传输</strong></p><ol><li>TCP采用发送应答机制<ul><li>TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文段传输成功</li></ul></li><li>超时重传<ul><li>发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段。</li><li>TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。</li></ul></li><li>错误校验<ul><li>TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。</li></ul></li><li>流量控制和阻塞管理<ul><li>流量控制用来避免主机发送得过快而使接收方来不及完全收下。</li></ul></li></ol><h4 id="tcp-注意点"><a href="#tcp-注意点" class="headerlink" title="tcp 注意点"></a>tcp 注意点</h4><ol><li>tcp服务器一般情况下都需要绑定ip和端口，否则客户端找不到这个服务器及其服务对应的端口</li><li>tcp客户端一般不绑定，因为是主动链接服务器，所以只要确定好服务器的ip、port等信息就好，本地客户端可以随机</li><li>tcp服务器中通过listen可以将socket创建出来的主动套接字变为被动的，这是做tcp服务器时必须要做的</li><li>当客户端需要链接服务器时，就需要使用connect进行链接，udp是不需要链接的而是直接发送，但是tcp必须先链接，只有链接成功才能通信</li><li>当一个tcp客户端连接服务器时，服务器端会有1个新的套接字，这个套接字用来标记这个客户端，单独为这个客户端服务</li><li>listen后的套接字是被动套接字，用来接收新的客户端的链接请求的，而accept返回的新套接字是标记这个新客户端的</li><li>关闭listen后的套接字意味着被动套接字关闭了，会导致新的客户端不能够链接服务器，但是之前已经链接成功的客户端正常通信。</li><li>关闭accept返回的套接字意味着这个客户端已经服务完毕</li><li>当客户端的套接字调用close后，服务器端会recv解堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来区别客户端是否已经下线</li><li>空字符串能够直接发送不能够直接接收(tcp服务端会过滤)</li></ol><h4 id="tcp-三次握手和四次挥手"><a href="#tcp-三次握手和四次挥手" class="headerlink" title="tcp 三次握手和四次挥手"></a>tcp 三次握手和四次挥手</h4><h5 id="tcp-三次握手图解"><a href="#tcp-三次握手图解" class="headerlink" title="tcp 三次握手图解"></a>tcp 三次握手图解</h5><p><img src="https://upload-images.jianshu.io/upload_images/3365001-3f3bcc28ca39fa1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tcp三次握手1.png"></p><table><thead><tr><th>标志位</th><th>序号</th></tr></thead><tbody><tr><td>SYN: 表示连接请求</td><td>seq:表示报文序号</td></tr><tr><td>ACK: 表示确认</td><td>ack: 表示确认号</td></tr><tr><td>FIN:  表示关闭连接</td><td></td></tr></tbody></table><p><img src="https://upload-images.jianshu.io/upload_images/3365001-4203e495de645009.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="tcp三次握手.png"></p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）第一次握手：<span class="built_in">Client</span>将标志位SYN置为<span class="number">1</span>，随机产生一个值seq=J，并将该数据包发送给<span class="built_in">Server</span>，<span class="built_in">Client</span>进入SYN_SENT状态，等待<span class="built_in">Server</span>确认。</span><br><span class="line">（<span class="number">2</span>）第二次握手：<span class="built_in">Server</span>收到数据包后由标志位SYN=<span class="number">1</span>知道<span class="built_in">Client</span>请求建立连接，<span class="built_in">Server</span>将标志位SYN和ACK都置为<span class="number">1</span>， ack (number )=J+<span class="number">1</span>，随机产生一个值seq=K，并将该数据包发送给<span class="built_in">Client</span>以确认连接请求，<span class="built_in">Server</span>进入SYN_RCVD状态。</span><br><span class="line">（<span class="number">3</span>）第三次握手：<span class="built_in">Client</span>收到确认后，检查ack是否为J+<span class="number">1</span>，ACK是否为<span class="number">1</span>，如果正确则将标志位ACK置为<span class="number">1</span>，ack=K+<span class="number">1</span>，并将该数据包发送给<span class="built_in">Server</span>，<span class="built_in">Server</span>检查ack是否为K+<span class="number">1</span>，ACK是否为<span class="number">1</span>，如果正确则连接建立成功，<span class="built_in">Client</span>和<span class="built_in">Server</span>进入ESTABLISHED状态，完成三次握手，随后<span class="built_in">Client</span>与<span class="built_in">Server</span>之间可以开始传输数据了。</span><br><span class="line"></span><br><span class="line">理解总结：</span><br><span class="line"><span class="number">1.</span>客户端发起连接请求，等待服务端确定</span><br><span class="line"><span class="number">2.</span>服务端确认连接请求</span><br><span class="line"><span class="number">3.</span>客户端收到确认后，再次发送数据包验证（验证正确，连接成功，完成三次握手）</span><br></pre></td></tr></table></figure><h5 id="tcp-四次挥手图解"><a href="#tcp-四次挥手图解" class="headerlink" title="tcp 四次挥手图解"></a>tcp 四次挥手图解</h5><p><img src="https://upload-images.jianshu.io/upload_images/3365001-e77fdb8210af7052.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tcp四次挥手.png"></p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">客户端主动关闭（三次挥手）：</span><br><span class="line">（<span class="number">1</span>）第一次挥手：客户端发送一个FIN，用来关闭客户端到服务的数据传送。</span><br><span class="line">（<span class="number">2</span>）第二次挥手：服务端发送一个ACK，用来关闭服务端到客户端的数据传送。</span><br><span class="line">（<span class="number">3</span>) 第三次挥手：客户端收到ACK后，接着发送一个ACK给服务端，确认序号为收到序号+<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">服务端主动关闭（四次挥手）：</span><br><span class="line">（<span class="number">1</span>）第一次挥手：server发送一个FIN，用来关闭server到client的数据传送。</span><br><span class="line">（<span class="number">2</span>) 第二次挥手：client收到FIN后，发送一个ACK给server，确认序号为收到序号+<span class="number">1</span>。</span><br><span class="line">（<span class="number">3</span>）第三次挥手：client发送一个FIN，用来关闭Client到Server的数据传送。</span><br><span class="line">（<span class="number">4</span>) 第四次挥手：Server收到FIN后，接着发送一个ACK给Client，确认序号为收到序号+<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">理解总结：</span><br><span class="line"><span class="number">1.</span>服务端 close()（我要关闭连接了）</span><br><span class="line"><span class="number">2.</span>客户端收到后发送一条消息（别急，事情还没处理完...）</span><br><span class="line"><span class="number">3.</span>客户端处理完成后 close()（可以关闭连接了）</span><br><span class="line"><span class="number">4.</span>服务端接着发送一个 ACK 给 Client（连接已关闭！四次挥手完成）</span><br></pre></td></tr></table></figure><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p>1.tcp 客户端</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">from socket import *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建socket</span></span><br><span class="line">tcp_client_socket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目的信息</span></span><br><span class="line">server_ip = input(<span class="string">"请输入服务器ip:"</span>)</span><br><span class="line">server_port = int(input(<span class="string">"请输入服务器port:"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接服务器</span></span><br><span class="line">tcp_client_socket.connect((server_ip, server_port))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示用户输入数据</span></span><br><span class="line">send_data = input(<span class="string">"请输入要发送的数据："</span>)</span><br><span class="line"></span><br><span class="line">tcp_client_socket.send(send_data.encode(<span class="string">"gbk"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收对方发送过来的数据，最大接收1024个字节</span></span><br><span class="line">recvData = tcp_client_socket.recv(1024)</span><br><span class="line"><span class="section">print('接收到的数据为:', recvData.decode('gbk'))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭套接字</span></span><br><span class="line">tcp_client_socket.close()</span><br></pre></td></tr></table></figure><p>2.tcp 服务端</p><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">步骤：</span></span><br><span class="line"><span class="string">    1.socket创建一个套接字</span></span><br><span class="line"><span class="string">    2.bind绑定ip和port</span></span><br><span class="line"><span class="string">    3.listen使套接字变为可以被动链接</span></span><br><span class="line"><span class="string">    4.accept等待客户端的链接</span></span><br><span class="line"><span class="string">    5.recv/send接收发送数据</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">from socket import *</span><br><span class="line"></span><br><span class="line"><span class="meta"># 创建socket</span></span><br><span class="line">tcp_server_socket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="meta"># 本地信息</span></span><br><span class="line">address = (<span class="string">''</span>, <span class="number">7788</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta"># 绑定</span></span><br><span class="line">tcp_server_socket.bind(address)</span><br><span class="line"></span><br><span class="line"><span class="meta"># 使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收别人的链接了</span></span><br><span class="line">tcp_server_socket.listen(<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务</span></span><br><span class="line"><span class="meta"># client_socket用来为这个客户端服务</span></span><br><span class="line"><span class="meta"># tcp_server_socket就可以省下来专门等待其他新客户端的链接</span></span><br><span class="line">client_socket, clientAddr = tcp_server_socket.accept()</span><br><span class="line"></span><br><span class="line"><span class="meta"># 接收对方发送过来的数据</span></span><br><span class="line">recv_data = client_socket.recv(<span class="number">1024</span>)  # 接收<span class="number">1024</span>个字节</span><br><span class="line">print(<span class="string">'接收到的数据为:'</span>, recv_data.decode(<span class="string">'gbk'</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta"># 发送一些数据到客户端</span></span><br><span class="line">client_socket.send(<span class="string">"thank you !"</span>.encode(<span class="string">'gbk'</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta"># 关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了，如果还需要服务，只能再次重新连接</span></span><br><span class="line">client_socket.close()</span><br></pre></td></tr></table></figure><h3 id="八、TCP-与-UDP-的不同点"><a href="#八、TCP-与-UDP-的不同点" class="headerlink" title="八、TCP 与 UDP 的不同点"></a>八、TCP 与 UDP 的不同点</h3><p><strong>TCP：</strong></p><ul><li>面向连接（确认有创建三方交握，连接已创建才作传输。）</li><li>有序数据传输</li><li>重发丢失的数据包</li><li>舍弃重复的数据包</li><li>无差错的数据传输</li><li>阻塞/流量控制</li></ul><p><strong>UDP 通信模型（类似于写信/发短信/广播/视频聊天）</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-66f6ee5be9f9df0f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="udp通信模型.jpg"></p><p><strong>TCP 通信模型（类似于打电话）</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-55244b661df4c1a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP通信模型.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UDP 和 TCP 及 socket 介绍；&lt;/li&gt;
&lt;li&gt;网络七层协议(四/五层模型)；&lt;/li&gt;
&lt;li&gt;IP 地址与端口；&lt;/li&gt;
&lt;li&gt;Python3 编码转换；&lt;/li&gt;
&lt;li&gt;Socket 套接字；&lt;/li&gt;
&lt;li&gt;UDP 协议；&lt;/li&gt;
&lt;li&gt;TCP 协议。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="udp" scheme="http://jovelin.cn/tags/udp/"/>
    
      <category term="tcp" scheme="http://jovelin.cn/tags/tcp/"/>
    
      <category term="socket" scheme="http://jovelin.cn/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>反问学习法（what、why、where），十万个为什么</title>
    <link href="http://jovelin.cn/2018/07/06/%E5%8F%8D%E9%97%AE%E5%AD%A6%E4%B9%A0%E6%B3%95%EF%BC%88what%E3%80%81why%E3%80%81where%EF%BC%89%EF%BC%8C%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88/"/>
    <id>http://jovelin.cn/2018/07/06/反问学习法（what、why、where），十万个为什么/</id>
    <published>2018-07-06T02:13:37.000Z</published>
    <updated>2018-07-18T11:49:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/3365001-b563404345271200.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="why.jpg"></p><p>不知道你们有没有这样的感受，就是当学完了一个知识点，可能知道怎么用、知道写代码的步骤（像套模板一样，按照案例、步骤一步步码出来），反正就是代码我能写出来，但是这个知识点是什么？为什么用它？在哪里使用这个知识点？往往就不是很清楚，有点印象、模模糊糊，理解不透彻。</p><a id="more"></a><p>平常工作的话，知道怎么用、知道怎么实现该功能，反正能完成任务即可，管它那么多！</p><p>那么问题来了，既然平常工作都没什么问题，还管它那么多干啥呢干啥呢。。</p><p><strong>原因有两点：</strong></p><p>一、深度掌握（用起来得心应手）</p><p>不只是照抄搬运，不是所有事情 copy 就能实现，要合理利用以前写过的案例，实现过的项目功能，懂得哪些地方能抄，也要懂得想改哪里就改哪里（就像一个人物换了个皮肤，相同点还是不变的，不同点就需要自己去发现去改造了，比如：变好看了，攻击变强了。。）</p><p>二、面试</p><p>大家都知道一个完整的面试包括三个流程（1、笔试 2、技术面试 3、hr面谈）</p><p>当然也有不用笔试的，2轮技术面试的也有，没有 hr 面谈的也大有存在，CTO 直接就能决定你的薪资，这也是小公司和大公司的一种差异</p><p>1.笔试：也就类似我们平常的考试，选择题、大题都有，只不过是综合的罢了（基础）</p><p>2.技术面谈：</p><ol><li>就你写的技术进行提问（一般有三种掌握程度，了解/熟练/精通）</li><li><p>项目上的提问（实现的过程、某个难点技术、碰到的 bug、团队开发遇到的问题都有。。）</p><p> 这就不仅仅是 知道怎么用、知道怎么实现该功能 就能过关了，和下面演示的 3个W反问 有关系了。</p></li><li><p>hr 面谈（恭喜你基本已经被录用了，谈工资这一块了，砍价、福利。。）</p></li></ol><blockquote><p>知识点分类：</p><p>1.死知识（不用死记硬背，API 文档、笔记、博客查阅即可） </p><p>2.理解性知识（理解实现原理，懂得框架，实现时灵活运用）</p></blockquote><p><strong>以 socket 知识点为例：</strong></p><p>———socket———</p><p>what<br>是什么？（概念、理解）</p><p>socket(简称 套接字 也称为插口–流对象) 是进程间通信的一种方式</p><p>why<br>为什么用？（好处，特点即不同点）</p><p>是实现tcp和udp的底层技术，实现 不同主机间 的进程间通信</p><p>where<br>在哪使用？（案例、实战）</p><p>网络程序发送、接收数据（发短信、打电话、广播）</p><p>————end————</p><blockquote><p>人生苦短，我用 Python，为何你要用 Python？———杠精</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3365001-b563404345271200.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;why.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;不知道你们有没有这样的感受，就是当学完了一个知识点，可能知道怎么用、知道写代码的步骤（像套模板一样，按照案例、步骤一步步码出来），反正就是代码我能写出来，但是这个知识点是什么？为什么用它？在哪里使用这个知识点？往往就不是很清楚，有点印象、模模糊糊，理解不透彻。&lt;/p&gt;
    
    </summary>
    
      <category term="学习方法" scheme="http://jovelin.cn/categories/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="学习方法" scheme="http://jovelin.cn/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux 终端命令</title>
    <link href="http://jovelin.cn/2018/07/03/Linux%20%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/"/>
    <id>http://jovelin.cn/2018/07/03/Linux 终端命令/</id>
    <published>2018-07-03T01:00:01.000Z</published>
    <updated>2018-07-28T02:50:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux-终端命令"><a href="#Linux-终端命令" class="headerlink" title="Linux 终端命令"></a>Linux 终端命令</h3><h4 id="01-终端命令格式"><a href="#01-终端命令格式" class="headerlink" title="01. 终端命令格式"></a>01. 终端命令格式</h4><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">command <span class="string">[-options]</span> <span class="string">[parameter]</span></span><br><span class="line">    command：命令名，相应功能的英文单词或单词的缩写</span><br><span class="line">    <span class="string">[-options]</span>：选项，可用来对命令进行控制，也可以省略</span><br><span class="line">    <span class="string">[parameter]</span>：传给命令的参数，可以是 零个、一个 或者 多个</span><br></pre></td></tr></table></figure><h4 id="02-查阅命令帮助信息"><a href="#02-查阅命令帮助信息" class="headerlink" title="02. 查阅命令帮助信息"></a>02. 查阅命令帮助信息</h4><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="number">2.1</span> <span class="comment">--help</span></span><br><span class="line">    <span class="keyword">command</span> --<span class="title">help</span></span><br><span class="line">    显示 <span class="keyword">command</span> 命令的帮助信息</span><br><span class="line"></span><br><span class="line"><span class="number">2.2</span> man</span><br><span class="line">    man <span class="keyword">command</span></span><br><span class="line">    查阅 <span class="keyword">command</span> 命令的使用手册</span><br><span class="line">    </span><br><span class="line">    man 是 manual 的缩写，是 Linux 提供的一个手册，包含了绝大部分的命令、函数的详细使用说明</span><br><span class="line"></span><br><span class="line">    使用 man 时的操作键：</span><br><span class="line">        空格键：显示手册页的下一屏</span><br><span class="line">        Enter 键：一次滚动手册页的一行</span><br><span class="line">        b：回滚一屏</span><br><span class="line">        f：前滚一屏</span><br><span class="line">        q：退出</span><br><span class="line">        /<span class="built_in">word</span>：搜索 <span class="built_in">word</span> 字符串</span><br></pre></td></tr></table></figure><h3 id="Linux-基本命令-一"><a href="#Linux-基本命令-一" class="headerlink" title="Linux 基本命令(一)"></a>Linux 基本命令(一)</h3><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">Linux 文件或者目录名称最长可以有 265 个字符，“.”代表当前目录，“..”代表上一级目录，以“.”开头的文件为隐藏文件，需要用 -a 参数才能显示。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 查看文件信息：<span class="keyword">ls</span></span><br><span class="line">    -a  显示指定目录下所有子目录与文件，包括隐藏文件</span><br><span class="line">    -<span class="keyword">l</span>以列表方式显示文件的详细信息</span><br><span class="line">    -<span class="keyword">h</span>配合 -<span class="keyword">l</span> 以人性化的方式显示文件大小（字节大小以 K 显示）</span><br><span class="line">    </span><br><span class="line">    $ <span class="keyword">ls</span> -a</span><br><span class="line">    $ <span class="keyword">ls</span> -<span class="keyword">l</span></span><br><span class="line">    $ <span class="keyword">ls</span> -<span class="keyword">l</span> -<span class="built_in">h</span></span><br><span class="line">    $ <span class="keyword">ls</span> -alh</span><br><span class="line">    </span><br><span class="line">2. 清屏：<span class="keyword">clear</span></span><br><span class="line">    <span class="keyword">clear</span> 作用为清除终端上的显示(类似于 DOS 的 cls 清屏功能)，也可使用快捷键：Ctrl + <span class="keyword">L</span></span><br><span class="line"></span><br><span class="line">3. 切换工作目录： <span class="keyword">cd</span></span><br><span class="line">    <span class="keyword">cd</span>    切换到当前用户的主目录(/home/用户目录)，用户登陆的时候，默认的目录就是用户的主目录。</span><br><span class="line">    <span class="keyword">cd</span> ~切换到当前用户的主目录(/home/用户目录)</span><br><span class="line">    <span class="keyword">cd</span> .切换到当前目录</span><br><span class="line">    <span class="keyword">cd</span> ..切换到上级目录</span><br><span class="line">    <span class="keyword">cd</span> -可进入上次所在的目录</span><br><span class="line">    </span><br><span class="line">4. 显示当前路径：<span class="keyword">pwd</span></span><br><span class="line">    </span><br><span class="line">5. 创建目录：<span class="keyword">mkdir</span></span><br><span class="line">    通过<span class="keyword">mkdir</span>命令可以创建一个新的目录。参数 -p 可递归创建目录。</span><br><span class="line">    </span><br><span class="line">    $ <span class="keyword">mkdir</span> newdir1</span><br><span class="line">    $ <span class="keyword">mkdir</span> -p newdir2/a/b/c</span><br><span class="line">    </span><br><span class="line">6. 删除文件：<span class="keyword">rm</span></span><br><span class="line">    可通过<span class="keyword">rm</span>删除文件或目录。使用<span class="keyword">rm</span>命令要小心，因为文件删除后不能恢复。</span><br><span class="line">    为了防止文件误删，可以在<span class="keyword">rm</span>后使用-i参数以逐个确认要删除的文件。</span><br><span class="line">    </span><br><span class="line">    -i以进行交互式方式执行</span><br><span class="line">    -f强制删除，忽略不存在的文件，无需提示</span><br><span class="line">    -r递归地删除目录下的内容，删除文件夹时必须加此参数</span><br><span class="line">    </span><br><span class="line">    $ <span class="keyword">rm</span> -<span class="keyword">if</span> newfile.txt</span><br><span class="line">    $ <span class="keyword">rm</span> -<span class="keyword">ir</span> newdir1</span><br><span class="line">    </span><br><span class="line">7. 拷贝：cp</span><br><span class="line">    cp 命令的功能是将给出的文件或目录复制到另一个文件或目录中，相当于 DOS 下的 <span class="keyword">copy</span> 命令。</span><br><span class="line">    </span><br><span class="line">    -a该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录，简单而言，保持文件原有属性。</span><br><span class="line">    -f已经存在的目标文件而不提示</span><br><span class="line">    -i交互式复制，在覆盖目标文件之前将给出提示要求用户确认</span><br><span class="line">    -r若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名。</span><br><span class="line">    -v显示拷贝进度</span><br><span class="line">    </span><br><span class="line">    $ cp -ivr newdir1 newdir2</span><br><span class="line">    </span><br><span class="line">8. mv：移动、重命名</span><br><span class="line">    用户可以使用mv命令来移动文件或目录，也可以给文件或目录重命名。</span><br><span class="line">    </span><br><span class="line">    -f禁止交互式操作，如有覆盖也不会给出提示</span><br><span class="line">    -i确认交互方式操作，如果mv操作将导致对已存在的目标文件的覆盖，系统会询问是否重写，要求用户回答以避免误覆盖文件</span><br><span class="line">    -v显示移动进度</span><br><span class="line">    </span><br><span class="line">    $ mv -iv newdir1 newdir3</span><br><span class="line">    </span><br><span class="line">9. 创建文件: touch</span><br><span class="line">    用户可以通过touch来创建一个空的文件</span><br><span class="line">    </span><br><span class="line">    $ touch hello.txt</span><br><span class="line">    </span><br><span class="line">10. 查看文件树状图：tree</span><br><span class="line">    通过使用 tree 命令来查看我们的文件树状图，那么如果我们的电脑里面没有安装tree的软件的话，那么就会执行命令失败，出现如下的问题：-bash: tree: command not found</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">Mac</span> 上安装 tree 安装包：</span><br><span class="line">    $ brew install tree</span><br><span class="line"></span><br><span class="line">11. echo</span><br><span class="line">    echo 命令用于在 <span class="keyword">shell</span> 中打印 <span class="keyword">shell</span> 变量的值，或者直接输出指定的字符串。</span><br><span class="line">    </span><br><span class="line">12. gedit</span><br><span class="line">    gedit 命令可以打开 linux 下记事本，类似 windows 下的 notepad (txt-记事本)</span><br></pre></td></tr></table></figure><h3 id="Linux-基本命令-二"><a href="#Linux-基本命令-二" class="headerlink" title="Linux 基本命令(二)"></a>Linux 基本命令(二)</h3><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">1. 输出重定向命令：&gt;</span><br><span class="line">    Linux 允许将命令执行结果重定向到一个文件，本应显示在终端上的内容保存到指定文件中。</span><br><span class="line">    </span><br><span class="line">    # <span class="keyword">test</span>.txt 如果不存在，则创建，存在则覆盖其内容</span><br><span class="line">        $ <span class="keyword">ls</span> &gt; <span class="keyword">test</span>.txt</span><br><span class="line">        $ echo 111 &gt; <span class="keyword">test</span>.txt</span><br><span class="line">        $ tree &gt; <span class="keyword">test</span>.txt</span><br><span class="line">    </span><br><span class="line">    注意：&gt;输出重定向会覆盖原来的内容，&gt;&gt;输出重定向则会追加到文件的尾部。 </span><br><span class="line"></span><br><span class="line">2. 查看或者合并文件内容：<span class="keyword">cat</span></span><br><span class="line"></span><br><span class="line">    # 查看文件所有内容,并全部显示</span><br><span class="line">    $ <span class="keyword">cat</span> 文件</span><br><span class="line"># 1.txt 2.txt文件内容保存到3.txt</span><br><span class="line">    $ <span class="keyword">cat</span> 1.txt 2.txt &gt; 3.txt</span><br><span class="line"># 1.txt 2.txt文件内容追加到3.txt</span><br><span class="line">    $ <span class="keyword">cat</span> 1.txt 2.txt &gt;&gt; 3.txt</span><br><span class="line"></span><br><span class="line">3. 分屏显示：<span class="keyword">more</span></span><br><span class="line">    分屏显示文件内容,每次只显示一页</span><br><span class="line"></span><br><span class="line"><span class="keyword">more</span> 文件名</span><br><span class="line"></span><br><span class="line">f/空格：翻到下一页</span><br><span class="line">b：翻到上一页</span><br><span class="line">回车：显示下一行</span><br><span class="line">q：退出当前显示</span><br><span class="line"><span class="keyword">h</span>：查看帮助</span><br><span class="line"></span><br><span class="line">4. 管道：|</span><br><span class="line">一个命令的输出可以通过管道做为另一个命令的输入</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">ls</span> /bin | <span class="keyword">more</span></span><br><span class="line"></span><br><span class="line">查看 bin 目录下的文件信息，让显示在终端的数据保存在管道里面，然后通过 <span class="keyword">more</span> 分屏显示管道里面的数据</span><br><span class="line">经常和 grep/xargs 连用</span><br><span class="line"></span><br><span class="line">$ grep -i '-' 1.txt | <span class="keyword">more</span></span><br><span class="line"></span><br><span class="line">5. 文本搜索：grep</span><br><span class="line">    Linux 系统中 grep 命令是一种强大的文本搜索工具，grep 允许对文本文件进行模式查找。</span><br><span class="line">    如果找到匹配模式，grep 打印包含模式的所有行。</span><br><span class="line">    </span><br><span class="line">    grep [-选项] '搜索内容串' 文件名</span><br><span class="line">    </span><br><span class="line">    -v显示不包含匹配文本的所有行（相当于求反）</span><br><span class="line">    -<span class="keyword">n</span>显示匹配行及行号</span><br><span class="line">    -i忽略大小写</span><br><span class="line">    </span><br><span class="line">    grep 常用正则表达式：</span><br><span class="line"></span><br><span class="line">    ^a  行首,搜寻以 a 开头的行；grep -<span class="keyword">n</span> '^a' 1.txt</span><br><span class="line">    ke$  行尾,搜寻以 ke 结束的行；grep -<span class="keyword">n</span> 'ke$' 1.txt</span><br><span class="line">    [Ss]  匹配 [] 里中一系列字符中的一个；grep -<span class="keyword">n</span> '[Ss]igna' 1.txt</span><br><span class="line">    .  匹配一个非换行符的字符；grep -<span class="keyword">n</span> '<span class="keyword">e</span>.<span class="keyword">e</span>' 1.txt</span><br><span class="line">    </span><br><span class="line">6. 建立链接文件：<span class="built_in">ln</span></span><br><span class="line">    1. 软链接</span><br><span class="line">    适合做快捷方式</span><br><span class="line">    源文件删除,软链接失效</span><br><span class="line">    </span><br><span class="line">    $ ln -s 源文件/文件夹 软链接名</span><br><span class="line">    </span><br><span class="line">    软链接文件和源文件不在同一个目录，源文件要使用绝对路径</span><br><span class="line">    软链接可以对文件或文件夹进行操作</span><br><span class="line">    创建软链接,文件/目录硬链接数不会增加</span><br><span class="line"></span><br><span class="line">2. 硬链接</span><br><span class="line">    适合做数据备份</span><br><span class="line">    源文件删除,硬链接不失效</span><br><span class="line">    </span><br><span class="line">    $ ln 源文件 硬链接名</span><br><span class="line">    </span><br><span class="line">    硬链接只能对文件进行操作</span><br><span class="line">    创建硬链接,文件的硬链接数会增加</span><br><span class="line">    </span><br><span class="line">7. 查找文件：find</span><br><span class="line">    find 命令功能非常强大，通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件。</span><br><span class="line">    </span><br><span class="line">    find ./ -name <span class="keyword">test</span>.<span class="keyword">sh</span>查找当前目录下所有名为<span class="keyword">test</span>.<span class="keyword">sh</span>的文件</span><br><span class="line">    find ./ -name '*.<span class="keyword">sh</span>'查找当前目录下所有后缀为.<span class="keyword">sh</span>的文件</span><br><span class="line">    find ./ -name '[A-Z]*'查找当前目录下所有以大写字母开头的文件</span><br><span class="line">    find /tmp -size 2M    查找在/tmp 目录下等于2M的文件</span><br><span class="line">    find /tmp -size +2M    查找在/tmp 目录下大于2M的文件</span><br><span class="line">    find /tmp -size -2M    查找在/tmp 目录下小于2M的文件</span><br><span class="line">    find ./ -size +4k -size -5M    查找当前目录下大于4k，小于5M的文件</span><br><span class="line">    find ./ -perm 777    查找当前目录下权限为 777 的文件或目录</span><br><span class="line">    find 目录 -<span class="keyword">type</span> f/<span class="keyword">d</span>     查找指定目录下的文件/文件夹</span><br><span class="line"></span><br><span class="line">8. 归档管理：tar</span><br><span class="line">1. 归档+打包</span><br><span class="line">tar</span><br><span class="line">归档：tar -cvf <span class="keyword">test</span>.tar *.txt</span><br><span class="line">        把所有.txt文件打包为<span class="keyword">test</span>.tar</span><br><span class="line">解档：tar -xvf <span class="keyword">test</span>.tar -C指定文件夹</span><br><span class="line">        将<span class="keyword">test</span>.tar解档到指定目录</span><br><span class="line">gzip</span><br><span class="line">压缩：gzip -r <span class="keyword">test</span>.tar <span class="keyword">test</span>.tar.gz</span><br><span class="line">将<span class="keyword">test</span>.tar压缩为<span class="keyword">test</span>.tar.gzip</span><br><span class="line">解压：gzip -<span class="keyword">d</span> <span class="keyword">test</span>.tar.gz <span class="keyword">test</span>.tar</span><br><span class="line">将<span class="keyword">test</span>.tar.gz解压为<span class="keyword">test</span>.tar</span><br><span class="line">bzip2</span><br><span class="line">压缩：bzip2 -r <span class="keyword">test</span>.tar <span class="keyword">test</span>.tar.bz2</span><br><span class="line">将<span class="keyword">test</span>.tar压缩为<span class="keyword">test</span>.tar.bz2</span><br><span class="line">解压：bzip2 -<span class="keyword">d</span> <span class="keyword">test</span>.tar.bz2 <span class="keyword">test</span>.tar</span><br><span class="line">将<span class="keyword">test</span>.tar.bz2解压为<span class="keyword">test</span>.tar</span><br><span class="line">2. gzip格式</span><br><span class="line">tar 归档+压缩：tar -zcvf <span class="keyword">test</span>.tar.gz *.txt</span><br><span class="line">所有.txt后缀的文件压缩为<span class="keyword">test</span>.tar.gz</span><br><span class="line">tar 解档+解压：tar -zxvf <span class="keyword">test</span>.tar.gz -C 指定文件夹</span><br><span class="line">解压<span class="keyword">test</span>.tar.gz到指定的文件夹</span><br><span class="line"></span><br><span class="line">3. bzip2格式</span><br><span class="line">tar 归档+压缩：tar -jcvf <span class="keyword">test</span>.tar.bz2 *.html</span><br><span class="line">所有.html后缀的文件压缩为<span class="keyword">test</span>.tar.bz2</span><br><span class="line">tar 解档+解压：tar -jxvf <span class="keyword">test</span>.tar.bz2 -C 指定文件夹</span><br><span class="line">解压<span class="keyword">test</span>.tar.bz2到指定的文件夹</span><br><span class="line">4. <span class="keyword">zip</span>格式</span><br><span class="line"><span class="keyword">zip</span> 压缩：<span class="keyword">zip</span> -r <span class="keyword">test</span>.<span class="keyword">zip</span> *.py</span><br><span class="line"><span class="keyword">zip</span>格式压缩所有.py文件</span><br><span class="line">unzip 解压：unzip -<span class="keyword">d</span> 指定文件夹 <span class="keyword">test</span>.<span class="keyword">zip</span></span><br><span class="line">解压<span class="keyword">test</span>.<span class="keyword">zip</span>到指定文件夹</span><br><span class="line"></span><br><span class="line">常用参数</span><br><span class="line">    -c生成档案文件，创建打包文件</span><br><span class="line">        -v列出归档解档的详细过程，显示进度</span><br><span class="line">        -f指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后</span><br><span class="line">        -t列出档案中包含的文件</span><br><span class="line">        -x解开档案文件</span><br><span class="line">        -<span class="keyword">d</span>解压</span><br><span class="line">        -r压缩所有子目录</span><br><span class="line">        -z  指定压缩包的格式为：<span class="keyword">file</span>.tar.gz</span><br><span class="line"></span><br><span class="line">9. 查看命令位置：<span class="keyword">which</span></span><br><span class="line">    $ <span class="keyword">which</span> <span class="keyword">ls</span></span><br><span class="line">    </span><br><span class="line">10. 修改文件权限：chmod</span><br><span class="line">文件权限</span><br><span class="line">r   可读    数字代号: 4</span><br><span class="line">w   可写    数字代号: 2</span><br><span class="line">x   可执行  数字代号: 1</span><br><span class="line">-   无任何权限  数字代号: 0</span><br><span class="line"></span><br><span class="line">用户</span><br><span class="line"><span class="keyword">u</span>   当前用户(user)</span><br><span class="line"><span class="keyword">g</span>   同组用户(group)</span><br><span class="line">o   其他用户(other)</span><br><span class="line">a所有用户(all)</span><br><span class="line"></span><br><span class="line">设置权限</span><br><span class="line">+添加权限</span><br><span class="line">-删除权限</span><br><span class="line">=设置权限</span><br><span class="line"></span><br><span class="line">字母法设置权限</span><br><span class="line">chmod <span class="keyword">u</span>/<span class="keyword">g</span>/o/a +/-/= rwx 文件</span><br><span class="line">chmod a= 1.txt</span><br><span class="line">所有用户没有权限</span><br><span class="line">chmod a=rwx 1.txt</span><br><span class="line">所有用户都有全部权限</span><br><span class="line">chmod <span class="keyword">u</span>+x 1.txt</span><br><span class="line">给当前用户添加可执行的权限</span><br><span class="line"></span><br><span class="line">数字法设置权限</span><br><span class="line">chmod 777 文件名</span><br><span class="line">给所有用户添加全部权限</span><br><span class="line">chmod 751 文件名</span><br><span class="line">给当前用户rwx权限,本组用户rx权限,其他用户x权限</span><br><span class="line"></span><br><span class="line">11. 切换账号</span><br><span class="line">切换到管理员账号</span><br><span class="line">sudo -<span class="built_in">s</span></span><br><span class="line">切换到其他账号</span><br><span class="line"><span class="keyword">su</span> 其他账号名</span><br><span class="line"></span><br><span class="line">12. 设置用户密码：passwd</span><br><span class="line">sudo passwd 新密码</span><br><span class="line"></span><br><span class="line">13. 退出登录账户：<span class="keyword">exit</span></span><br><span class="line"></span><br><span class="line">14. 查看登录用户：who</span><br><span class="line">who     查看当前系统登录的所有用户名</span><br><span class="line">who -q  只显示用户登录的账号和登录的用户数量</span><br><span class="line">who -<span class="keyword">u</span>  只显示列标题</span><br><span class="line">whoami  只显示当前用户登录的用户名</span><br><span class="line"></span><br><span class="line">15. 关机重启</span><br><span class="line">shutdown</span><br><span class="line">shutdown -r now</span><br><span class="line">重启系统,并给其他用户提示</span><br><span class="line">shutdown -<span class="keyword">h</span> now</span><br><span class="line">立刻关机</span><br><span class="line">shutdown -<span class="keyword">h</span> 20:25</span><br><span class="line">系统在今天的20:25 关机</span><br><span class="line">shutdown -<span class="keyword">h</span> +10</span><br><span class="line">系统再过十分钟,自动关机</span><br><span class="line">shutdown -c</span><br><span class="line">取消关机</span><br><span class="line"></span><br><span class="line">init</span><br><span class="line">init 0  系统关机</span><br><span class="line">init 6  系统重启</span><br><span class="line"></span><br><span class="line">reboot</span><br><span class="line">重新启动系统</span><br></pre></td></tr></table></figure><h3 id="软件操作的相关命令"><a href="#软件操作的相关命令" class="headerlink" title="软件操作的相关命令"></a>软件操作的相关命令</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> update  更新源</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install package 安装包</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> <span class="builtin-name">remove</span> package 删除包</span><br><span class="line"></span><br><span class="line">sudo apt-cache search package 搜索软件包</span><br><span class="line"></span><br><span class="line">sudo apt-cache show package  获取包的相关信息，如说明、大小、版本等</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install package --reinstall   重新安装包</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> -f install   修复安装</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> <span class="builtin-name">remove</span> package --purge 删除包，包括配置文件等</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> build-dep package 安装相关的编译环境</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span><span class="built_in"> upgrade </span>更新已安装的包</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> dist-upgrade 升级系统</span><br><span class="line"></span><br><span class="line">sudo apt-cache depends package 了解使用该包依赖那些包</span><br><span class="line"></span><br><span class="line">sudo apt-cache rdepends package 查看该包被哪些包依赖</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> source package  下载该包的源代码</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> clean &amp;&amp; sudo apt-<span class="builtin-name">get</span> autoclean 清理无用的包</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> check 检查是否有损坏的依赖</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="1-必须学会使用的"><a href="#1-必须学会使用的" class="headerlink" title="1.必须学会使用的"></a>1.必须学会使用的</h4><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">命令行安装工具：（例如: tree/greenlet/gevent.<span class="string">..</span>）</span><br><span class="line">sudo apt-get install 包名</span><br><span class="line">sudo gedit 文件名</span><br><span class="line"></span><br><span class="line">基本命令：<span class="keyword">cd</span> <span class="keyword">ls</span></span><br></pre></td></tr></table></figure><h4 id="2-大纲要求会的-以后上班有可能用的到"><a href="#2-大纲要求会的-以后上班有可能用的到" class="headerlink" title="2.大纲要求会的(以后上班有可能用的到)"></a>2.大纲要求会的(以后上班有可能用的到)</h4><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">a</span>. <span class="keyword">cp</span>/rm/<span class="built_in">mkdir</span>/mv/touch/<span class="keyword">find</span></span><br><span class="line"><span class="keyword">b</span>. putty/filezilla 等远程操控及文件传输软件的使用</span><br><span class="line"><span class="keyword">c</span>. <span class="keyword">vim</span> 能够修改内容（最简单形式）</span><br><span class="line">d. 命令 | <span class="keyword">grep</span> 内容：从前面命令中获取指定内容</span><br><span class="line"><span class="keyword">e</span>. passwd/who/<span class="keyword">ln</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Linux-终端命令&quot;&gt;&lt;a href=&quot;#Linux-终端命令&quot; class=&quot;headerlink&quot; title=&quot;Linux 终端命令&quot;&gt;&lt;/a&gt;Linux 终端命令&lt;/h3&gt;&lt;h4 id=&quot;01-终端命令格式&quot;&gt;&lt;a href=&quot;#01-终端命令格式&quot; c
      
    
    </summary>
    
      <category term="Linux" scheme="http://jovelin.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://jovelin.cn/tags/Linux/"/>
    
      <category term="Linux 命令" scheme="http://jovelin.cn/tags/Linux-%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux 系统介绍</title>
    <link href="http://jovelin.cn/2018/07/02/Linux%20%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jovelin.cn/2018/07/02/Linux 系统介绍/</id>
    <published>2018-07-02T01:00:01.000Z</published>
    <updated>2018-07-28T02:51:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li>操作系统（Operation System，OS）</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/3365001-a1bc7631457c9a6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="操作系统作为接口的示意图.png"></p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">1.1 操作系统的作用</span><br><span class="line">    1. 是现代计算机系统中 最基本和最重要 的系统软件</span><br><span class="line">    2. 是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩展</span><br><span class="line">    3. 主要作用是管理好硬件设备，并为用户和应用程序提供一个简单的接口，以便于使用</span><br><span class="line">    4. 而其他的诸如编译程序、数据库管理系统，以及大量的应用软件，都直接依赖于操作系统的支持</span><br><span class="line"></span><br><span class="line">1.2 不同应用领域的主流操作系统</span><br><span class="line">    1. 桌面操作系统</span><br><span class="line">    2. 服务器操作系统</span><br><span class="line">    3. 嵌入式操作系统</span><br><span class="line">    4. 移动设备操作系统</span><br><span class="line">    </span><br><span class="line">    1&gt; 桌面操作系统</span><br><span class="line">        Windows 系列</span><br><span class="line">        用户群体大</span><br><span class="line">        macOS</span><br><span class="line">        适合于开发人员</span><br><span class="line">        Linux</span><br><span class="line">        应用软件少</span><br><span class="line">    </span><br><span class="line">    2&gt; 服务器操作系统</span><br><span class="line">        Linux</span><br><span class="line">        安全、稳定、免费</span><br><span class="line">        占有率高</span><br><span class="line">        Windows Server</span><br><span class="line">        付费</span><br><span class="line">        占有率低</span><br><span class="line">        002_机房照片</span><br><span class="line">    </span><br><span class="line">    3&gt; 嵌入式操作系统</span><br><span class="line">        Linux</span><br><span class="line">        微型化</span><br><span class="line">        可裁剪性</span><br><span class="line">        实时性</span><br><span class="line">        高可靠性</span><br><span class="line">        易移植性</span><br><span class="line">        例如: mp3、mp4、车载导航、智能家电<span class="built_in">..</span>.（工厂控制设备，智能仪表，智能玩具<span class="built_in">..</span>.）</span><br><span class="line">        </span><br><span class="line">        linux在开发，或者删减部分功能适应硬件，或者使用c语言直接开发的特定设备简单系统<span class="built_in">..</span>.</span><br><span class="line">    </span><br><span class="line">    4&gt; 移动设备操作系统</span><br><span class="line">        iOS</span><br><span class="line">        Android（基于 Linux）</span><br><span class="line">    </span><br><span class="line">    1.3 虚拟机</span><br><span class="line">        虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统</span><br><span class="line">        </span><br><span class="line">        1. 虚拟系统通过生成现有操作系统的全新虚拟镜像，具有真实操作系统完全一样的功能</span><br><span class="line">        2. 进入虚拟系统后，所有操作都是在这个全新的独立的虚拟系统里面进行，可以独立安装运行软件，保存数据，拥有自己的独立桌面，不会对真正的系统产生任何影响</span><br><span class="line">        3. 而且能够在现有系统与虚拟镜像之间灵活切换的一类操作系统</span><br></pre></td></tr></table></figure><h3 id="Linux-下的文件系统"><a href="#Linux-下的文件系统" class="headerlink" title="Linux 下的文件系统"></a>Linux 下的文件系统</h3><ul><li><p>在 Linux 下，我们是看不到这些驱动器盘符，我们看到的是文件夹（目录）</p></li><li><p>Ubuntu 没有盘符这个概念，只有一个根目录 /，所有文件都在它下面</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/3365001-945e061bb06df968.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="003-Linux的树形示意图.png"></p><h3 id="用户目录"><a href="#用户目录" class="headerlink" title="用户目录"></a>用户目录</h3><ul><li>位于 /home/user，称之为用户工作目录或家目录，表示方式：</li></ul><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">/home/user</span><br><span class="line">~</span><br></pre></td></tr></table></figure><h3 id="Linux-主要目录速查表"><a href="#Linux-主要目录速查表" class="headerlink" title="Linux 主要目录速查表"></a>Linux 主要目录速查表</h3><ul><li>/：根目录，一般根目录下只存放目录，在 linux 下有且只有一个根目录，所有的东西都是从这里开始<br>当在终端里输入 /home，其实是在告诉电脑，先从 /（根目录）开始，再进入到 home 目录</li><li>/bin、/usr/bin：可执行二进制文件的目录，如常用的命令 ls、tar、mv、cat 等</li><li>/boot：放置 linux 系统启动时用到的一些文件，如 linux 的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub</li><li>/dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱mount /dev/cdrom /mnt</li><li>/etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有<ul><li>/etc/inittab</li><li>/etc/fstab</li><li>/etc/init.d</li><li>/etc/X11</li><li>/etc/sysconfig</li><li>/etc/xinetd.d</li></ul></li><li>/home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下<ul><li>~ 表示当前用户的家目录</li><li>~edu 表示用户 edu 的家目录</li></ul></li><li>/lib、/usr/lib、/usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助</li><li>/lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下</li><li>/mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载</li><li>/opt：给主机额外安装软件所摆放的目录</li><li>/proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的文件有：/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等</li><li>/root：系统管理员root的家目录</li><li>/sbin、/usr/sbin、/usr/local/sbin：放置系统管理员使用的可执行命令，如 fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root 使用的命令，一般用户只能”查看”而不能设置和使用</li><li>/tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下</li><li>/srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内</li><li>/usr：应用程序存放目录<ul><li>/usr/bin：存放应用程序</li><li>/usr/share：存放共享数据</li><li>/usr/lib：存放不能直接运行的，却是许多程序运行所必需的一些函数库文件</li><li>/usr/local：存放软件升级包</li><li>/usr/share/doc：系统说明文件存放目录</li><li>/usr/share/man：程序说明文件存放目录</li></ul></li><li>/var：放置系统执行过程中经常变化的文件<ul><li>/var/log：随时更改的日志文件</li><li>/var/spool/mail：邮件存放的目录</li><li>/var/run：程序或服务启动后，其 PID 存放在该目录下</li></ul></li></ul><h3 id="Unix-家谱"><a href="#Unix-家谱" class="headerlink" title="Unix 家谱"></a>Unix 家谱</h3><p><img src="https://upload-images.jianshu.io/upload_images/3365001-6d0dce67b82131cc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="003_unix家谱.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;操作系统（Operation System，OS）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https:
      
    
    </summary>
    
      <category term="Linux" scheme="http://jovelin.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://jovelin.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>认识 Python</title>
    <link href="http://jovelin.cn/2017/06/22/%E8%AE%A4%E8%AF%86%20Python/"/>
    <id>http://jovelin.cn/2017/06/22/认识 Python/</id>
    <published>2017-06-22T13:25:32.000Z</published>
    <updated>2018-07-28T02:14:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Python-的起源"><a href="#1-Python-的起源" class="headerlink" title="1. Python 的起源"></a>1. Python 的起源</h2><p>人生苦短，我用 Python</p><blockquote><p>Python 的创始人为吉多·范罗苏姆（Guido van Rossum）</p></blockquote><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/3365001-0748c25c80efb613.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="002_吉多.jpg"></p><ul><li><p>Python的作者，Guido von Rossum，荷兰人。1982年，Guido从阿姆斯特丹大学获得了数学和计算机硕士学位。然而，尽管他算得上是一位数学家，但他更加享受计算机带来的乐趣。用他的话说，尽管拥有数学和计算机双料资质，他总趋向于做计算机相关的工作，并热衷于做任何和编程相关的活儿。</p></li><li><p>在那个时候，Guido接触并使用过诸如Pascal、C、Fortran等语言。这些语言的基本设计原则是让机器能更快运行。Guido知道如何用C语言写出一个功能，但整个编写过程需要耗费大量的时间，即使他已经准确的知道了如何实现。这种编程方式让Guido感到苦恼。</p></li><li><p>他的另一个选择是shell。Bourne Shell作为UNIX系统的解释器已经长期存在。UNIX的管理员们常常用shell去写一些简单的脚本，以进行一些系统维护的工作，比如定期备份、文件系统管理等等。shell可以像胶水一样，将UNIX下的许多功能连接在一起。许多C语言下上百行的程序，在shell下只用几行就可以完成。然而，shell的本质是调用命令。它并不是一个真正的语言。比如说，shell没有数值型的数据类型，加法运算都很复杂。总之，shell不能全面的调动计算机的功能。</p></li><li><p>Guido希望有一种语言，这种语言能够像C语言那样，能够全面调用计算机的功能接口，又可以像shell那样，可以轻松的编程。</p></li><li><p>1989年，为了打发圣诞节假期，Guido开始写Python语言的编译器。Python这个名字，来自Guido所挚爱的电视剧Monty Python’s Flying Circus。他希望这个新的叫做Python的语言，能符合他的理想：创造一种C和shell之间，功能全面，易学易用，可拓展的语言。Guido作为一个语言设计爱好者，已经有过设计语言的尝试。这一次，也不过是一次纯粹的hacking行为。</p></li></ul><h3 id="一门语言的诞生"><a href="#一门语言的诞生" class="headerlink" title="一门语言的诞生"></a>一门语言的诞生</h3><ul><li><p>1991年，第一个Python编译器诞生。它是用C语言实现的，并能够调用C语言的库文件。从一出生，Python已经具有了 ：类，函数，异常处理，包含表和词典在内的核心数据类型，以及模块为基础的拓展系统。</p></li><li><p>Python语法很多来自C，但又受到ABC语言的强烈影响。来自ABC语言的一些规定直到今天还富有争议，比如强制缩进。 但这些语法规定让Python容易读。另一方面，Python聪明的选择服从一些惯例，特别是C语言的惯例，比如回归等号赋值。Guido认为，如果“常识”上确立的东西，没有必要过度纠结。</p></li><li><p>Python从一开始就特别在意可拓展性。Python可以在多个层次上拓展。从高层上，你可以直接引入. py文件。在底层，你可以引用C语言的库。Python程序员可以快速的使用Python写. py文件作为拓展模块。但当性能是考虑的重要因素时，Python程序员可以深入底层，写C程序，编译为.so文件引入到Python中使用。Python就好像是使用钢构建房一样，先规定好大的框架。而程序员可以在此框架下相当自由的拓展或更改。</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/3365001-fa16f0a8dfd6f173.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="001_人生苦短我用python.jpg"></p><p>人生苦短，我用 Python</p><ul><li><p>由于计算机性能的提高，软件的世界也开始随之改变。硬件足以满足许多个人电脑的需要。硬件性能不是瓶颈，Python又容易使用，所以许多人开始转向Python。Guido维护了一个maillist，Python用户就通过邮件进行交流。Python用户来自许多领域，有不同的背景，对Python也有不同的需求。Python相当的开放，又容易拓展，所以当用户不满足于现有功能，很容易对Python进行拓展或改造。随后，这些用户将改动发给Guido，并由Guido决定是否将新的特征加入到Python或者标准库中。如果代码能被纳入Python自身或者标准库，这将极大的荣誉。由于Guido至高无上的决定权，他因此被称为“终身的仁慈独裁者”。</p></li><li><p>Python被称为“Battery Included”，是说它以及其标准库的功能强大。这些是整个社区的贡献。Python的开发者来自不同领域，他们将不同领域的优点带给Python。比如Python标准库中的正则表达是参考Perl，而lambda, map, filter, reduce等函数参考了Lisp。Python本身的一些功能以及大部分的标准库来自于社区。Python的社 区不断扩大，进而拥有了自己的newsgroup，网站，以及基金。从Python 2.0开始，Python也从maillist的开发方式，转为完全开源的开发方式。社区气氛已经形成，工作被整个社区分担，Python也获得了更加高速的发展。</p></li><li><p>到今天，Python的框架已经确立。Python语言以对象为核心组织代码，支持多种编程范式，采用动态类型，自动进行内存回收。Python支持解释运行，并能调用C库进行拓展。Python有强大的标准库。由于标准库的体系已经稳定，所以Python的生态系统开始拓展到第三方包。这些包，如Django、web.py、wxpython、numpy、matplotlib、PIL，将Python升级成了物种丰富的热带雨林。</p></li><li><p>Python崇尚优美、清晰、简单，是一个优秀并广泛使用的语言。Python在TIOBE排行榜中排行第八，它是Google的第三大开发语言，Dropbox的基础语言，豆瓣的服务器语言。Python的发展史可以作为一个代表，带给我许多启示。</p></li><li><p>在Python的开发过程中，社区起到了重要的作用。Guido自认为自己不是全能型的程序员，所以他只负责制订框架。如果问题太复杂，他会选择绕过去，也就是cut the corner。这些问题最终由社区中的其他人解决。社区中的人才是异常丰富的，就连创建网站，筹集基金这样与开发稍远的事情，也有人乐意于处理。如今的项目开发越来越复杂，越来越庞大，合作以及开放的心态成为项目最终成功的关键。</p></li><li><p>Python从其他语言中学到了很多，无论是已经进入历史的ABC，还是依然在使用的C和Perl，以及许多没有列出的其他 语言。可以说，Python的成功代表了它所有借鉴的语言的成功。同样，Ruby借鉴了Python，它的成功也代表了Python某些方面的成功。每个语言都是混合体，都有它优秀的地方，但也有各种各样的缺陷。同时，一个语言“好与不好”的评 判，往往受制于平台、硬件、时代等等外部原因。程序员经历过许多语言之争。其实，以开放的心态来接受各个语言，说不定哪一天，程序员也可以如Guido那样，混合出自己的语言。</p></li></ul><h4 id="关键点常识"><a href="#关键点常识" class="headerlink" title="关键点常识"></a>关键点常识</h4><ul><li>Python的发音与拼写</li><li>Python的作者是Guido van Rossum（龟叔）</li><li>Python正式诞生于1991年</li><li>Python的解释器如今有多个语言实现，我们常用的是CPython（官方版本的C语言实现），其他还有Jython（可以运行在Java平台）、IronPython（可以运行在.NET和Mono平台）、PyPy（Python实现的，支持JIT即时编译）</li><li><p>Python目前有两个版本，Python2和Python3，最新版分别为2.7.14和3.6.4</p></li><li><p>2018年1月份 编程语言流行排行榜</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/3365001-cee017a6aa9e6af4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TIOBE-201801.png"></p><h2 id="2-Python-优缺点"><a href="#2-Python-优缺点" class="headerlink" title="2. Python 优缺点"></a>2. Python 优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>简单————Python是一种代表简单主义思想的语言。阅读一个良好的Python程序就感觉像是在读英语一样，尽管这个英语的要求非常严格！Python的这种伪代码本质是它最大的优点之一。它使你能够专注于解决问题而不是去搞明白语言本身。</p></li><li><p>易学————就如同你即将看到的一样，Python极其容易上手。前面已经提到了，Python有极其简单的语法。</p></li><li><p>免费、开源————Python是FLOSS（自由/开放源码软件）之一。简单地说，你可以自由地发布这个软件的拷贝、阅读它的源代码、对它做改动、把它的一部分用于新的自由软件中。FLOSS是基于一个团体分享知识的概念。这是为什么Python如此优秀的原因之一——它是由一群希望看到一个更加优秀的Python的人创造并经常改进着的。</p></li><li><p>高层语言————当你用Python语言编写程序的时候，你无需考虑诸如如何管理你的程序使用的内存一类的底层细节。</p></li><li><p>可移植性————由于它的开源本质，Python已经被移植在许多平台上（经过改动使它能够工作在不同平台上）。如果你小心地避免使用依赖于系统的特性，那么你的所有Python程序无需修改就可以在下述任何平台上面运行。这些平台包括Linux、Windows、FreeBSD、Macintosh、Solaris、OS/2、Amiga、AROS、AS/400、BeOS、OS/390、z/OS、Palm OS、QNX、VMS、Psion、Acom RISC OS、VxWorks、PlayStation、Sharp Zaurus、Windows CE甚至还有PocketPC、Symbian以及Google基于linux开发的Android平台！</p></li><li><p>解释性————这一点需要一些解释。一个用编译性语言比如C或C++写的程序可以从源文件（即C或C++语言）转换到一个你的计算机使用的语言（二进制代码，即0和1）。这个过程通过编译器和不同的标记、选项完成。当你运行你的程序的时候，连接/转载器软件把你的程序从硬盘复制到内存中并且运行。而Python语言写的程序不需要编译成二进制代码。你可以直接从源代码运行程序。在计算机内部，Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。事实上，由于你不再需要担心如何编译程序，如何确保连接转载正确的库等等，所有这一切使得使用Python更加简单。由于你只需要把你的Python程序拷贝到另外一台计算机上，它就可以工作了，这也使得你的Python程序更加易于移植。</p></li><li><p>面向对象————Python既支持面向过程的编程也支持面向对象的编程。在“面向过程”的语言中，程序是由过程或仅仅是可重用代码的函数构建起来的。在“面向对象”的语言中，程序是由数据和功能组合而成的对象构建起来的。与其他主要的语言如C++和Java相比，Python以一种非常强大又简单的方式实现面向对象编程。</p></li><li><p>可扩展性————如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们。</p></li><li><p>丰富的库————Python标准库确实很庞大。它可以帮助你处理各种工作，包括正则表达式、文档生成、单元测试、线程、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、WAV文件、密码系统、GUI（图形用户界面）、Tk和其他与系统有关的操作。记住，只要安装了Python，所有这些功能都是可用的。这被称作Python的“功能齐全”理念。除了标准库以外，还有许多其他高质量的库，如wxPython、Twisted和Python图像库等等。</p></li><li><p>规范的代码————Python采用强制缩进的方式使得代码具有极佳的可读性。</p></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>运行速度，有速度要求的话，用C++改写关键部分吧。</li><li>国内市场较小（国内以python来做主要开发的，目前只有一些web2.0公司）。但时间推移，目前很多国内软件公司，尤其是游戏公司，也开始规模使用他。</li><li>中文资料匮乏（好的python中文资料屈指可数）。托社区的福，有几本优秀的教材已经被翻译了，但入门级教材多，高级内容还是只能看英语版。</li><li>构架选择太多（没有像C#这样的官方.net构架，也没有像ruby由于历史较短，构架开发的相对集中。Ruby on Rails 构架开发中小型web程序天下无敌）。不过这也从另一个侧面说明，python比较优秀，吸引的人才多，项目也多。</li></ol><h2 id="3-Python-应用场景"><a href="#3-Python-应用场景" class="headerlink" title="3. Python 应用场景"></a>3. Python 应用场景</h2><ul><li><p><strong>Web应用开发</strong></p><p>Python经常被用于Web开发。比如，通过mod_wsgi模块，Apache可以运行用Python编写的Web程序。Python定义了WSGI标准应用接口来协调Http服务器与基于Python的Web程序之间的通信。一些Web框架，如Django,TurboGears,web2py,Zope等，可以让程序员轻松地开发和管理复杂的Web程序。</p></li><li><p><strong>操作系统管理、服务器运维的自动化脚本</strong></p><p>在很多操作系统里，Python是标准的系统组件。 大多数Linux发行版以及NetBSD、OpenBSD和Mac OS X都集成了Python，可以在终端下直接运行Python。有一些Linux发行版的安装器使用Python语言编写，比如Ubuntu的Ubiquity安装器,Red Hat Linux和Fedora的Anaconda安装器。Gentoo Linux使用Python来编写它的Portage包管理系统。Python标准库包含了多个调用操作系统功能的库。通过pywin32这个第三方软件 包，Python能够访问Windows的COM服务及其它Windows API。使用IronPython，Python程序能够直接调用.Net Framework。一般说来，Python编写的系统管理脚本在可读性、性能、代码重用度、扩展性几方面都优于普通的shell脚本。</p></li><li><p><strong>科学计算</strong></p><p>NumPy,SciPy,Matplotlib可以让Python程序员编写科学计算程序。</p></li><li><p><strong>桌面软件</strong></p><p>PyQt、PySide、wxPython、PyGTK是Python快速开发桌面应用程序的利器。</p></li><li><p><strong>服务器软件（网络软件）</strong></p><p>Python对于各种网络协议的支持很完善，因此经常被用于编写服务器软件、网络爬虫。第三方库Twisted支持异步网络编程和多数标准的网络协议(包含客户端和服务器)，并且提供了多种工具，被广泛用于编写高性能的服务器软件。</p></li><li><p><strong>游戏</strong></p><p>很多游戏使用C++编写图形显示等高性能模块，而使用Python或者Lua编写游戏的逻辑、服务器。相较于Python，Lua的功能更简单、体积更小；而Python则支持更多的特性和数据类型。</p></li><li><p><strong>构思实现，产品早期原型和迭代</strong></p><p>YouTube、Google、Yahoo!、NASA都在内部大量地使用Python。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Python-的起源&quot;&gt;&lt;a href=&quot;#1-Python-的起源&quot; class=&quot;headerlink&quot; title=&quot;1. Python 的起源&quot;&gt;&lt;/a&gt;1. Python 的起源&lt;/h2&gt;&lt;p&gt;人生苦短，我用 Python&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Python 的创始人为吉多·范罗苏姆（Guido van Rossum）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python 基础" scheme="http://jovelin.cn/categories/Python-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Python 基础" scheme="http://jovelin.cn/tags/Python-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理</title>
    <link href="http://jovelin.cn/2017/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <id>http://jovelin.cn/2017/06/22/计算机组成原理/</id>
    <published>2017-06-22T01:47:06.000Z</published>
    <updated>2018-07-28T02:02:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是计算机？"><a href="#什么是计算机？" class="headerlink" title="什么是计算机？"></a>什么是计算机？</h1><p>计算机（computer）俗称电脑，是现代一种用于高速计算的电子机器，可以进行数值计算，又可以进行逻辑判断，还具有存储记忆功能，且能够按照程序的运行，自动、高速处理数据。</p><blockquote><p>计算机是20世纪最先进的科学技术发明之一。</p></blockquote><a id="more"></a><h1 id="计算机是由什么组成的？"><a href="#计算机是由什么组成的？" class="headerlink" title="计算机是由什么组成的？"></a>计算机是由什么组成的？</h1><p><strong>一个完整的计算机系统，是由<code>硬件系统</code>和<code>软件系统</code>两大部分组成的。</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-8aefbecac43e38e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="computer.png"></p><h2 id="1-硬件系统"><a href="#1-硬件系统" class="headerlink" title="1. 硬件系统"></a>1. 硬件系统</h2><p>主要分为主机和外设两部分，是指那些构成计算机系统的物理实体，它们主要由各种各样的电子器件和机电装置组成。</p><p>从ENIAC(世界上第一台计算机)到当前最先进的计算机，硬件系统的设计采用的都是 冯·诺依曼体系结构。</p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-5f9b4bea1ca081e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="冯诺依曼体系结构.png"></p><blockquote><p>运算器:　负责数据的算术运算和逻辑运算，即数据的加工处理。</p><p>控制器:　是整个计算机的中枢神经，分析程序规定的控制信息，并根据程序要求进行控制，协调计算机各部分组件工作及内存与外设的访问等。</p><p>运算器和控制器统称中央处理器（即CPU)</p><p>存储器:　实现记忆功能的部件，用来存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息。</p><p>输入设备:　实现将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机。</p><p>输出设备:　实现将计算机处理后生成的中间结果或最后结果（各种数据符号及文字或各种控制信号等信息）输出出来。</p></blockquote><h2 id="2-软件系统"><a href="#2-软件系统" class="headerlink" title="2. 软件系统"></a>2. 软件系统</h2><p>主要分为系统软件和应用软件，是指计算机证运行所需的各种各样的计算机程序。</p><p>系统软件的任务是既要保证计算机硬件的正常工作，又要使计算机硬件的性能得到充分发挥，并且为计算机用户提供一个比较直观、方便和友好的使用界面。</p><h3 id="2-1-操作系统（Operation-System，OS）"><a href="#2-1-操作系统（Operation-System，OS）" class="headerlink" title="2.1 操作系统（Operation System，OS）"></a>2.1 操作系统（Operation System，OS）</h3><ul><li>没有安装操作系统的计算机，通常被称为 <strong>裸机</strong></li><li>如果想在 <strong>裸机</strong> 上运行自己所编写的程序，就必须用机器语言书写程序</li></ul><blockquote><p>操作系统作为接口的示意图</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/3365001-724f676482e34f05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="001_OS作为接口的示意图.png"></p><h4 id="2-1-1-操作系统的作用："><a href="#2-1-1-操作系统的作用：" class="headerlink" title="2.1.1 操作系统的作用："></a>2.1.1 操作系统的作用：</h4><ul><li>是现代计算机系统中 <strong>最基本和最重要</strong> 的系统软件</li><li>主要作用是<strong>管理好硬件设备</strong>，并为用户和应用程序提供一个简单的接口，以便于使用</li><li>而其他的诸如驱动程序、编译程序、数据库管理系统，以及大量的应用软件，都直接依赖于操作系统的支持</li></ul><h3 id="2-2-其他系统程序"><a href="#2-2-其他系统程序" class="headerlink" title="2.2 其他系统程序"></a>2.2 其他系统程序</h3><ul><li><p><strong>驱动程序</strong>：真正管理和控制硬件的程序，往往操作系统会携带一些默认版本</p></li><li><p><strong>语言处理程序</strong>：也称为编译程序，作用是把程序员用某种编程语言(如Python)所编写的程序，翻译成计算机可执行的机器语言。机器语言也被称为机器码，是可以通过CPU进行分析和执行的指令集。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是计算机？&quot;&gt;&lt;a href=&quot;#什么是计算机？&quot; class=&quot;headerlink&quot; title=&quot;什么是计算机？&quot;&gt;&lt;/a&gt;什么是计算机？&lt;/h1&gt;&lt;p&gt;计算机（computer）俗称电脑，是现代一种用于高速计算的电子机器，可以进行数值计算，又可以进行逻辑判断，还具有存储记忆功能，且能够按照程序的运行，自动、高速处理数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;计算机是20世纪最先进的科学技术发明之一。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python 基础" scheme="http://jovelin.cn/categories/Python-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机" scheme="http://jovelin.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Python 基础学习大纲</title>
    <link href="http://jovelin.cn/2017/06/21/Python%20%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2/"/>
    <id>http://jovelin.cn/2017/06/21/Python 基础学习大纲/</id>
    <published>2017-06-21T12:34:44.000Z</published>
    <updated>2018-07-28T02:03:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><p>1.掌握 Python 基础语法, 具备基础的编程能力；</p><p>2.建立起编程思维以及面向对象程序设计思想。</p><p>3.能够熟练使用 Python 技术完成较小程序的开发以及简单小游戏程序的开发。</p><a id="more"></a><hr><h3 id="学习知识点"><a href="#学习知识点" class="headerlink" title="学习知识点"></a>学习知识点</h3><h4 id="1-计算机组成原理"><a href="#1-计算机组成原理" class="headerlink" title="1.计算机组成原理"></a>1.计算机组成原理</h4><p>认识操作系统以及操作系统的作用</p><h4 id="2-认识-Python"><a href="#2-认识-Python" class="headerlink" title="2.认识 Python"></a>2.认识 Python</h4><p>认识 Python 及了解 Python 发展历史</p><h4 id="3-Python-开发环境"><a href="#3-Python-开发环境" class="headerlink" title="3.Python 开发环境"></a>3.Python 开发环境</h4><p>Python 开发环境的搭建、Sublime 使用、Python 交互式终端使用、IPython 交互式终端使用、Pycharm 使用</p><h4 id="4-Python-基础变量"><a href="#4-Python-基础变量" class="headerlink" title="4.Python 基础变量"></a>4.Python 基础变量</h4><p>变量以及变量的类型、标识符和关键字、变量名命名方式、算数运算符、变量数据类型转换、输入和输出、注释 </p><h4 id="5-逻辑控制语句"><a href="#5-逻辑控制语句" class="headerlink" title="5.逻辑控制语句"></a>5.逻辑控制语句</h4><p>if语句基本格式、if…else…语句、if…elif..else语句、逻辑运算符、比较关系运算符、运算符优先级、while循环语法格式、while嵌套应用、break的用法、continue的用法 </p><h4 id="6-高级变量类型"><a href="#6-高级变量类型" class="headerlink" title="6.高级变量类型"></a>6.高级变量类型</h4><p>列表概念及操作、元组概念及操作、字典概念及操作、字符串概念及操作、集合概念及操作、for循环及for…else用法 </p><h4 id="7-函数应用"><a href="#7-函数应用" class="headerlink" title="7.函数应用"></a>7.函数应用</h4><p>函数的基本语法、函数执行流程、文档注释、带参数的函数、带返回值的函数、函数的嵌套调用、匿名函数、递归函数、局部变量和全局变量、引用 </p><h4 id="8-文件操作"><a href="#8-文件操作" class="headerlink" title="8.文件操作"></a>8.文件操作</h4><p>文件的概念、文件的打开与关闭、文件读写, 以及文件定位读写、文件、目录相关操作 </p><h4 id="9-面向对象"><a href="#9-面向对象" class="headerlink" title="9.面向对象"></a>9.面向对象</h4><p>面向对象介绍、类和对象的概念、魔术方法的意义及作用、对象成员的访问控制权限、继承的概念及意义、继承、多层继承和多继承、多态的概念以及应用、类属性和实例属性、实例方法、类方法、静态方法、设计模式: 单例模式</p><h4 id="10-异常处理"><a href="#10-异常处理" class="headerlink" title="10.异常处理"></a>10.异常处理</h4><p>理解异常的作用、捕获异常、异常的传递规则、自定义异常 </p><h4 id="11-模块和包"><a href="#11-模块和包" class="headerlink" title="11.模块和包"></a>11.模块和包</h4><p>模块和包的概念、<strong>all</strong>的用法、import语句用法、from…import…用法、from…import * 用法</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h3&gt;&lt;p&gt;1.掌握 Python 基础语法, 具备基础的编程能力；&lt;/p&gt;
&lt;p&gt;2.建立起编程思维以及面向对象程序设计思想。&lt;/p&gt;
&lt;p&gt;3.能够熟练使用 Python 技术完成较小程序的开发以及简单小游戏程序的开发。&lt;/p&gt;
    
    </summary>
    
      <category term="Python 基础" scheme="http://jovelin.cn/categories/Python-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Python 基础" scheme="http://jovelin.cn/tags/Python-%E5%9F%BA%E7%A1%80/"/>
    
      <category term="学习大纲" scheme="http://jovelin.cn/tags/%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2/"/>
    
  </entry>
  
</feed>
