<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jovelin&#39;s Blog</title>
  
  <subtitle>Python The old farmer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jovelin.cn/"/>
  <updated>2018-07-18T03:10:23.000Z</updated>
  <id>http://jovelin.cn/</id>
  
  <author>
    <name>曹永林</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL 命令语句</title>
    <link href="http://jovelin.cn/2018/07/18/MySQL%20%E5%91%BD%E4%BB%A4%E8%AF%AD%E5%8F%A5/"/>
    <id>http://jovelin.cn/2018/07/18/MySQL 命令语句/</id>
    <published>2018-07-18T02:00:01.000Z</published>
    <updated>2018-07-18T03:10:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、命令行脚本（重点）"><a href="#一、命令行脚本（重点）" class="headerlink" title="一、命令行脚本（重点）"></a>一、命令行脚本（重点）</h3><h4 id="1-mysql服务器操作"><a href="#1-mysql服务器操作" class="headerlink" title="1. mysql服务器操作"></a>1. mysql服务器操作</h4><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">启动: sudo service mysql start</span><br><span class="line">查看: <span class="keyword">ps</span> -aux| <span class="keyword">grep</span> <span class="string">'mysql'</span></span><br><span class="line">停止: sudo service mysql <span class="keyword">stop</span></span><br><span class="line">重启：sudo service mysql restart</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="2-mysql登录操作"><a href="#2-mysql登录操作" class="headerlink" title="2. mysql登录操作"></a>2. mysql登录操作</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">登录: mysql -u root -p</span><br><span class="line">退出: <span class="keyword">exit</span><span class="regexp">/quit</span></span><br></pre></td></tr></table></figure><h4 id="3-数据库操作"><a href="#3-数据库操作" class="headerlink" title="3. 数据库操作"></a>3. 数据库操作</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 掌握命令行中的数据库操作：使用、查看、创建、删除</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">-- 使用数据库</span></span><br><span class="line"><span class="keyword">use</span> db_xxx;</span><br><span class="line"><span class="comment">-- 查看所有数据库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"><span class="comment">-- 查看当前数据库</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">database</span>();</span><br><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db_xxx <span class="keyword">charset</span>=utf8;</span><br><span class="line"><span class="comment">-- 查看创建语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">database</span> db_xxx;</span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> db_xxx;</span><br></pre></td></tr></table></figure><h4 id="4-数据表操作"><a href="#4-数据表操作" class="headerlink" title="4. 数据表操作"></a>4. 数据表操作</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 掌握命令行中的数据表操作：查看、创建、修改、删除</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">-- 查看</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 数据表名字 (字段 类型 约束[, 字段 类型 约束]);</span><br><span class="line"><span class="comment">-- 修改</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span>|<span class="keyword">modify</span>|<span class="keyword">change</span>|<span class="keyword">drop</span> 列名 类型及约束;</span><br><span class="line"><span class="comment">-- 添加字段 </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 类型;</span><br><span class="line"><span class="comment">-- 修改字段：不重命名版</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">modify</span> 列名 类型及约束;</span><br><span class="line"><span class="comment">-- 修改字段：重命名版</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">change</span> 原名 新名 类型及约束;</span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br></pre></td></tr></table></figure><blockquote><p>Mysql 增加、删除外键：<a href="https://blog.csdn.net/qq_34988341/article/details/78305892" target="_blank" rel="noopener">https://blog.csdn.net/qq_34988341/article/details/78305892</a></p></blockquote><h4 id="5-数据-记录-的增删改查curd"><a href="#5-数据-记录-的增删改查curd" class="headerlink" title="5. 数据(记录)的增删改查curd"></a>5. 数据(记录)的增删改查curd</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 掌握命令行中的对数据表中数据的操作：增加、删除、修改和基本查询</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">-- 新增</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(列<span class="number">1</span>,...) <span class="keyword">values</span>(值<span class="number">1</span>,...)</span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br><span class="line"><span class="comment">-- 修改</span></span><br><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 列<span class="number">1</span>=值<span class="number">1</span>,列<span class="number">2</span>=值<span class="number">2.</span>.. <span class="keyword">where</span> 条件;</span><br><span class="line"><span class="comment">-- 基本查询</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><h3 id="二、高级查询（难点）"><a href="#二、高级查询（难点）" class="headerlink" title="二、高级查询（难点）"></a>二、高级查询（难点）</h3><h4 id="1-掌握select查询所有字段、指定字段的数据"><a href="#1-掌握select查询所有字段、指定字段的数据" class="headerlink" title="1. 掌握select查询所有字段、指定字段的数据"></a>1. 掌握select查询所有字段、指定字段的数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> students;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,age <span class="keyword">from</span> students;</span><br></pre></td></tr></table></figure><h4 id="2-掌握消除重复行命令distinct"><a href="#2-掌握消除重复行命令distinct" class="headerlink" title="2. 掌握消除重复行命令distinct"></a>2. 掌握消除重复行命令distinct</h4><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> gender <span class="keyword">from</span> students;</span><br></pre></td></tr></table></figure><h4 id="3-掌握as给字段、表起别名"><a href="#3-掌握as给字段、表起别名" class="headerlink" title="3. 掌握as给字段、表起别名"></a>3. 掌握as给字段、表起别名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.name <span class="keyword">as</span> <span class="string">'姓名'</span>,s.age <span class="keyword">as</span> <span class="string">'年龄'</span> <span class="keyword">from</span> students <span class="keyword">as</span> s;</span><br></pre></td></tr></table></figure><h4 id="4-掌握条件查询where后跟比较运算符、逻辑运算符的用法"><a href="#4-掌握条件查询where后跟比较运算符、逻辑运算符的用法" class="headerlink" title="4. 掌握条件查询where后跟比较运算符、逻辑运算符的用法"></a>4. 掌握条件查询where后跟比较运算符、逻辑运算符的用法</h4><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">&gt;   &lt;   &gt;=  &lt;=  =   !=   </span><br><span class="line"><span class="keyword">and</span>  <span class="keyword">or</span> <span class="keyword">not</span></span><br></pre></td></tr></table></figure><blockquote><p>优先级：not&gt;and&gt;or，如果同时出现并希望先算or，需要结合()使用</p></blockquote><h4 id="5-掌握条件查询中的模糊查询like和范围查询in"><a href="#5-掌握条件查询中的模糊查询like和范围查询in" class="headerlink" title="5. 掌握条件查询中的模糊查询like和范围查询in"></a>5. 掌握条件查询中的模糊查询like和范围查询in</h4><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">name</span> like  '%杰'</span><br><span class="line">  % ： 代表任意个字符</span><br><span class="line">  _ : 代表一个字符</span><br><span class="line"></span><br><span class="line"><span class="built_in">id</span>  <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>)</span><br></pre></td></tr></table></figure><h4 id="6-掌握空判断is-null和非空判断is-not-null"><a href="#6-掌握空判断is-null和非空判断is-not-null" class="headerlink" title="6. 掌握空判断is null和非空判断is not null"></a>6. 掌握空判断is null和非空判断is not null</h4><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> height <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span>  height <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h4 id="7-掌握查询中使用order-by排序"><a href="#7-掌握查询中使用order-by排序" class="headerlink" title="7. 掌握查询中使用order by排序"></a>7. 掌握查询中使用order by排序</h4><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">放在 <span class="keyword">from</span>、<span class="keyword">where</span>、<span class="keyword">group</span> <span class="keyword">by</span>之后</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 列<span class="number">1</span> <span class="keyword">asc</span> ，列<span class="number">2</span> <span class="keyword">desc</span>；</span><br><span class="line"><span class="keyword">desc</span>: 降序</span><br><span class="line"><span class="keyword">asc</span>：升序，默认</span><br></pre></td></tr></table></figure><h4 id="8-掌握常用到的聚合函数count、max、min、sum、avg"><a href="#8-掌握常用到的聚合函数count、max、min、sum、avg" class="headerlink" title="8. 掌握常用到的聚合函数count、max、min、sum、avg"></a>8. 掌握常用到的聚合函数count、max、min、sum、avg</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">count</span><span class="params">(*)</span></span>\count(列)：总数 </span><br><span class="line"><span class="function"><span class="title">max</span><span class="params">(列)</span></span>: 最大值</span><br><span class="line"><span class="function"><span class="title">min</span><span class="params">(列)</span></span>: 最小值</span><br><span class="line"><span class="function"><span class="title">sum</span><span class="params">(列)</span></span> ： 求和</span><br><span class="line"><span class="function"><span class="title">avg</span><span class="params">(列)</span></span> ：求平均</span><br></pre></td></tr></table></figure><h4 id="9-掌握分组查询group-by-group-concat-字段名-聚合函数-having"><a href="#9-掌握分组查询group-by-group-concat-字段名-聚合函数-having" class="headerlink" title="9 掌握分组查询group by + group_concat(字段名)/聚合函数/having"></a>9 掌握分组查询group by + group_concat(字段名)/聚合函数/having</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">更精细化统计</span><br><span class="line">group by： 分组</span><br><span class="line">group_concat： 拼接字符串，拼接字段名</span><br><span class="line">聚合函数： 最大，最小，平均，计数，求和</span><br><span class="line">having： 对分组后的结果集进一步筛选</span><br><span class="line"></span><br><span class="line">注意1: select 列 中只能存放分组函数(比如聚合函数)，或是出现在group by子句中的分组标签</span><br><span class="line">注意2：</span><br><span class="line">where: 对源数据做条件筛选， 不能接聚合函数</span><br><span class="line">having: 是对分组之后的数据做进一步的筛选操作, 有having就一定有group by, 有<span class="built_in"> group </span>by 不一定有having，接聚合函数</span><br></pre></td></tr></table></figure><h4 id="10-掌握分页查询获取部分行的命令limit"><a href="#10-掌握分页查询获取部分行的命令limit" class="headerlink" title="10 掌握分页查询获取部分行的命令limit"></a>10 掌握分页查询获取部分行的命令limit</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">limit [<span class="keyword">start</span>],<span class="keyword">count</span> </span><br><span class="line"><span class="number">1.</span> 放在查询语句的最后</span><br><span class="line"><span class="number">2.</span> <span class="keyword">start</span>=(page<span class="number">-1</span>)*<span class="keyword">count</span></span><br></pre></td></tr></table></figure><h4 id="11-掌握连接查询inner-left-right-join"><a href="#11-掌握连接查询inner-left-right-join" class="headerlink" title="11 掌握连接查询inner/left/right join"></a>11 掌握连接查询inner/left/right join</h4><figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">inner <span class="built_in">join</span> <span class="keyword">on</span> :内连接(结果仅包含符合连接条件的两表中的行)</span><br><span class="line"><span class="built_in">left</span> <span class="built_in">join</span> <span class="keyword">on</span> : 左连接(完全显示左表所有的行，如果左表中某行 在右表中没有匹配的行，则右表该行显示<span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">right</span> <span class="built_in">join</span> <span class="keyword">on</span> : 右连接(与左连接相反)</span><br></pre></td></tr></table></figure><h4 id="12-掌握子查询的方法"><a href="#12-掌握子查询的方法" class="headerlink" title="12 掌握子查询的方法"></a>12 掌握子查询的方法</h4><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">查询中嵌套查询：</span><br><span class="line"> 分为三种：</span><br><span class="line">  标量子查询: 子查询的结果为一个值<span class="comment">(一行一列)</span></span><br><span class="line">  列子查询：  子查询的结果为一个列<span class="comment">(一列多行)</span></span><br><span class="line">  表子查询:   子查询的结果为一个表<span class="comment">(多行多列)</span></span><br></pre></td></tr></table></figure><h3 id="三、查询总结"><a href="#三、查询总结" class="headerlink" title="三、查询总结"></a>三、查询总结</h3><ul><li><strong>查询的完整格式 （^_^ 不要被吓到 其实很简单 ! _ !）</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> select_expr [,select_expr,...] [      </span><br><span class="line">      <span class="keyword">FROM</span> tb_name</span><br><span class="line">      [<span class="keyword">WHERE</span> 条件判断]</span><br><span class="line">      [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &#123;col_name | postion&#125; [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>], ...] </span><br><span class="line">      [<span class="keyword">HAVING</span> <span class="keyword">WHERE</span> 条件判断]</span><br><span class="line">      [<span class="keyword">ORDER</span> <span class="keyword">BY</span> &#123;col_name|expr|postion&#125; [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>], ...]</span><br><span class="line">      [ <span class="keyword">LIMIT</span> &#123;[<span class="keyword">offset</span>,]rowcount | <span class="keyword">row_count</span> <span class="keyword">OFFSET</span> <span class="keyword">offset</span>&#125;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li><strong>完整的select语句</strong></li></ul><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">select distinct *</span><br><span class="line"><span class="keyword">from</span> 表名</span><br><span class="line">where <span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">group by <span class="built_in">..</span>. having <span class="built_in">..</span>.</span><br><span class="line">order by <span class="built_in">..</span>.</span><br><span class="line">limit start,count</span><br></pre></td></tr></table></figure><ul><li><strong>执行顺序</strong></li></ul><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> 表名</span><br><span class="line">where <span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">group by <span class="built_in">..</span>.</span><br><span class="line">select distinct *</span><br><span class="line">having <span class="built_in">..</span>.</span><br><span class="line">order by <span class="built_in">..</span>.</span><br><span class="line">limit start,count</span><br></pre></td></tr></table></figure><blockquote><p>实际使用中，只是语句中某些部分的组合，而不是全部</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、命令行脚本（重点）&quot;&gt;&lt;a href=&quot;#一、命令行脚本（重点）&quot; class=&quot;headerlink&quot; title=&quot;一、命令行脚本（重点）&quot;&gt;&lt;/a&gt;一、命令行脚本（重点）&lt;/h3&gt;&lt;h4 id=&quot;1-mysql服务器操作&quot;&gt;&lt;a href=&quot;#1-mysql服务器操作&quot; class=&quot;headerlink&quot; title=&quot;1. mysql服务器操作&quot;&gt;&lt;/a&gt;1. mysql服务器操作&lt;/h4&gt;&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;启动: sudo service mysql start&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查看: &lt;span class=&quot;keyword&quot;&gt;ps&lt;/span&gt; -aux| &lt;span class=&quot;keyword&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;mysql&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;停止: sudo service mysql &lt;span class=&quot;keyword&quot;&gt;stop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;重启：sudo service mysql restart&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/categories/Python/MySQL/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/tags/MySQL/"/>
    
      <category term="MySQL 命令" scheme="http://jovelin.cn/tags/MySQL-%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 安装与介绍</title>
    <link href="http://jovelin.cn/2018/07/16/MySQL%20%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jovelin.cn/2018/07/16/MySQL 安装与介绍/</id>
    <published>2018-07-16T02:00:01.000Z</published>
    <updated>2018-07-18T05:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、数据库简介"><a href="#一、数据库简介" class="headerlink" title="一、数据库简介"></a>一、数据库简介</h3><h4 id="1-数据存储"><a href="#1-数据存储" class="headerlink" title="1.数据存储"></a>1.数据存储</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据库是由一些特殊的文件组成，用来存储数据</span><br></pre></td></tr></table></figure><h4 id="2-数据库分类"><a href="#2-数据库分类" class="headerlink" title="2.数据库分类"></a>2.数据库分类</h4><ul><li>关系型数据库</li><li>非关系型数据库</li></ul><a id="more"></a><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 关系型数据库</span><br><span class="line"></span><br><span class="line">    建立在关系模型基础上的数据库，通俗讲这种数据库由多个表组成，表与表存在一定的关系</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>. 主要的几种关系型数据库</span><br><span class="line"></span><br><span class="line">    oracle：在大型项目中使用,银行,电信等项目</span><br><span class="line">    mysql：web时代使用最广泛的关系型数据库</span><br><span class="line">    <span class="keyword">ms</span> <span class="title">sql</span> server：在微软的项目中使用</span><br><span class="line">    sqlite：轻量级数据库，主要应用在移动平台</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 关系型数据库核心的元素</span><br><span class="line"></span><br><span class="line">    数据行（记录）</span><br><span class="line">    数据列（字段）</span><br><span class="line">    数据表（数据行的集合）</span><br><span class="line">    数据库（数据表的集合）</span><br><span class="line">    主键（特殊的字段，用来唯一标识记录的唯一性）</span><br></pre></td></tr></table></figure><h4 id="3-RDBMS"><a href="#3-RDBMS" class="headerlink" title="3. RDBMS"></a>3. RDBMS</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">1. RDBMS：Relational Database Management System</span><br><span class="line"></span><br><span class="line">    关系型数据库管理系统，用于管理数据库</span><br><span class="line"></span><br><span class="line">2. RDBMS 与关系型数据库的关系</span><br><span class="line">    </span><br><span class="line">    通过 RDBMS 实现对数据库的增删改查</span><br></pre></td></tr></table></figure><h4 id="4-SQL"><a href="#4-SQL" class="headerlink" title="4. SQL"></a>4. SQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SQL(Structured Query Language) 结构化查询语言，是一种用来操作RDBMS的数据库语言，当前关系型数据库都支持使用SQL语言进行操作，</span><br><span class="line">也就是说可以通过 SQL 操作 oracle,sql server,mysql,sqlite 等等所有的关系型的数据库。</span><br><span class="line"></span><br><span class="line">- DQL：数据查询语言，用于对数据进行查询，如<span class="keyword">select</span></span><br><span class="line">- DML：数据操作语言，对数据进行增加、修改、删除，如<span class="keyword">insert</span>、udpate、<span class="keyword">delete</span></span><br><span class="line">- <span class="keyword">DDL</span>：数据定义语言，进行数据库、表的管理等，如<span class="keyword">create</span>、<span class="keyword">drop</span></span><br><span class="line"></span><br><span class="line">- TPL：事务处理语言，对事务进行处理，包括<span class="keyword">begin</span> <span class="keyword">transaction</span>、<span class="keyword">commit</span>、<span class="keyword">rollback</span></span><br><span class="line">- DCL：数据控制语言，进行授权与权限回收，如<span class="keyword">grant</span>、<span class="keyword">revoke</span></span><br><span class="line">- CCL：指针控制语言，通过控制指针完成表的操作，如<span class="keyword">declare</span> <span class="keyword">cursor</span></span><br></pre></td></tr></table></figure><blockquote><p>提示： sql语句不区分大小写，每条sql语句后面加;    </p></blockquote><h4 id="5-MySQL"><a href="#5-MySQL" class="headerlink" title="5. MySQL"></a>5. MySQL</h4><p>MySQL 官方网站：<a href="https://www.mysql.com/" target="_blank" rel="noopener">www.mysql.com</a></p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">MySQL 是一个关系型数据库管理系统，最早由瑞典 MySQL AB 公司开发，后来被Sun公司收购，</span><br><span class="line">Sun公司后来又被 <span class="keyword">Oracle </span>公司收购，目前属于 <span class="keyword">Oracle </span>旗下产品</span><br><span class="line"></span><br><span class="line">MySQL 对跨平台支持性好，提供了多种主流语言调用的API</span><br><span class="line"></span><br><span class="line">MySQL 市场占有率高，且开源，免费，是中小型项目首选的关系型数据库系统</span><br></pre></td></tr></table></figure><p><br></p><h3 id="二、MySql数据库的安装"><a href="#二、MySql数据库的安装" class="headerlink" title="二、MySql数据库的安装"></a>二、MySql数据库的安装</h3><h4 id="1-安装mysql服务端"><a href="#1-安装mysql服务端" class="headerlink" title="1. 安装mysql服务端"></a>1. 安装mysql服务端</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">a&gt; 安装mysql服务端</span><br><span class="line">    Linux命令安装：sudo apt-get install mysql-server</span><br><span class="line"> </span><br><span class="line">b&gt; 命令管理：服务器的开、关、重启、查看进程</span><br><span class="line">    启动: sudo service mysql start</span><br><span class="line">    查看: ps -aux| grep <span class="string">'mysql'</span></span><br><span class="line">    停止: sudo service mysql stop</span><br><span class="line">    重启：sudo service mysql restart</span><br><span class="line">    </span><br><span class="line">    登录: mysql -u root -p</span><br><span class="line">    退出: <span class="keyword">exit</span><span class="regexp">/quit</span></span><br></pre></td></tr></table></figure><h4 id="2-配置mysql服务端"><a href="#2-配置mysql服务端" class="headerlink" title="2. 配置mysql服务端"></a>2. 配置mysql服务端</h4><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">a&gt; 配置文件</span><br><span class="line">/etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line"></span><br><span class="line">b&gt; 常用配置项:</span><br><span class="line">bind-address：服务器绑定的ip，默认为<span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line">port：端口，默认为<span class="number">3306</span></span><br><span class="line">datadir：数据库目录，默认为/var/<span class="class"><span class="keyword">lib</span>/<span class="title">mysql</span></span></span><br><span class="line">general_log_file：普通日志，默认为/var/log/mysql/mysql.log</span><br><span class="line">log_error：错误日志，默认为/var/log/mysql/error.log</span><br></pre></td></tr></table></figure><h4 id="3-客户端"><a href="#3-客户端" class="headerlink" title="3. 客户端"></a>3. 客户端</h4><p>可以到 <a href="https://www.navicat.com.cn/" target="_blank" rel="noopener">Navicat 官网</a> 下载</p><p>将压缩文件拷贝到ubuntu虚拟机中，放到桌面上，解压</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">a&gt; 图形化界面客户端 <span class="symbol">navicat:</span></span><br><span class="line">解压： tar -xzvf navicat.tar.gz </span><br><span class="line">执行命令：</span><br><span class="line">python<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/navicat112_mysql_cs_x64</span><span class="variable">$ </span>./start_navicat </span><br><span class="line"></span><br><span class="line">关于注册的问题：</span><br><span class="line">  删除文件：</span><br><span class="line">    cd ~</span><br><span class="line">rm -r .navicat64  </span><br><span class="line"></span><br><span class="line">b&gt; 命令行客户端</span><br><span class="line">安装命令客户端：</span><br><span class="line">    sudo apt-get install mysql-client</span><br><span class="line">登录mysql服务端：</span><br><span class="line">    mysql -u root -pmysql</span><br></pre></td></tr></table></figure><h3 id="三、navicat图形界面客户端工具使用-了解"><a href="#三、navicat图形界面客户端工具使用-了解" class="headerlink" title="三、navicat图形界面客户端工具使用(了解)"></a>三、navicat图形界面客户端工具使用(了解)</h3><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby"> 连接服务端 ： 用户名，密码，数据库服务器主机的ip地址</span></span><br><span class="line"><span class="ruby">- 创建数据库 ： 字符集，排序</span></span><br><span class="line"><span class="ruby">- 创建表(字段，类型与约束)： t_employee（id，name，age）</span></span><br><span class="line"><span class="ruby">- 添加记录，删除记录，修改记录</span></span><br></pre></td></tr></table></figure><h3 id="四、数据类型与约束"><a href="#四、数据类型与约束" class="headerlink" title="四、数据类型与约束"></a>四、数据类型与约束</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 数据类型：</span><br><span class="line">   使用数据类型的原则是：够用就行，尽量使用取值范围小的，而不用大的，这样可以更多的节省存储空间</span><br><span class="line"></span><br><span class="line">   <span class="number">1.</span> int： 整形</span><br><span class="line"><span class="number">2.</span> bit：位（<span class="number">0</span> | <span class="number">1</span>）</span><br><span class="line"><span class="number">2.</span> decimal： 浮点数  # dicemal(<span class="number">5</span>,<span class="number">2</span>) # 总位数<span class="number">5</span>位，小数位<span class="number">2</span>位</span><br><span class="line"><span class="number">3.</span> varchar： 可变字符类型 # 可节省存储空间</span><br><span class="line"><span class="number">4.</span> enum： 枚举类型 # gender enum(<span class="string">"男"</span>,<span class="string">"女"</span>) 注意：有中文时，数据库编码必须支持中文（utf<span class="number">-8</span> 可以，latin1 不行）</span><br><span class="line"><span class="number">5.</span> datetime： 日期时间类型</span><br><span class="line"><span class="number">6.</span> tinyint： 非贪婪整形</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 数据约束：</span><br><span class="line"><span class="number">1.</span> 主键： primary <span class="type">key</span>(id)</span><br><span class="line"><span class="number">2.</span> 自增： auto_increment</span><br><span class="line"><span class="number">2.</span> 非空： not null</span><br><span class="line"><span class="number">3.</span> 唯一值： unique</span><br><span class="line"><span class="number">4.</span> 缺省值： <span class="section">default</span></span><br><span class="line"><span class="number">5.</span> 外键： foreign <span class="type">key</span> </span><br><span class="line"><span class="number">6.</span> 无符号： unsigned</span><br></pre></td></tr></table></figure><h3 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.  </span>InnoDB，MyISAM 数据库引擎</span><br><span class="line"><span class="code">mysql 创建表时，默认是InnoDB引擎</span></span><br><span class="line"><span class="code">两种类型有什么区别：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。 </span></span><br><span class="line"><span class="code">MyISAM类型的表强调的是性能，其执行速度比InnoDB类型更快，但是不提供事务等高级特性，而InnoDB提供事务支持,行级锁，高并发。一般开发中默认使用的是innodb引擎</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、数据库简介&quot;&gt;&lt;a href=&quot;#一、数据库简介&quot; class=&quot;headerlink&quot; title=&quot;一、数据库简介&quot;&gt;&lt;/a&gt;一、数据库简介&lt;/h3&gt;&lt;h4 id=&quot;1-数据存储&quot;&gt;&lt;a href=&quot;#1-数据存储&quot; class=&quot;headerlink&quot; title=&quot;1.数据存储&quot;&gt;&lt;/a&gt;1.数据存储&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;数据库是由一些特殊的文件组成，用来存储数据&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;2-数据库分类&quot;&gt;&lt;a href=&quot;#2-数据库分类&quot; class=&quot;headerlink&quot; title=&quot;2.数据库分类&quot;&gt;&lt;/a&gt;2.数据库分类&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;关系型数据库&lt;/li&gt;
&lt;li&gt;非关系型数据库&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/categories/Python/MySQL/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="MySQL" scheme="http://jovelin.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Python HTTP 协议与 web 静态服务器</title>
    <link href="http://jovelin.cn/2018/07/15/Python%20HTTP%20%E5%8D%8F%E8%AE%AE%E4%B8%8E%20web%20%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://jovelin.cn/2018/07/15/Python HTTP 协议与 web 静态服务器/</id>
    <published>2018-07-15T12:08:35.000Z</published>
    <updated>2018-07-18T02:08:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-超文本传输协议"><a href="#HTTP-超文本传输协议" class="headerlink" title="HTTP 超文本传输协议"></a>HTTP 超文本传输协议</h1><p><strong>超文本传输协议（HyperText Transfer Protocol）是一种应用层协议。</strong></p><p>HTTP是万维网的数据通信的基础。设计HTTP最初的目的是为了提供一种发布和接收HTML页面&lt;网页&gt;的方法。</p><ul><li>1989年蒂姆·伯纳斯-李在CERN研发</li><li>1999年公布现今广泛使用的HTTP 1.1版(RFC2616)</li></ul><a id="more"></a><h3 id="浏览器请求的基本流程"><a href="#浏览器请求的基本流程" class="headerlink" title="浏览器请求的基本流程"></a>浏览器请求的基本流程</h3><p><img src="https://upload-images.jianshu.io/upload_images/3365001-07b4a469d55b38bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="mini-web服务器工作流程"></p><h3 id="浏览器请求的-URL"><a href="#浏览器请求的-URL" class="headerlink" title="浏览器请求的 URL"></a>浏览器请求的 URL</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> www.baidu.com: 网站(网址)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   url(统一资源定位符):</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   完整版: http://www.baidu.com:80/aaa/bbb/index.html?username=aaa&amp;password=123</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       http/https: https是http加密后进行传输;(https收费...)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       端口: http: 80;    https: 443;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       /aaa/bbb/index.html: 请求的资源路径;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       username=aaa&amp;password=123: 传输的内容;(请求体...GET)</span></span><br></pre></td></tr></table></figure><h3 id="请求报文格式总结"><a href="#请求报文格式总结" class="headerlink" title="请求报文格式总结"></a>请求报文格式总结</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 总结: 请求报文格式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.请求行;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     GET / HTTP/1.1\r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.请求头;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     头属性: 属性值\r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     Host: www.baidu.com\r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.空行;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     \r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.请求体;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     username=jovelin&amp;password=123456</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 请求报文格式分析:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.请求行(request line)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   格式: 请求方式 资源路径 协议及版本号\r\n</span></span><br><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">   GET: 常用请求方式GET/POST;   (GET/POST/PUT/DELETE...)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       GET:  获取(从服务器获取信息的时候用...)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       POST: 发送(向服务器存储信息的时候用...)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   /: /aaa/bbb/index.html; 想要访问的页面/图片/音频...(明天要用...)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   HTTP/1.1: 协议及版本号</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   空行: \r\n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.请求头(request header)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   格式: 头属性: 头信息\r\n</span></span><br><span class="line">Host: www.baidu.com\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       Host: 主机;(记住...)</span></span><br><span class="line">Connection: keep-alive\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       Connection: 链接;(长连接)</span></span><br><span class="line">Upgrade-Insecure-Requests: 1\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       提示服务端我可以解析https;</span></span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       User-Agent: 用户代理;(浏览器及系统版本...)</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       Accept: 接收!</span></span><br><span class="line">Accept-Encoding: gzip, deflate, br\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       压缩: 数据压缩算法;</span></span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       语言: 中文;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.空行;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     \r\n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.请求体;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     username=jovelin&amp;password=123456</span></span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/3365001-28c36634d5de588c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="请求报文格式总结"></p><h3 id="响应报文格式总结"><a href="#响应报文格式总结" class="headerlink" title="响应报文格式总结"></a>响应报文格式总结</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 总结: 响应报文格式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.响应行;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   HTTP/1.1 200 OK\r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.响应头;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   头属性: 头信息\r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   Server: BWS/1.1\r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.换行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   \r\n</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.响应体;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   文本/图片/音频/视频/网页...</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 响应报文格式分析:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.响应行(response line)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   格式: 协议及版本号 状态码 英文解释\r\n</span></span><br><span class="line">HTTP/1.1 200 OK\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">       HTTP/1.1: 协议及版本号</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       200 OK: 状态码 英文解释</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.响应头(response header)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   格式: 头属性: 属性值\r\n</span></span><br><span class="line">Connection: Keep-Alive\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">   长连接</span></span><br><span class="line">Content-Encoding: gzip\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">   压缩格式</span></span><br><span class="line">Content-Type: text/html; charset=utf-8\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">   请求体的文本类型;</span></span><br><span class="line">Date: Wed, 14 Mar 2018 09:52:48 GMT\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">   更新时间</span></span><br><span class="line">Server: BWS/1.1\r\n</span><br><span class="line"><span class="meta">#</span><span class="bash">   服务器名:(记住,因为简单,以后用)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.空行;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     \r\n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.响应体(response body)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     文本/图片/音频/视频/网页...</span></span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/3365001-31f7768dcb76551e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="响应报文格式总结"></p><h3 id="网络响应状态码"><a href="#网络响应状态码" class="headerlink" title="网络响应状态码"></a>网络响应状态码</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>xx 成功  <span class="number">200</span> OK  （发送成功）</span><br><span class="line"><span class="number">3</span>xx 重定向 </span><br><span class="line"><span class="number">302</span> Moved Temporarily/<span class="number">302</span> Found   解释作用(暂时跳转)  <span class="number">301</span>/<span class="number">2</span>/<span class="number">3</span>/<span class="number">4</span>/<span class="number">7</span></span><br><span class="line"><span class="number">307</span> Internal Redirect（内部重定向）</span><br><span class="line"><span class="symbol">Location:</span> https:<span class="comment">//www.baidu.com</span></span><br><span class="line"><span class="number">4</span>xx 客户端错误 <span class="number">404</span> Not Found（客户端发送的页面没找打）</span><br><span class="line"><span class="symbol">http:</span><span class="comment">//help.xunlei.com/online/stat_inst.php?pid=0000&amp;thunderver=5.8.14.706&amp;thundertype=4&amp;peerid=000C294E4AE1J3J4</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//video.baomihua.com/play_error/-30001</span></span><br><span class="line"><span class="number">5</span>xx 服务器错误 <span class="number">503</span> Service Unavailable（服务器不能使用）</span><br></pre></td></tr></table></figure><h3 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h3><p><br></p><p><strong>TCP长/短连接 好比 地铁卡/单程票</strong></p><p><br></p><p>在HTTP/1.0中, 默认使用的是短连接.也就是说, 浏览器和服务器每进行一次HTTP操作, 就建立一次连接, 但任务结束就中断连接.如果客户端浏览器访问的某个HTML或其他类型的 Web 页中包含有其他的Web资源，如js文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p><p>但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码:</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Connection</span>:<span class="meta">keep</span>-alive</span><br></pre></td></tr></table></figure><p>在真正的读写操作之前，server与client之间必须建立一个连接，</p><p>当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，</p><p>连接的建立通过三次握手，释放则需要四次握手，</p><p>所以说每个连接的建立都是需要资源消耗和时间消耗的。</p><h4 id="TCP-短连接"><a href="#TCP-短连接" class="headerlink" title="TCP 短连接"></a>TCP 短连接</h4><p><strong>短连接一般只会在 client/server 间传递一次读写操作！</strong></p><ol><li>client 向 server 发起连接请求</li><li>server 接到请求，双方建立连接</li><li>client 向 server 发送消息</li><li>server 回应 client</li><li>一次读写完成，此时双方任何一个都可以发起 close 操作 (一般都是 client 先发起 close 操作。当然也不排除有特殊的情况。)</li></ol><h4 id="TCP-长连接"><a href="#TCP-长连接" class="headerlink" title="TCP 长连接"></a>TCP 长连接</h4><ol><li>client 向 server 发起连接</li><li>server 接到请求，双方建立连接</li><li>client 向 server 发送消息</li><li>server 回应 client</li><li>一次读写完成，连接不关闭</li><li>后续读写操作…</li><li>长时间操作之后 client 发起关闭请求</li></ol><h4 id="TCP长-短连接的优点和缺点"><a href="#TCP长-短连接的优点和缺点" class="headerlink" title="TCP长/短连接的优点和缺点"></a>TCP长/短连接的优点和缺点</h4><p>长连接可以省去较多的TCP建立和关闭的操作，节约时间。但是如果用户量太大容易造成服务器负载过高最终导致服务不可用。</p><p>短连接对于服务器来说实现起来较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但是如果用户访问量很大, 往往可能在很短时间内需要创建大量的连接，造成服务器响应速度过慢。</p><p><strong>总之：</strong></p><p>小的WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源来让套接字 保持存活-keep alive，</p><p>对于中大型WEB网站一般都采用长连接，好处是响应用户请求的时间更短，用户体验更好，虽然更耗硬件资源一些，但这都不是事儿。另外，数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>1.模拟服务器(服务端)</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 需求: 获取请求报文的格式;</span></span><br><span class="line"></span><br><span class="line">import <span class="built_in">socket</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tcp_socket = <span class="built_in">socket</span>.<span class="built_in">socket</span>(<span class="built_in">socket</span>.AF_INET, <span class="built_in">socket</span>.SOCK_STREAM)</span><br><span class="line">    tcp_socket.setsockopt(<span class="built_in">socket</span>.SOL_SOCKET, <span class="built_in">socket</span>.SO_REUSEADDR, True)</span><br><span class="line">    tcp_socket.bind((<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>))</span><br><span class="line">    tcp_socket.listen(<span class="number">128</span>)</span><br><span class="line">    print(<span class="string">"服务已开启..."</span>)</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        service_client_socket, ip_port = tcp_socket.accept()</span><br><span class="line">        print(ip_port, <span class="string">"已连接..."</span>)</span><br><span class="line">        data_bin = service_client_socket.recv(<span class="number">5000</span>)</span><br><span class="line">        print(<span class="string">"二进制数据："</span>, data_bin)</span><br><span class="line">        print(<span class="string">"解析后数据："</span>, data_bin.decode())</span><br><span class="line">        service_client_socket.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><p>2.模拟浏览器(客户端)</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 需求: 获取响应报文的格式内容并保存;</span></span><br><span class="line"></span><br><span class="line">import <span class="built_in">socket</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建TCP连接</span></span><br><span class="line">    tcp_socket = <span class="built_in">socket</span>.<span class="built_in">socket</span>(<span class="built_in">socket</span>.AF_INET, <span class="built_in">socket</span>.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># DNS解析 和 连接HTTP服务器</span></span><br><span class="line">    tcp_socket.connect((<span class="string">"www.baidu.com"</span>, <span class="number">80</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 组包 发送HTTP请求报文</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求行</span></span><br><span class="line">    request_line = <span class="string">"GET / HTTP/1.1\r\n"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求头</span></span><br><span class="line">    request_header = <span class="string">"Host: www.baidu.com\r\n"</span></span><br><span class="line">    request_data = request_line + request_header + <span class="string">"\r\n"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送请求</span></span><br><span class="line">    tcp_socket.<span class="built_in">send</span>(request_data.encode())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收响应报文</span></span><br><span class="line">    response_data = tcp_socket.recv(<span class="number">4096</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对响应报文进行解析 -- 切割</span></span><br><span class="line">    response_str_data = response_data.decode()</span><br><span class="line">    <span class="comment"># print(response_data)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># '\r\n\r\n'之后的数据就是响应体数据</span></span><br><span class="line">    index = response_str_data.find(<span class="string">"\r\n\r\n"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 切割出的数据就是文件数据</span></span><br><span class="line">    html_data = response_str_data[index + <span class="number">4</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># data_file = open("index.html", "wb")</span></span><br><span class="line">    <span class="comment"># data_file.write(html_data.encode())</span></span><br><span class="line">    <span class="comment"># data_file.close()</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"index.html"</span>, <span class="string">"wb"</span>) <span class="keyword">as</span> <span class="built_in">file</span>:</span><br><span class="line">        <span class="built_in">file</span>.<span class="built_in">write</span>(html_data.encode())</span><br><span class="line">        <span class="comment"># 如果是长连接,还有很多内容没有收到,需要死循环接收</span></span><br><span class="line">        <span class="keyword">while</span> True:</span><br><span class="line">            <span class="comment"># 后面在获取到的响应内容,就不包含响应行和响应头了</span></span><br><span class="line">            data_bin = tcp_socket.recv(<span class="number">4096</span>)</span><br><span class="line">            <span class="keyword">if</span> data_bin:</span><br><span class="line">                <span class="built_in">file</span>.<span class="built_in">write</span>(data_bin)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭套接字</span></span><br><span class="line">    tcp_socket.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><ol start="3"><li>web 静态服务器</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebServer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Web 服务器类"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ip, port)</span>:</span></span><br><span class="line">        <span class="comment"># 创建套接字</span></span><br><span class="line">        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        <span class="comment"># 设置套接字复用地址</span></span><br><span class="line">        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 绑定IP地址和端口</span></span><br><span class="line">        self.socket.bind((ip, port))</span><br><span class="line">        <span class="comment"># 设置被动套接字</span></span><br><span class="line">        self.socket.listen(<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startup</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""等待客户端连接"""</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="comment"># 等待被连接</span></span><br><span class="line">            service_client_socket, ip_port = self.socket.accept()</span><br><span class="line">            print(ip_port, <span class="string">"连接成功."</span>, end=<span class="string">"\n\n"</span>)</span><br><span class="line">            <span class="comment"># 处理请求</span></span><br><span class="line">            gevent.spawn(self.client_handler, service_client_socket)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">client_handler</span><span class="params">(self, service_client_socket)</span>:</span></span><br><span class="line">        <span class="string">"""处理客户端请求"""</span></span><br><span class="line">        request_data_bin = service_client_socket.recv(<span class="number">4096</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> request_data_bin:</span><br><span class="line">            print(<span class="string">'客户端已经断开连接.'</span>, end=<span class="string">"\n\n"</span>)</span><br><span class="line">            service_client_socket.close()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"客户端请求报文："</span>, request_data_bin, end=<span class="string">"\n\n"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 解析 HTTP 文本</span></span><br><span class="line">        my_http = self.parse_http(request_data_bin.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取固定页面数据</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response_line = <span class="string">'HTTP/1.1 200 OK\r\n'</span></span><br><span class="line">            response_header = <span class="string">'Server: PythonWebServer1.0\r\n'</span></span><br><span class="line">            file = open(<span class="string">'./static'</span> + my_http[<span class="string">'url'</span>], <span class="string">'rb'</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            response_line = <span class="string">'HTTP/1.1 404 NOT FOUND\r\n'</span></span><br><span class="line">            response_header = <span class="string">'Server: PythonWebServer1.0\r\n'</span></span><br><span class="line">            file = open(<span class="string">'./static/404.html'</span>, <span class="string">'rb'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取文件内容</span></span><br><span class="line">        response_content = file.read()</span><br><span class="line">        file.close()</span><br><span class="line">        <span class="comment"># 拼接响应报文</span></span><br><span class="line">        response_data = (response_line + response_header + <span class="string">'\r\n'</span>).encode(<span class="string">'utf-8'</span>) + response_content</span><br><span class="line">        <span class="comment"># 发送响应报文</span></span><br><span class="line">        service_client_socket.send(response_data)</span><br><span class="line">        <span class="comment"># 关闭套接字</span></span><br><span class="line">        service_client_socket.close()</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"\n"</span>, <span class="string">"-"</span> * <span class="number">100</span>, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_http</span><span class="params">(request_data)</span>:</span></span><br><span class="line">        <span class="string">"""解析 HTTP 文本"""</span></span><br><span class="line"></span><br><span class="line">        my_http = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 分成多行</span></span><br><span class="line">        request_headers = request_data.split(<span class="string">'\r\n'</span>)</span><br><span class="line">        request_lines = request_headers[<span class="number">0</span>].split(<span class="string">' '</span>)</span><br><span class="line">        print(<span class="string">"request_lines: "</span>, request_lines, end=<span class="string">"\n\n"</span>)</span><br><span class="line"></span><br><span class="line">        my_http[<span class="string">'method'</span>] = request_lines[<span class="number">0</span>]</span><br><span class="line">        my_http[<span class="string">'url'</span>] = request_lines[<span class="number">1</span>]</span><br><span class="line">        my_http[<span class="string">'version'</span>] = request_lines[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 未指定页面时 默认访问 index.html</span></span><br><span class="line">        <span class="keyword">if</span> my_http[<span class="string">'url'</span>] == <span class="string">"/"</span>:</span><br><span class="line">            my_http[<span class="string">'url'</span>] = <span class="string">"/index.html"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> header <span class="keyword">in</span> request_headers[<span class="number">1</span>:]:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> header:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Host: www.baidu.com</span></span><br><span class="line">            lines = header.split(<span class="string">':'</span>)</span><br><span class="line">            my_http[lines[<span class="number">0</span>]] = lines[<span class="number">1</span>][<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"my_http: "</span>, my_http, end=<span class="string">"\n\n"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> my_http</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">port_handler</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""指定端口"""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 默认设置端口为 8888</span></span><br><span class="line">    port = <span class="number">8888</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 获取外部传递过来的参数;</span></span><br><span class="line">    <span class="comment"># # 1.尽量值传递一个参数过来</span></span><br><span class="line">    <span class="comment"># #   ctrl+z: 退出页面,但是程序没有退出;(该端口还可以使用)</span></span><br><span class="line">    <span class="comment"># #   ctrl+c: 退出页面,也退出程序;</span></span><br><span class="line">    <span class="comment"># # print(sys.argv[1])</span></span><br><span class="line">    <span class="comment"># if not len(sys.argv) == 2:</span></span><br><span class="line">    <span class="comment">#     print('输入的格式错误,正确的格式应该是: python3 文件名.py 端口号')</span></span><br><span class="line">    <span class="comment">#     return</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># # 2.如果传递过来端口号,里面有非数字;(也不行)</span></span><br><span class="line">    <span class="comment"># if not sys.argv[1].isdigit():</span></span><br><span class="line">    <span class="comment">#     print('端口号, 必须是整数!!!')</span></span><br><span class="line">    <span class="comment">#     return</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># # 3.取值范围: [0-65535]</span></span><br><span class="line">    <span class="comment"># if not 0 &lt;= int(sys.argv[1]) &lt;= 65535:</span></span><br><span class="line">    <span class="comment">#     print('端口号必须在: [0-65535]之间!!!')</span></span><br><span class="line">    <span class="comment">#     return</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># # 4.如果全部通过,那么要把端口号,传递到程序中</span></span><br><span class="line">    <span class="comment"># # 获取用户指定的绑定端口</span></span><br><span class="line">    <span class="comment"># port = int(sys.argv[1])</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> port</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 服务器 IP，默认为本机 IP</span></span><br><span class="line">    server_ip = <span class="string">""</span></span><br><span class="line">    <span class="comment"># 服务器 端口</span></span><br><span class="line">    server_port = port_handler()</span><br><span class="line">    web_server = WebServer(server_ip, server_port)</span><br><span class="line">    web_server.startup()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP-超文本传输协议&quot;&gt;&lt;a href=&quot;#HTTP-超文本传输协议&quot; class=&quot;headerlink&quot; title=&quot;HTTP 超文本传输协议&quot;&gt;&lt;/a&gt;HTTP 超文本传输协议&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;超文本传输协议（HyperText Transfer Protocol）是一种应用层协议。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTTP是万维网的数据通信的基础。设计HTTP最初的目的是为了提供一种发布和接收HTML页面&amp;lt;网页&amp;gt;的方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1989年蒂姆·伯纳斯-李在CERN研发&lt;/li&gt;
&lt;li&gt;1999年公布现今广泛使用的HTTP 1.1版(RFC2616)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="HTTP" scheme="http://jovelin.cn/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Python 中 exit( ) 的用法</title>
    <link href="http://jovelin.cn/2018/07/15/Python%20%E4%B8%AD%20exit()%20%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://jovelin.cn/2018/07/15/Python 中 exit() 的用法/</id>
    <published>2018-07-14T16:22:31.000Z</published>
    <updated>2018-07-14T16:30:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Python 中 exit( ) 的用法总结</strong>：</p><ol><li><p><strong>sys.exit(n)  退出程序引发 SystemExit 异常，可以捕获异常执行些清理工作</strong>。</p><p> n 默认值为 0，表示正常退出，其他都是非正常退出。还可以 sys.exit(“sorry, goodbye!”);</p><p> 一般 <strong>主程序中</strong> 使用此退出。</p></li></ol><a id="more"></a><ol><li><p><strong>os._exit(n)，直接退出，不抛异常， 不执行相关清理工作</strong>。</p><p> 常用在 <strong>子进程</strong> 的退出。</p></li><li><p><strong>exit()/quit()，跑出 SystemExit 异常</strong>。</p><p> 一般在 <strong>交互式 shell 中</strong> 退出时使用。</p></li><li><p><strong>exit(0) 有什么功能</strong>？</p><p> 在很多类型的操作系统里，exit(0) 可以中断某个程序，而其中的数字参数则用来表示程序是否是碰到错误而中断。</p><p> exit(1) 表示发生了错误，而 exit(0) 则表示程序是正常退出的。</p><p> 这和我们学的布尔逻辑  0==False 正好相反，不过你可以用不一样的数字表示不同的错误结果。</p><p> 比如你可以用 exit(100) 来表示另一种和 exit(2) 或 exit(1) 不同的错误。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Python 中 exit( ) 的用法总结&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;sys.exit(n)  退出程序引发 SystemExit 异常，可以捕获异常执行些清理工作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; n 默认值为 0，表示正常退出，其他都是非正常退出。还可以 sys.exit(“sorry, goodbye!”);&lt;/p&gt;
&lt;p&gt; 一般 &lt;strong&gt;主程序中&lt;/strong&gt; 使用此退出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="exit方法" scheme="http://jovelin.cn/tags/exit%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python 正则表达式</title>
    <link href="http://jovelin.cn/2018/07/12/Python%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://jovelin.cn/2018/07/12/Python 正则表达式/</id>
    <published>2018-07-12T07:21:00.000Z</published>
    <updated>2018-07-13T12:25:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。</p><p><strong>简而言之：正则表达式就是记录文本规则的代码。</strong></p><a id="more"></a><p>特点: </p><p>操作字符串</p><p>1.更快的方式操作字符串；(表单校验，数据匹配…)</p><p>2.普通字符串操作无法做到的，或者很难做的正则很容易搞定！！！</p><p>使用场景：</p><p>1.表单校验</p><p>2.api 里面也需要正则</p><p><strong>正则表达式代码体验</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python 解释器为我们提供了一个使用正则的模块，这个模块叫做re(regex)</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 1.match()：匹配 -&gt; object</span></span><br><span class="line">    <span class="comment"># group()：通过匹配后，可以使用group()获取内容</span></span><br><span class="line">    obj = re.match(<span class="string">r"jovelin"</span>, <span class="string">"jovelin"</span>)</span><br><span class="line">    print(obj.group())  <span class="comment"># -&gt; jovelin</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.如果被匹配的内容多余正则；(只返回开头匹配的部分)</span></span><br><span class="line">    obj = re.match(<span class="string">r"jovelin"</span>, <span class="string">"jovelin.cn"</span>)</span><br><span class="line">    print(obj.group())  <span class="comment"># -&gt; jovelin</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.如果开头部分，没有匹配的内容； 那么返回None</span></span><br><span class="line">    obj = re.match(<span class="string">r"jovelin"</span>, <span class="string">"www.jovelin.cn"</span>)</span><br><span class="line">    print(obj)  <span class="comment"># -&gt; None</span></span><br><span class="line"></span><br><span class="line">    print(<span class="keyword">None</span>, type(<span class="keyword">None</span>))  <span class="comment"># -&gt; None &lt;class 'NoneType'&gt;</span></span><br></pre></td></tr></table></figure><h3 id="常用的元字符"><a href="#常用的元字符" class="headerlink" title="常用的元字符"></a>常用的元字符</h3><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:left">匹配除换行符(\n)以外的任意字符</td></tr><tr><td style="text-align:center">[]</td><td style="text-align:left">匹配 [ ] 中列举的字符</td></tr><tr><td style="text-align:center">\w 与 \W</td><td style="text-align:left">匹配字母或数字或下划线或汉字(单词) / 反义(非单词)</td></tr><tr><td style="text-align:center">\s 与 \S</td><td style="text-align:left">匹配任意的空白符 / 反义(非空白)</td></tr><tr><td style="text-align:center">\d 与 \D</td><td style="text-align:left">匹配数字 [0-9] / 反义(非数字)</td></tr><tr><td style="text-align:center">\b 与 \B</td><td style="text-align:left">匹配单词的开始或结束 / 反义</td></tr><tr><td style="text-align:center">^</td><td style="text-align:left">匹配字符串的开始</td></tr><tr><td style="text-align:center">$</td><td style="text-align:left">匹配字符串的结束</td></tr></tbody></table><p><strong>代码演示：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># . 匹配任意1个字符（除了 \n）</span></span><br><span class="line">print(re.match(<span class="string">r'a.b'</span>, <span class="string">'a\nb'</span>))  <span class="comment"># -&gt; None</span></span><br><span class="line"><span class="comment">#  - 在 [] 里代表范围</span></span><br><span class="line">print(re.match(<span class="string">r'a[a-c]c'</span>, <span class="string">'abc'</span>).group())  <span class="comment"># -&gt; abc</span></span><br><span class="line"><span class="comment"># 在 [] 里面也想使用 - 那么需要 \ 转义</span></span><br><span class="line">print(re.match(<span class="string">r'a[a\-c]c'</span>, <span class="string">'a-c'</span>).group())  <span class="comment"># -&gt; a-c</span></span><br><span class="line"><span class="comment"># \b用法 与 ^ $ 相似，不过 \b 只匹配单词，\B 只匹配非单词</span></span><br><span class="line">print(re.match(<span class="string">r"\b\w+\b"</span>, <span class="string">"0_9_a_z_A_Z汉字"</span>).group())  <span class="comment"># -&gt; 0_9_a_z_A_Z</span></span><br><span class="line">print(re.match(<span class="string">r"\B\W+\B"</span>, <span class="string">"!@#$%^&amp;*"</span>).group())  <span class="comment"># -&gt; !@#$%^&amp;*</span></span><br><span class="line"><span class="comment"># ^匹配字符串开头</span></span><br><span class="line"><span class="comment"># $匹配字符串结尾</span></span><br><span class="line">print(re.match(<span class="string">r'[\w\W]*$'</span>, <span class="string">'0_9_a_z_A_Z汉字!@#$%^&amp;* \n\t'</span>).group())  <span class="comment"># -&gt; 0_9_a_z_A_Z汉字!@#$%^&amp;* </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意: ^ 如果出现在 [] 中，代表的是取反!   (想要使用 ^,可以转义 \)</span></span><br><span class="line">print(re.match(<span class="string">r'^[\^]$'</span>, <span class="string">'^'</span>).group())  <span class="comment"># -&gt; ^</span></span><br><span class="line">print(re.match(<span class="string">r'^[^^]$'</span>, <span class="string">'^'</span>))  <span class="comment"># -&gt; None</span></span><br><span class="line">print(re.match(<span class="string">r'^[^47]$'</span>, <span class="string">'47'</span>))  <span class="comment"># -&gt; 47</span></span><br></pre></td></tr></table></figure><h3 id="常用的限定符（量词）"><a href="#常用的限定符（量词）" class="headerlink" title="常用的限定符（量词）"></a>常用的限定符（量词）</h3><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:left">说明</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:left">重复零次或更多次</td><td style="text-align:left">&gt;=0</td></tr><tr><td style="text-align:center">+</td><td style="text-align:left">重复一次或更多次</td><td style="text-align:left">&gt;=1</td></tr><tr><td style="text-align:center">?</td><td style="text-align:left">重复零次或一次</td><td style="text-align:left">0 or 1</td></tr><tr><td style="text-align:center">{n}</td><td style="text-align:left">重复n次</td><td style="text-align:left">==n</td></tr><tr><td style="text-align:center">{n,}</td><td style="text-align:left">重复n次或更多次</td><td style="text-align:left">&gt;=n</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:left">重复n到m次</td><td style="text-align:left">n&lt;=X&lt;=m</td></tr></tbody></table><p><strong>代码演示：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># * 匹配前一个字符出现0次或者无限次，即可有可无 (&gt;=0)</span></span><br><span class="line">print(re.match(<span class="string">r'a*b'</span>, <span class="string">'b'</span>).group())  <span class="comment"># -&gt; b</span></span><br><span class="line"><span class="comment"># + 匹配前一个字符出现1次或者无限次，即至少有1次 (&gt;=1)</span></span><br><span class="line">print(re.match(<span class="string">r'a+b'</span>, <span class="string">'b'</span>))  <span class="comment"># -&gt; None，必须要 1 个 a</span></span><br><span class="line"><span class="comment"># &#123;n&#125; 匹配前一个字符出现n次 == n                           (== n)</span></span><br><span class="line">print(re.match(<span class="string">r'a&#123;2&#125;b'</span>, <span class="string">'ab'</span>))  <span class="comment"># -&gt; None，必须要 2 个 a</span></span><br><span class="line"><span class="comment"># &#123;n,m&#125; 匹配前一个字符出现: n次&lt;= 前一个字符 &lt;=m次 (n&lt;=X&lt;=m)</span></span><br><span class="line">print(re.match(<span class="string">r'a&#123;2,5&#125;b'</span>, <span class="string">'ab'</span>))  <span class="comment"># -&gt; None，a 的次数必须是 2&lt;=a&lt;=5</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>案例</strong>：</p><p>1.校验手机号</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMobileNumber</span><span class="params">(tel)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    校验手机号是否正确</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> re.match(<span class="string">r"^[1-][34578-]\d&#123;9&#125;$"</span>, tel) <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(isMobileNumber(<span class="string">"18819950820"</span>))</span><br></pre></td></tr></table></figure><p>2.校验邮箱</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">邮箱名称部分为： [a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)&#123;0,4&#125;</span></span><br><span class="line"><span class="string">域名部分： [a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+</span></span><br><span class="line"><span class="string">连起来 ^[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)&#123;0,4&#125;@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)&#123;1,2&#125;$</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isEmail</span><span class="params">(email)</span>:</span></span><br><span class="line">    <span class="string">"""校验邮箱是否正确"""</span></span><br><span class="line">    <span class="keyword">if</span> re.match(<span class="string">r"^[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)&#123;0,4&#125;@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)&#123;1,2&#125;$"</span>, email) <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(isEmail(<span class="string">"jovelin@163.com"</span>))</span><br><span class="line">print(isEmail(<span class="string">"jovelin.dev@gmail.com"</span>))</span><br><span class="line">print(isEmail(<span class="string">"jovelin@163.com.cn"</span>))</span><br><span class="line">print(isEmail(<span class="string">"jovelin.dev@gmail.com.cn"</span>))</span><br></pre></td></tr></table></figure><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作。</p><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">(abc)</td><td style="text-align:left">将括号中字符作为一个分组</td></tr><tr><td style="text-align:center">竖线</td><td style="text-align:left">匹配左右任意一个表达式</td></tr><tr><td style="text-align:center">\num</td><td style="text-align:left">引用分组num匹配到的字符串</td></tr><tr><td style="text-align:center">(?P<name>)</name></td><td style="text-align:left">分组起别名</td></tr><tr><td style="text-align:center">(?P=name)</td><td style="text-align:left">引用别名为name分组匹配到的字符串</td></tr></tbody></table><p>代码演示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># (abc) 将括号中字符作为一个分组</span></span><br><span class="line">print(re.match(<span class="string">r'(aaa)bbb(ccc)'</span>, <span class="string">'aaabbbccc'</span>).group())</span><br><span class="line"><span class="comment"># 一个括号就是一个分组； group()：参数代表分组的编号；写 0 或者不写时，获取全部；</span></span><br><span class="line">print(re.match(<span class="string">r'(aaa)bbb(ccc)'</span>, <span class="string">'aaabbbccc'</span>).group())</span><br><span class="line">print(re.match(<span class="string">r'(aaa)bbb(ccc)'</span>, <span class="string">'aaabbbccc'</span>).group(<span class="number">0</span>))</span><br><span class="line">print(re.match(<span class="string">r'(aaa)bbb(ccc)'</span>, <span class="string">'aaabbbccc'</span>).group(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 竖线 | 匹配左右任意一个表达式（和 [] 相似）</span></span><br><span class="line">print(re.match(<span class="string">r'aaa(xxx|yyy|zzz)bbb'</span>, <span class="string">'aaaxxxbbb'</span>).group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># \num 引用分组 num 匹配到的字符串</span></span><br><span class="line"><span class="comment">#       前后保证一致，要使用到分组！</span></span><br><span class="line">print(re.match(<span class="string">r'^&lt;(\w+)&gt;\w+&lt;/\1&gt;$'</span>, <span class="string">'&lt;html&gt;nihao&lt;/html&gt;'</span>).group())</span><br><span class="line">print(re.match(<span class="string">r'^&lt;(\w+)&gt;&lt;(\w+)&gt;\w+&lt;/\2&gt;&lt;/\1&gt;$'</span>, <span class="string">'&lt;html&gt;&lt;div&gt;nihao&lt;/div&gt;&lt;/html&gt;'</span>).group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># (?P&lt;name&gt;正则)  分组起别名</span></span><br><span class="line"><span class="comment"># (?P=name)      引用别名为name分组匹配到的字符串</span></span><br><span class="line">print(re.match(<span class="string">r'^&lt;(?P&lt;re1&gt;\w+)&gt;&lt;(?P&lt;re2&gt;\w+)&gt;\w+&lt;/(?P=re2)&gt;&lt;/(?P=re1)&gt;$'</span>, <span class="string">'&lt;html&gt;&lt;div&gt;jovelin&lt;/div&gt;&lt;/html&gt;'</span>).group())</span><br></pre></td></tr></table></figure><h3 id="正则高级-API（4个）"><a href="#正则高级-API（4个）" class="headerlink" title="正则高级 API（4个）"></a>正则高级 API（4个）</h3><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">search()</td><td style="text-align:left">搜索字符串中符合正则表达式的内容 -&gt; 只返回第一个</td></tr><tr><td style="text-align:center">findall()</td><td style="text-align:left">搜索字符串中符合正则表达式的内容 -&gt; 返回一个列表</td></tr><tr><td style="text-align:center">sub()</td><td style="text-align:left">替换字符串中符合正则的内容 -&gt; 替换后的字符串</td></tr><tr><td style="text-align:center">split()</td><td style="text-align:left">按照指定正则切割字符串 -&gt; 返回列表</td></tr></tbody></table><p>代码演示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.search()</span></span><br><span class="line">print(re.search(<span class="string">r"\d+"</span>, <span class="string">"aaa111bbb222ccc333ddd"</span>).group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.findall()</span></span><br><span class="line">print(re.findall(<span class="string">r"\d+"</span>, <span class="string">"aaa111bbb222ccc333ddd"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.sub()</span></span><br><span class="line">print(re.sub(<span class="string">r"\d+"</span>, <span class="string">"***"</span>, <span class="string">"aaa111bbb222ccc333ddd"</span>))</span><br><span class="line"><span class="comment"># sub(正则, 替换成***, 被操作的字符串, 替换次数)</span></span><br><span class="line">print(re.sub(<span class="string">r"\d+"</span>, <span class="string">"***"</span>, <span class="string">"aaa111bbb222ccc333ddd"</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.split()</span></span><br><span class="line">print(re.split(<span class="string">r"\d+"</span>, <span class="string">"aaa111bbb222ccc333ddd eee"</span>))</span><br><span class="line">print(re.split(<span class="string">r"\d+|\s"</span>, <span class="string">"aaa111bbb222ccc333ddd eee"</span>))</span><br></pre></td></tr></table></figure><h3 id="r-的作用"><a href="#r-的作用" class="headerlink" title="r 的作用"></a>r 的作用</h3><p>让程序把正则直接当做正则看；(不是从字符串开始解释)</p><figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line"># c:<span class="symbol">\a</span>aa<span class="symbol">\b</span>bb<span class="symbol">\c</span>cc</span><br><span class="line">print('c:<span class="symbol">\a</span>aa<span class="symbol">\b</span>bb<span class="symbol">\c</span>cc')</span><br><span class="line">print('c:<span class="symbol">\\</span>aaa<span class="symbol">\\</span>bbb<span class="symbol">\\</span>ccc')</span><br><span class="line"></span><br><span class="line"># 问题：在字符串中写 <span class="symbol">\ </span>时会转义，需要写成 <span class="symbol">\\</span></span><br><span class="line"># 不写 r 时 <span class="symbol">\\</span><span class="symbol">\\</span> -&gt; <span class="symbol">\\</span></span><br><span class="line">print(re.match('c:<span class="symbol">\\</span><span class="symbol">\\</span>aaa<span class="symbol">\\</span><span class="symbol">\\</span>bbb<span class="symbol">\\</span><span class="symbol">\\</span>ccc', 'c:<span class="symbol">\\</span>aaa<span class="symbol">\\</span>bbb<span class="symbol">\\</span>ccc').group())</span><br><span class="line"># 写 r 时 <span class="symbol">\\</span> -&gt; <span class="symbol">\\</span></span><br><span class="line">print(re.match(r'c:<span class="symbol">\\</span>aaa<span class="symbol">\\</span>bbb<span class="symbol">\\</span>ccc', 'c:<span class="symbol">\\</span>aaa<span class="symbol">\\</span>bbb<span class="symbol">\\</span>ccc').group())</span><br></pre></td></tr></table></figure><h3 id="贪婪-非贪婪"><a href="#贪婪-非贪婪" class="headerlink" title="贪婪/非贪婪"></a>贪婪/非贪婪</h3><p>贪婪：(量词在自己的范围内，取最多…)</p><p>非贪婪：(量词在自己的范围内，取最少… ) </p><p>非贪婪用法：量词后面加?</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'贪婪'</span>, re.match(<span class="string">r'a+'</span>, <span class="string">'aaa'</span>).group())  <span class="comment"># -&gt; aaa</span></span><br><span class="line"><span class="comment"># 量词后面加?</span></span><br><span class="line">print(<span class="string">'非贪婪'</span>, re.match(<span class="string">r'a+?'</span>, <span class="string">'aaa'</span>).group())  <span class="comment"># -&gt; a</span></span><br><span class="line">print(<span class="string">'贪婪'</span>, re.match(<span class="string">r'a&#123;1,2&#125;'</span>, <span class="string">'aaa'</span>).group())  <span class="comment"># -&gt; aa</span></span><br><span class="line"><span class="comment"># 量词后面加?</span></span><br><span class="line">print(<span class="string">'非贪婪'</span>, re.match(<span class="string">r'a&#123;1,3&#125;?'</span>, <span class="string">'aaa'</span>).group())  <span class="comment"># -&gt; a</span></span><br></pre></td></tr></table></figure><blockquote><p>更多参考内容： <a href="http://deerchao.net" target="_blank" rel="noopener">http://deerchao.net</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简而言之：正则表达式就是记录文本规则的代码。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="正则表达式" scheme="http://jovelin.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 多任务-线程、进程与协程</title>
    <link href="http://jovelin.cn/2018/07/10/Python%20%E5%A4%9A%E4%BB%BB%E5%8A%A1-%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/"/>
    <id>http://jovelin.cn/2018/07/10/Python 多任务-线程、进程与协程/</id>
    <published>2018-07-09T16:20:12.000Z</published>
    <updated>2018-07-18T02:07:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-多任务-线程、进程与协程"><a href="#Python-多任务-线程、进程与协程" class="headerlink" title="Python 多任务-线程、进程与协程"></a>Python 多任务-线程、进程与协程</h1><p>什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是进程的一个实体，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/3365001-4cf0e2846bad9723.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="进程和线程.png"></p><h4 id="并行-并发"><a href="#并行-并发" class="headerlink" title="并行/并发"></a>并行/并发</h4><p><img src="https://upload-images.jianshu.io/upload_images/3365001-9365b83598e8f764.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02-CPU及线程介绍.png"></p><p><strong>并发</strong></p><p>指的是任务数多余cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）</p><p><strong>并行</strong></p><p>指的是任务数小于等于cpu核数，即任务真的是一起执行的</p><h4 id="多线程图解"><a href="#多线程图解" class="headerlink" title="多线程图解"></a>多线程图解</h4><p><img src="https://upload-images.jianshu.io/upload_images/3365001-81ffaa2cf10ae661.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03-线程.png"></p><h4 id="共享全局变量与问题"><a href="#共享全局变量与问题" class="headerlink" title="共享全局变量与问题"></a>共享全局变量与问题</h4><p>在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据。</p><p><strong>问题</strong>：</p><p>如果多个线程同时对同一个全局变量操作，会出现资源竞争问题，从而数据结果会不正确。（即线程非安全）</p><h4 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h4><p>同步：单线程（从上到下依次执行顺序）</p><p>异步：多线程（开启多个任务一同执行，互不影响）</p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p><strong>当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制</strong>。</p><p><strong>锁的好处</strong>：</p><ul><li>确保了某段关键代码只能由一个线程从头到尾完整地执行</li></ul><p><strong>锁的坏处</strong>：</p><ul><li>阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了<br>由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁</li></ul><h4 id="死锁（一种-bug）"><a href="#死锁（一种-bug）" class="headerlink" title="死锁（一种 bug）"></a>死锁（一种 bug）</h4><p>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。</p><p><strong>避免死锁</strong></p><ul><li>程序设计时要尽量避免（银行家算法）</li><li>添加超时时间等</li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>1.多线程体验</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python 解释器中有一个模块专门控制线程，实现多任务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        print(<span class="string">"send msg"</span>, i + <span class="number">1</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive_msg</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        print(<span class="string">"receive msg"</span>, i + <span class="number">1</span>)</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建线程对象（target=函数名, name=线程别名, args=参数, kwargs=字典参数）</span></span><br><span class="line">    t1 = threading.Thread(target=send_msg, name=<span class="string">"send"</span>, args=(<span class="number">3</span>,))</span><br><span class="line">    t2 = threading.Thread(target=receive_msg, name=<span class="string">"receive"</span>, kwargs=&#123;<span class="string">"num"</span>: <span class="number">3</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 三个 API</span></span><br><span class="line">    print(threading.enumerate())</span><br><span class="line">    print(threading.current_thread())</span><br><span class="line">    print(threading.active_count())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 守护线程</span></span><br><span class="line">    t1.setDaemon(<span class="keyword">True</span>)</span><br><span class="line">    t2.setDaemon(<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开启线程</span></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 线程等待</span></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"*** main thread ***"</span>)</span><br></pre></td></tr></table></figure><p>2.自定义线程类</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendThread</span>(<span class="title">threading</span>.<span class="title">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, num)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="comment"># threading.Thread.__init__(self)</span></span><br><span class="line">        <span class="keyword">super</span>(SendThread, <span class="keyword">self</span>).__init_<span class="number">_</span>()</span><br><span class="line">        <span class="comment"># super().__init__()</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.num = num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)<span class="symbol">:</span></span><br><span class="line">            print(<span class="string">"send msg"</span>, i + <span class="number">1</span>)</span><br><span class="line">            time.sleep(<span class="number">0</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.send_msg()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiveThread</span>(<span class="title">threading</span>.<span class="title">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive_msg</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)<span class="symbol">:</span></span><br><span class="line">            print(<span class="string">"receive msg"</span>, i + <span class="number">1</span>)</span><br><span class="line">            time.sleep(<span class="number">0</span>.<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.receive_msg()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    t1 = SendThread(<span class="number">3</span>)</span><br><span class="line">    t2 = ReceiveThread()</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"*** main thread ***"</span>)</span><br></pre></td></tr></table></figure><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>运行的程序以及运行时用到的资源这个整体称之为进程，是系统进行资源分配和调度的一个独立单位。</p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-4e2b4618127c7d94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01-进程.png"></p><h4 id="进程间通信-Queue"><a href="#进程间通信-Queue" class="headerlink" title="进程间通信-Queue"></a>进程间通信-Queue</h4><p>进程间通信：运行的程序之间的数据共享。</p><h3 id="进程、线程对比"><a href="#进程、线程对比" class="headerlink" title="进程、线程对比"></a>进程、线程对比</h3><p>功能</p><ul><li>进程，能够完成多任务，比如 在一台电脑上能够同时运行多个 QQ。</li><li>线程，能够完成多任务，比如 一个 QQ 中的多个聊天窗口。</li></ul><p>定义的不同</p><ul><li>进程是系统进行资源分配和调度的一个独立单位。</li><li>线程是进程的一个实体，是 CPU  调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</li><li>线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</li></ul><p>区别</p><ul><li>一个程序至少有一个进程，一个进程至少有一个线程。</li><li>线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高。</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率，</li><li>线线程不能够独立执行，必须依存在进程中。</li><li>可以将进程理解为工厂中的一条流水线，而其中的线程就是这个流水线上的工人。</li></ul><p>优缺点</p><ul><li>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。</li></ul><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程，又称微线程，纤程。英文名Coroutine。</p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-d37fbaaca0679c6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02-协程.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-8f26f1b69124ba7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03-迭代器和生成器.png"></p><h4 id="greenlet"><a href="#greenlet" class="headerlink" title="greenlet"></a>greenlet</h4><p>为了更好使用协程来完成多任务，python中的greenlet模块对其封装，从而使得切换任务变的更加简单</p><p><strong>安装方式</strong></p><p>使用如下命令安装 greenlet 模块:</p><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">pip3 list: 验证已安装的python第三方插件（如果没有pip3会提示安装）</span><br><span class="line"></span><br><span class="line">sudo pip3 install greenlet</span><br></pre></td></tr></table></figure><h4 id="gevent"><a href="#gevent" class="headerlink" title="gevent"></a>gevent</h4><p>greenlet已经实现了协程，但是这个还的人工切换，是不是觉得太麻烦了，不要捉急，python还有一个比greenlet更强大的并且能够自动切换任务的模块gevent</p><p>其原理是当一个greenlet遇到IO(指的是input output 输入输出，比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。</p><p>由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO</p><p><strong>安装方式</strong></p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip3 <span class="keyword">install</span> gevent</span><br></pre></td></tr></table></figure><h4 id="协程和线程差异"><a href="#协程和线程差异" class="headerlink" title="协程和线程差异"></a>协程和线程差异</h4><p>在实现多任务时, 线程切换从系统层面远不止保存和恢复 CPU 上下文这么简单。</p><p>操作系统为了程序运行的高效性每个线程都有自己缓存 Cache 等等数据，操作系统还会帮你做这些数据的恢复操作。所以线程的切换非常耗性能。</p><p>但是协程的切换只是单纯的操作 CPU 的上下文，所以一秒钟切换个上百万次系统都抗的住。</p><h3 id="进程、线程、协程对比"><a href="#进程、线程、协程对比" class="headerlink" title="进程、线程、协程对比"></a>进程、线程、协程对比</h3><ol><li>进程是资源分配的单位</li><li>线程是操作系统调度的单位</li><li>进程切换需要的资源很最大，效率很低</li><li>线程切换需要的资源一般，效率一般（当然了在不考虑GIL的情况下）</li><li>协程切换任务资源很小，效率高</li><li>多进程、多线程根据cpu核数不一样可能是并行的，但是协程是在一个线程中 所以是并发</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-多任务-线程、进程与协程&quot;&gt;&lt;a href=&quot;#Python-多任务-线程、进程与协程&quot; class=&quot;headerlink&quot; title=&quot;Python 多任务-线程、进程与协程&quot;&gt;&lt;/a&gt;Python 多任务-线程、进程与协程&lt;/h1&gt;&lt;p&gt;什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。&lt;/p&gt;
&lt;h3 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h3&gt;&lt;p&gt;线程是进程的一个实体，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="多任务" scheme="http://jovelin.cn/tags/%E5%A4%9A%E4%BB%BB%E5%8A%A1/"/>
    
      <category term="线程" scheme="http://jovelin.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="进程" scheme="http://jovelin.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="协程" scheme="http://jovelin.cn/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python 网络通信-udp、tcp 与 socket</title>
    <link href="http://jovelin.cn/2018/07/08/Python%20%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1-udp%E3%80%81tcp%20%E4%B8%8E%20socket/"/>
    <id>http://jovelin.cn/2018/07/08/Python 网络通信-udp、tcp 与 socket/</id>
    <published>2018-07-07T16:21:11.000Z</published>
    <updated>2018-07-18T02:07:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-网络通信"><a href="#Python-网络通信" class="headerlink" title="Python 网络通信"></a>Python 网络通信</h1><h3 id="udp-和-tcp-及-socket-介绍"><a href="#udp-和-tcp-及-socket-介绍" class="headerlink" title="udp 和 tcp 及 socket 介绍"></a>udp 和 tcp 及 socket 介绍</h3><p><strong>注意：udp 和 tcp 都是网络传输的协议，只不过具体传输形式不一样，但功能都是定义网络传输数据规则。</strong></p><p><strong>udp 和 tcp (发短信和打电话)(不同: 是否创建链接)</strong></p><a id="more"></a><ol><li><p><strong>udp 是用户数据报协议</strong>，UDP(User Datagram Protocol)不能保证数据的准确性和有效性。<br>(数据报:是通过网络传输的数据的基本单元) </p></li><li><p><strong>tcp 是传输控制协议</strong>，TCP(Transmission Control Protocol)能保证数据的准确性和有效性。<br>(和udp差不多依靠socket技术)</p></li><li><p><strong>socket 就是具体实现 tcp 和 udp 的底层技术(也称套接字/流对象)</strong>(不在网络七层协议之列-因为是技术不是协议)</p></li></ol><h3 id="网络七层协议-四-五层模型"><a href="#网络七层协议-四-五层模型" class="headerlink" title="网络七层协议(四/五层模型)"></a>网络七层协议(四/五层模型)</h3><p><img src="https://upload-images.jianshu.io/upload_images/3365001-893eb6882ef825ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="七层协议1.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-03725767e52c896a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="七层协议2.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-d812e52bc2dc7743.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络七层协议.png"></p><h3 id="IP-地址与端口"><a href="#IP-地址与端口" class="headerlink" title="IP 地址与端口"></a>IP 地址与端口</h3><p>网络通信过程中，之所需要ip、port等，就是为了能够将一个复杂的通信过程进行任务划分，从而保证数据准确无误的传递。</p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-5d9168459fadd31a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ip和端口.png"></p><h4 id="ip-地址"><a href="#ip-地址" class="headerlink" title="ip 地址"></a>ip 地址</h4><p>作用：用来在网络中标记一台电脑，比如 192．168．1．1 在本地局域网上是唯一的。</p><p>注意：IP 地址 127．0．0．1~127．255．255．255 用于回路测试</p><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>端口是通过端口号来标记的，端口号只有整数，范围是从0到65535</p><h5 id="知名端口"><a href="#知名端口" class="headerlink" title="知名端口"></a>知名端口</h5><p>众所周知的端口号，范围从0到1023</p><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">80 </span>端口分配给HTTP服务</span><br><span class="line"><span class="symbol">21 </span>端口分配给FTP服务</span><br></pre></td></tr></table></figure><h5 id="动态端口"><a href="#动态端口" class="headerlink" title="动态端口"></a>动态端口</h5><p>范围是从1024到65535</p><h5 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h5><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">netstat －an 查看端口状态</span><br><span class="line">lsof -<span class="selector-tag">i</span>:port 查看端口占用</span><br></pre></td></tr></table></figure><h3 id="Python3-编码转换"><a href="#Python3-编码转换" class="headerlink" title="Python3 编码转换"></a>Python3 编码转换</h3><p>str-&gt;bytes:encode编码</p><p>bytes-&gt;str:decode解码</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding: 在解码编码过程中使用的编码(此处指“编码方案”是名词)</span></span><br><span class="line"><span class="comment"># errors: 错误的处理方案</span></span><br><span class="line">bytes.decode(<span class="attribute">encoding</span>=<span class="string">"utf-8"</span>, <span class="attribute">errors</span>=<span class="string">"strict"</span>)</span><br><span class="line">str.encode(<span class="attribute">encoding</span>=<span class="string">"utf-8"</span>, <span class="attribute">errors</span>=<span class="string">"strict"</span>)</span><br></pre></td></tr></table></figure><p>详细的可以参照官方文档：</p><p><a href="https://docs.python.org/3/library/stdtypes.html?highlight=decode#str.encode" target="_blank" rel="noopener">str.encode()</a></p><p><a href="https://docs.python.org/3/library/stdtypes.html?highlight=decode#bytes.decode" target="_blank" rel="noopener">bytes.decode()</a></p><h3 id="Socket-套接字"><a href="#Socket-套接字" class="headerlink" title="Socket 套接字"></a>Socket 套接字</h3><p><strong>socket(简称 套接字也成为插口–流对象)</strong> 是进程间通信的一种方式，它与其他进程间通信的一个主要不同是：</p><p>它能实现不同主机间的进程间通信，我们网络上各种各样的服务大多都是基于 Socket 来完成通信的。</p><p>例如我们每天浏览网页、QQ 聊天、收发 email 等等。</p><h4 id="Socket-反问理解"><a href="#Socket-反问理解" class="headerlink" title="Socket 反问理解"></a>Socket 反问理解</h4><p>———start———</p><p><strong>what 是什么</strong>？（概念、理解）</p><p>socket(简称 套接字 也称为插口–流对象) 是进程间通信的一种方式</p><p><br></p><p><strong>why 为什么用</strong>？（用它的好处，特点/不同点）</p><p>是实现tcp和udp的底层技术，能实现 不同主机间 的进程间通信</p><p><br></p><p><strong>where 在哪使用</strong>？（案例、项目）</p><p>网络程序发送、接收数据（发短信、打电话、广播）</p><p>————end————</p><h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><p>udp 是用户数据报协议，UDP (User Datagram Protocol) 不能保证数据的准确性和有效性。 (数据报:是通过网络传输的数据的基本单元)</p><p>udp 通信模型中，在通信开始之前，不需要建立相关的链接，只需要发送数据即可，类似于生活中，”写信/发短信”</p><p>python 使用 udp 协议要通过 socket 技术:</p><pre><code>使用步骤：1.引包 2.创建流对象(ipv4, udp) 3.发送(二进制字符串, 元组ip和端口) 4.关闭流对象</code></pre><p>创建 socket 语法</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Address Family：可以选择 AF_INET（用于 Internet 进程间通信） 或者 AF_UNIX（用于同一台机器进程间通信）,实际工作中常用AF_INET</span></span><br><span class="line"><span class="comment"># Type：套接字类型，可以是 SOCK_STREAM（流式套接字，主要用于 TCP 协议）或者 SOCK_DGRAM（数据报套接字，主要用于 UDP 协议）</span></span><br><span class="line"></span><br><span class="line">import <span class="built_in">socket</span></span><br><span class="line">    <span class="built_in">socket</span>.<span class="built_in">socket</span>(AddressFamily, Type)</span><br></pre></td></tr></table></figure><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>1.udp 发送</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.引包</span></span><br><span class="line">import <span class="built_in">socket</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 2.创建流对象(ipv4, udp)</span></span><br><span class="line">    <span class="comment"># socket是一个模块</span></span><br><span class="line">    <span class="comment"># socket.socket是一个类</span></span><br><span class="line">    <span class="comment">#   socket.AF_INET: 这个socket数据传世用ipv4;</span></span><br><span class="line">    <span class="comment">#   socket.SOCK_DGRAM: 这个socket使用udp协议进行数据传输;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># socket对象(套接字);    插口 -- 流对象(就要关闭 -- 发送和接收信息)</span></span><br><span class="line">    udp_socket = <span class="built_in">socket</span>.<span class="built_in">socket</span>(<span class="built_in">socket</span>.AF_INET, <span class="built_in">socket</span>.SOCK_DGRAM)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3.发送(二进制字符串, 元组ip和端口)</span></span><br><span class="line">    str1 = <span class="string">'你好,我是udp协议发送的测试数据...'</span></span><br><span class="line">    tuple1 = (<span class="string">'192.168.1.1'</span>, <span class="number">8888</span>)</span><br><span class="line">    udp_socket.sendto(str1.encode(<span class="string">'utf-8'</span>), tuple1)</span><br><span class="line">    print(tuple1, <span class="string">'发送成功!'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4.关闭流对象</span></span><br><span class="line">    udp_socket.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><p>2.udp 接收（主动接收方需手动绑定端口，发送方才知道发送给谁）</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">socket</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 1.创建套接字对象</span></span><br><span class="line">    udp_socket = <span class="built_in">socket</span>.<span class="built_in">socket</span>(<span class="built_in">socket</span>.AF_INET, <span class="built_in">socket</span>.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 绑定本地的相关信息，如果一个网络程序不绑定，则系统会随机分配</span></span><br><span class="line">    local_addr = (<span class="string">''</span>, <span class="number">8888</span>) <span class="comment">#  ip地址和端口号，ip一般不用写，表示本机的任何一个ip</span></span><br><span class="line">    udp_socket.bind(local_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.数据接收( recvfrom() )</span></span><br><span class="line">    <span class="comment">#       参数: 最多一次性接收1024字节;</span></span><br><span class="line">    <span class="comment">#       返回值: 一个元组(二进制数据, ip及port组成的元组)</span></span><br><span class="line">    <span class="comment">#       recvfrom(): 可以阻塞代码!( 类似input() )</span></span><br><span class="line">    <span class="comment">#       发送和接收数据的时候,udp承受的最大上线为: 64k</span></span><br><span class="line">    str2, tuple2 = udp_socket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    print(str2)</span><br><span class="line">    print(tuple2)</span><br><span class="line">    print(str2.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="comment"># print(str2.decode('gbk'))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4.关闭套接字</span></span><br><span class="line">    udp_socket.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><p>3.udp 聊天器</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">说明：在一个电脑中编写1个程序，有2个功能：</span></span><br><span class="line"><span class="string">    1.获取键盘数据，并将其发送给对方</span></span><br><span class="line"><span class="string">    2.接收数据并显示</span></span><br><span class="line"><span class="string">    并且功能数据进行选择以上的2个功能调用</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(udp_socket)</span>:</span></span><br><span class="line">    <span class="string">"""获取键盘数据，并将其发送给对方"""</span></span><br><span class="line">    <span class="comment"># 1. 从键盘输入数据</span></span><br><span class="line">    msg = input(<span class="string">"\n请输入要发送的数据:"</span>)</span><br><span class="line">    <span class="comment"># 2. 输入对方的ip地址</span></span><br><span class="line">    dest_ip = input(<span class="string">"\n请输入对方的ip地址:"</span>)</span><br><span class="line">    <span class="comment"># 3. 输入对方的port</span></span><br><span class="line">    dest_port = int(input(<span class="string">"\n请输入对方的port:"</span>))</span><br><span class="line">    <span class="comment"># 4. 发送数据</span></span><br><span class="line">    udp_socket.sendto(msg.encode(<span class="string">"utf-8"</span>), (dest_ip, dest_port))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_msg</span><span class="params">(udp_socket)</span>:</span></span><br><span class="line">    <span class="string">"""接收数据并显示"""</span></span><br><span class="line">    <span class="comment"># 1. 接收数据</span></span><br><span class="line">    recv_msg = udp_socket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># 2. 解码</span></span><br><span class="line">    recv_ip = recv_msg[<span class="number">1</span>]</span><br><span class="line">    recv_msg = recv_msg[<span class="number">0</span>].decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    <span class="comment"># 3. 显示接收到的数据</span></span><br><span class="line">    print(<span class="string">"&gt;&gt;&gt;%s:%s"</span> % (str(recv_ip), recv_msg))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 1. 创建套接字</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">    <span class="comment"># 2. 绑定本地信息</span></span><br><span class="line">    udp_socket.bind((<span class="string">""</span>, <span class="number">7890</span>))</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># 3. 选择功能</span></span><br><span class="line">        print(<span class="string">"="</span>*<span class="number">30</span>)</span><br><span class="line">        print(<span class="string">"1:发送消息"</span>)</span><br><span class="line">        print(<span class="string">"2:接收消息"</span>)</span><br><span class="line">        print(<span class="string">"="</span>*<span class="number">30</span>)</span><br><span class="line">        op_num = input(<span class="string">"请输入要操作的功能序号:"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4. 根据选择调用相应的函数</span></span><br><span class="line">        <span class="keyword">if</span> op_num == <span class="string">"1"</span>:</span><br><span class="line">            send_msg(udp_socket)</span><br><span class="line">        <span class="keyword">elif</span> op_num == <span class="string">"2"</span>:</span><br><span class="line">            recv_msg(udp_socket)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"输入有误，请重新输入..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><p>TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。</p><p>TCP通信需要经过 <strong>创建连接、数据传送、终止连接</strong> 三个步骤。</p><p>TCP通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，”打电话””</p><h4 id="TCP-特点"><a href="#TCP-特点" class="headerlink" title="TCP 特点"></a>TCP 特点</h4><p><strong>1.面向连接</strong></p><ol><li>通信双方必须先建立连接才能进行数据的传输，双方都必须为该连接分配必要的系统内核资源，以管理连接的状态和连接上的传输。</li><li><strong>TCP不适用于广播的应用程序，基于广播的应用程序请使用UDP协议。</strong></li></ol><p><strong>2.可靠传输</strong></p><ol><li>TCP采用发送应答机制<ul><li>TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文段传输成功</li></ul></li><li>超时重传<ul><li>发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段。</li><li>TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。</li></ul></li><li>错误校验<ul><li>TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。</li></ul></li><li>流量控制和阻塞管理<ul><li>流量控制用来避免主机发送得过快而使接收方来不及完全收下。</li></ul></li></ol><h4 id="tcp-注意点"><a href="#tcp-注意点" class="headerlink" title="tcp 注意点"></a>tcp 注意点</h4><ol><li>tcp服务器一般情况下都需要绑定ip和端口，否则客户端找不到这个服务器及其服务对应的端口</li><li>tcp客户端一般不绑定，因为是主动链接服务器，所以只要确定好服务器的ip、port等信息就好，本地客户端可以随机</li><li>tcp服务器中通过listen可以将socket创建出来的主动套接字变为被动的，这是做tcp服务器时必须要做的</li><li>当客户端需要链接服务器时，就需要使用connect进行链接，udp是不需要链接的而是直接发送，但是tcp必须先链接，只有链接成功才能通信</li><li>当一个tcp客户端连接服务器时，服务器端会有1个新的套接字，这个套接字用来标记这个客户端，单独为这个客户端服务</li><li>listen后的套接字是被动套接字，用来接收新的客户端的链接请求的，而accept返回的新套接字是标记这个新客户端的</li><li>关闭listen后的套接字意味着被动套接字关闭了，会导致新的客户端不能够链接服务器，但是之前已经链接成功的客户端正常通信。</li><li>关闭accept返回的套接字意味着这个客户端已经服务完毕</li><li>当客户端的套接字调用close后，服务器端会recv解堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来区别客户端是否已经下线</li><li>空字符串能够直接发送不能够直接接收(tcp服务端会过滤)</li></ol><h4 id="tcp-三次握手和四次挥手"><a href="#tcp-三次握手和四次挥手" class="headerlink" title="tcp 三次握手和四次挥手"></a>tcp 三次握手和四次挥手</h4><h5 id="tcp-三次握手图解"><a href="#tcp-三次握手图解" class="headerlink" title="tcp 三次握手图解"></a>tcp 三次握手图解</h5><p><img src="https://upload-images.jianshu.io/upload_images/3365001-3f3bcc28ca39fa1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tcp三次握手1.png"></p><table><thead><tr><th>标志位</th><th>序号</th></tr></thead><tbody><tr><td>SYN: 表示连接请求</td><td>seq:表示报文序号</td></tr><tr><td>ACK: 表示确认</td><td>ack: 表示确认号</td></tr><tr><td>FIN:  表示关闭连接</td><td></td></tr></tbody></table><p><img src="https://upload-images.jianshu.io/upload_images/3365001-4203e495de645009.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="tcp三次握手.png"></p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）第一次握手：<span class="built_in">Client</span>将标志位SYN置为<span class="number">1</span>，随机产生一个值seq=J，并将该数据包发送给<span class="built_in">Server</span>，<span class="built_in">Client</span>进入SYN_SENT状态，等待<span class="built_in">Server</span>确认。</span><br><span class="line">（<span class="number">2</span>）第二次握手：<span class="built_in">Server</span>收到数据包后由标志位SYN=<span class="number">1</span>知道<span class="built_in">Client</span>请求建立连接，<span class="built_in">Server</span>将标志位SYN和ACK都置为<span class="number">1</span>， ack (number )=J+<span class="number">1</span>，随机产生一个值seq=K，并将该数据包发送给<span class="built_in">Client</span>以确认连接请求，<span class="built_in">Server</span>进入SYN_RCVD状态。</span><br><span class="line">（<span class="number">3</span>）第三次握手：<span class="built_in">Client</span>收到确认后，检查ack是否为J+<span class="number">1</span>，ACK是否为<span class="number">1</span>，如果正确则将标志位ACK置为<span class="number">1</span>，ack=K+<span class="number">1</span>，并将该数据包发送给<span class="built_in">Server</span>，<span class="built_in">Server</span>检查ack是否为K+<span class="number">1</span>，ACK是否为<span class="number">1</span>，如果正确则连接建立成功，<span class="built_in">Client</span>和<span class="built_in">Server</span>进入ESTABLISHED状态，完成三次握手，随后<span class="built_in">Client</span>与<span class="built_in">Server</span>之间可以开始传输数据了。</span><br><span class="line"></span><br><span class="line">理解总结：</span><br><span class="line"><span class="number">1.</span>客户端发起连接请求，等待服务端确定</span><br><span class="line"><span class="number">2.</span>服务端确认连接请求</span><br><span class="line"><span class="number">3.</span>客户端收到确认后，再次发送数据包验证（验证正确，连接成功，完成三次握手）</span><br></pre></td></tr></table></figure><h5 id="tcp-四次挥手图解"><a href="#tcp-四次挥手图解" class="headerlink" title="tcp 四次挥手图解"></a>tcp 四次挥手图解</h5><p><img src="https://upload-images.jianshu.io/upload_images/3365001-e77fdb8210af7052.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tcp四次挥手.png"></p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">客户端主动关闭（三次挥手）：</span><br><span class="line">（<span class="number">1</span>）第一次挥手：客户端发送一个FIN，用来关闭客户端到服务的数据传送。</span><br><span class="line">（<span class="number">2</span>）第二次挥手：服务端发送一个ACK，用来关闭服务端到客户端的数据传送。</span><br><span class="line">（<span class="number">3</span>) 第三次挥手：客户端收到ACK后，接着发送一个ACK给服务端，确认序号为收到序号+<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">服务端主动关闭（四次挥手）：</span><br><span class="line">（<span class="number">1</span>）第一次挥手：server发送一个FIN，用来关闭server到client的数据传送。</span><br><span class="line">（<span class="number">2</span>) 第二次挥手：client收到FIN后，发送一个ACK给server，确认序号为收到序号+<span class="number">1</span>。</span><br><span class="line">（<span class="number">3</span>）第三次挥手：client发送一个FIN，用来关闭Client到Server的数据传送。</span><br><span class="line">（<span class="number">4</span>) 第四次挥手：Server收到FIN后，接着发送一个ACK给Client，确认序号为收到序号+<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">理解总结：</span><br><span class="line"><span class="number">1.</span>服务端 close()（我要关闭连接了）</span><br><span class="line"><span class="number">2.</span>客户端收到后发送一条消息（别急，事情还没处理完...）</span><br><span class="line"><span class="number">3.</span>客户端处理完成后 close()（可以关闭连接了）</span><br><span class="line"><span class="number">4.</span>服务端接着发送一个 ACK 给 Client（连接已关闭！四次挥手完成）</span><br></pre></td></tr></table></figure><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p>1.tcp 客户端</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">from socket import *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建socket</span></span><br><span class="line">tcp_client_socket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目的信息</span></span><br><span class="line">server_ip = input(<span class="string">"请输入服务器ip:"</span>)</span><br><span class="line">server_port = int(input(<span class="string">"请输入服务器port:"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接服务器</span></span><br><span class="line">tcp_client_socket.connect((server_ip, server_port))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示用户输入数据</span></span><br><span class="line">send_data = input(<span class="string">"请输入要发送的数据："</span>)</span><br><span class="line"></span><br><span class="line">tcp_client_socket.send(send_data.encode(<span class="string">"gbk"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收对方发送过来的数据，最大接收1024个字节</span></span><br><span class="line">recvData = tcp_client_socket.recv(1024)</span><br><span class="line"><span class="section">print('接收到的数据为:', recvData.decode('gbk'))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭套接字</span></span><br><span class="line">tcp_client_socket.close()</span><br></pre></td></tr></table></figure><p>2.tcp 服务端</p><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">步骤：</span></span><br><span class="line"><span class="string">    1.socket创建一个套接字</span></span><br><span class="line"><span class="string">    2.bind绑定ip和port</span></span><br><span class="line"><span class="string">    3.listen使套接字变为可以被动链接</span></span><br><span class="line"><span class="string">    4.accept等待客户端的链接</span></span><br><span class="line"><span class="string">    5.recv/send接收发送数据</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">from socket import *</span><br><span class="line"></span><br><span class="line"><span class="meta"># 创建socket</span></span><br><span class="line">tcp_server_socket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="meta"># 本地信息</span></span><br><span class="line">address = (<span class="string">''</span>, <span class="number">7788</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta"># 绑定</span></span><br><span class="line">tcp_server_socket.bind(address)</span><br><span class="line"></span><br><span class="line"><span class="meta"># 使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收别人的链接了</span></span><br><span class="line">tcp_server_socket.listen(<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务</span></span><br><span class="line"><span class="meta"># client_socket用来为这个客户端服务</span></span><br><span class="line"><span class="meta"># tcp_server_socket就可以省下来专门等待其他新客户端的链接</span></span><br><span class="line">client_socket, clientAddr = tcp_server_socket.accept()</span><br><span class="line"></span><br><span class="line"><span class="meta"># 接收对方发送过来的数据</span></span><br><span class="line">recv_data = client_socket.recv(<span class="number">1024</span>)  # 接收<span class="number">1024</span>个字节</span><br><span class="line">print(<span class="string">'接收到的数据为:'</span>, recv_data.decode(<span class="string">'gbk'</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta"># 发送一些数据到客户端</span></span><br><span class="line">client_socket.send(<span class="string">"thank you !"</span>.encode(<span class="string">'gbk'</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta"># 关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了，如果还需要服务，只能再次重新连接</span></span><br><span class="line">client_socket.close()</span><br></pre></td></tr></table></figure><h3 id="TCP-与-UDP-的不同点"><a href="#TCP-与-UDP-的不同点" class="headerlink" title="TCP 与 UDP 的不同点"></a>TCP 与 UDP 的不同点</h3><p><strong>TCP：</strong></p><ul><li>面向连接（确认有创建三方交握，连接已创建才作传输。）</li><li>有序数据传输</li><li>重发丢失的数据包</li><li>舍弃重复的数据包</li><li>无差错的数据传输</li><li>阻塞/流量控制</li></ul><p><strong>UDP 通信模型（类似于写信/发短信/广播/视频聊天）</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-66f6ee5be9f9df0f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="udp通信模型.jpg"></p><p><strong>TCP 通信模型（类似于打电话）</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-55244b661df4c1a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP通信模型.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-网络通信&quot;&gt;&lt;a href=&quot;#Python-网络通信&quot; class=&quot;headerlink&quot; title=&quot;Python 网络通信&quot;&gt;&lt;/a&gt;Python 网络通信&lt;/h1&gt;&lt;h3 id=&quot;udp-和-tcp-及-socket-介绍&quot;&gt;&lt;a href=&quot;#udp-和-tcp-及-socket-介绍&quot; class=&quot;headerlink&quot; title=&quot;udp 和 tcp 及 socket 介绍&quot;&gt;&lt;/a&gt;udp 和 tcp 及 socket 介绍&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;注意：udp 和 tcp 都是网络传输的协议，只不过具体传输形式不一样，但功能都是定义网络传输数据规则。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;udp 和 tcp (发短信和打电话)(不同: 是否创建链接)&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://jovelin.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jovelin.cn/tags/Python/"/>
    
      <category term="udp" scheme="http://jovelin.cn/tags/udp/"/>
    
      <category term="tcp" scheme="http://jovelin.cn/tags/tcp/"/>
    
      <category term="socket" scheme="http://jovelin.cn/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>反问学习法（what、why、where），十万个为什么</title>
    <link href="http://jovelin.cn/2018/07/06/%E5%8F%8D%E9%97%AE%E5%AD%A6%E4%B9%A0%E6%B3%95%EF%BC%88what%E3%80%81why%E3%80%81where%EF%BC%89%EF%BC%8C%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88/"/>
    <id>http://jovelin.cn/2018/07/06/反问学习法（what、why、where），十万个为什么/</id>
    <published>2018-07-06T02:13:37.000Z</published>
    <updated>2018-07-18T11:49:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/3365001-b563404345271200.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="why.jpg"></p><p>不知道你们有没有这样的感受，就是当学完了一个知识点，可能知道怎么用、知道写代码的步骤（像套模板一样，按照案例、步骤一步步码出来），反正就是代码我能写出来，但是这个知识点是什么？为什么用它？在哪里使用这个知识点？往往就不是很清楚，有点印象、模模糊糊，理解不透彻。</p><a id="more"></a><p>平常工作的话，知道怎么用、知道怎么实现该功能，反正能完成任务即可，管它那么多！</p><p>那么问题来了，既然平常工作都没什么问题，还管它那么多干啥呢干啥呢。。</p><p><strong>原因有两点：</strong></p><p>一、深度掌握（用起来得心应手）</p><p>不只是照抄搬运，不是所有事情 copy 就能实现，要合理利用以前写过的案例，实现过的项目功能，懂得哪些地方能抄，也要懂得想改哪里就改哪里（就像一个人物换了个皮肤，相同点还是不变的，不同点就需要自己去发现去改造了，比如：变好看了，攻击变强了。。）</p><p>二、面试</p><p>大家都知道一个完整的面试包括三个流程（1、笔试 2、技术面试 3、hr面谈）</p><p>当然也有不用笔试的，2轮技术面试的也有，没有 hr 面谈的也大有存在，CTO 直接就能决定你的薪资，这也是小公司和大公司的一种差异</p><p>1.笔试：也就类似我们平常的考试，选择题、大题都有，只不过是综合的罢了（基础）</p><p>2.技术面谈：</p><ol><li>就你写的技术进行提问（一般有三种掌握程度，了解/熟练/精通）</li><li><p>项目上的提问（实现的过程、某个难点技术、碰到的 bug、团队开发遇到的问题都有。。）</p><p> 这就不仅仅是 知道怎么用、知道怎么实现该功能 就能过关了，和下面演示的 3个W反问 有关系了。</p></li><li><p>hr 面谈（恭喜你基本已经被录用了，谈工资这一块了，砍价、福利。。）</p></li></ol><blockquote><p>知识点分类：</p><p>1.死知识（不用死记硬背，API 文档、笔记、博客查阅即可） </p><p>2.理解性知识（理解实现原理，懂得框架，实现时灵活运用）</p></blockquote><p><strong>以 socket 知识点为例：</strong></p><p>———socket———</p><p>what<br>是什么？（概念、理解）</p><p>socket(简称 套接字 也称为插口–流对象) 是进程间通信的一种方式</p><p>why<br>为什么用？（好处，特点即不同点）</p><p>是实现tcp和udp的底层技术，实现 不同主机间 的进程间通信</p><p>where<br>在哪使用？（案例、实战）</p><p>网络程序发送、接收数据（发短信、打电话、广播）</p><p>————end————</p><blockquote><p>人生苦短，我用 Python，为何你要用 Python？———杠精</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3365001-b563404345271200.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;why.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;不知道你们有没有这样的感受，就是当学完了一个知识点，可能知道怎么用、知道写代码的步骤（像套模板一样，按照案例、步骤一步步码出来），反正就是代码我能写出来，但是这个知识点是什么？为什么用它？在哪里使用这个知识点？往往就不是很清楚，有点印象、模模糊糊，理解不透彻。&lt;/p&gt;
    
    </summary>
    
      <category term="学习方法" scheme="http://jovelin.cn/categories/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="学习方法" scheme="http://jovelin.cn/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>认识 Python</title>
    <link href="http://jovelin.cn/2017/06/22/%E8%AE%A4%E8%AF%86%20Python/"/>
    <id>http://jovelin.cn/2017/06/22/认识 Python/</id>
    <published>2017-06-22T13:25:32.000Z</published>
    <updated>2018-06-22T14:00:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Python-的起源"><a href="#1-Python-的起源" class="headerlink" title="1. Python 的起源"></a>1. Python 的起源</h2><p>人生苦短，我用 Python</p><blockquote><p>Python 的创始人为吉多·范罗苏姆（Guido van Rossum）</p></blockquote><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/3365001-0748c25c80efb613.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="002_吉多.jpg"></p><ul><li><p>Python的作者，Guido von Rossum，荷兰人。1982年，Guido从阿姆斯特丹大学获得了数学和计算机硕士学位。然而，尽管他算得上是一位数学家，但他更加享受计算机带来的乐趣。用他的话说，尽管拥有数学和计算机双料资质，他总趋向于做计算机相关的工作，并热衷于做任何和编程相关的活儿。</p></li><li><p>在那个时候，Guido接触并使用过诸如Pascal、C、Fortran等语言。这些语言的基本设计原则是让机器能更快运行。Guido知道如何用C语言写出一个功能，但整个编写过程需要耗费大量的时间，即使他已经准确的知道了如何实现。这种编程方式让Guido感到苦恼。</p></li><li><p>他的另一个选择是shell。Bourne Shell作为UNIX系统的解释器已经长期存在。UNIX的管理员们常常用shell去写一些简单的脚本，以进行一些系统维护的工作，比如定期备份、文件系统管理等等。shell可以像胶水一样，将UNIX下的许多功能连接在一起。许多C语言下上百行的程序，在shell下只用几行就可以完成。然而，shell的本质是调用命令。它并不是一个真正的语言。比如说，shell没有数值型的数据类型，加法运算都很复杂。总之，shell不能全面的调动计算机的功能。</p></li><li><p>Guido希望有一种语言，这种语言能够像C语言那样，能够全面调用计算机的功能接口，又可以像shell那样，可以轻松的编程。</p></li><li><p>1989年，为了打发圣诞节假期，Guido开始写Python语言的编译器。Python这个名字，来自Guido所挚爱的电视剧Monty Python’s Flying Circus。他希望这个新的叫做Python的语言，能符合他的理想：创造一种C和shell之间，功能全面，易学易用，可拓展的语言。Guido作为一个语言设计爱好者，已经有过设计语言的尝试。这一次，也不过是一次纯粹的hacking行为。</p></li></ul><h3 id="一门语言的诞生"><a href="#一门语言的诞生" class="headerlink" title="一门语言的诞生"></a>一门语言的诞生</h3><ul><li><p>1991年，第一个Python编译器诞生。它是用C语言实现的，并能够调用C语言的库文件。从一出生，Python已经具有了 ：类，函数，异常处理，包含表和词典在内的核心数据类型，以及模块为基础的拓展系统。</p></li><li><p>Python语法很多来自C，但又受到ABC语言的强烈影响。来自ABC语言的一些规定直到今天还富有争议，比如强制缩进。 但这些语法规定让Python容易读。另一方面，Python聪明的选择服从一些惯例，特别是C语言的惯例，比如回归等号赋值。Guido认为，如果“常识”上确立的东西，没有必要过度纠结。</p></li><li><p>Python从一开始就特别在意可拓展性。Python可以在多个层次上拓展。从高层上，你可以直接引入. py文件。在底层，你可以引用C语言的库。Python程序员可以快速的使用Python写. py文件作为拓展模块。但当性能是考虑的重要因素时，Python程序员可以深入底层，写C程序，编译为.so文件引入到Python中使用。Python就好像是使用钢构建房一样，先规定好大的框架。而程序员可以在此框架下相当自由的拓展或更改。</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/3365001-fa16f0a8dfd6f173.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="001_人生苦短我用python.jpg"></p><p>人生苦短，我用 Python</p><ul><li><p>由于计算机性能的提高，软件的世界也开始随之改变。硬件足以满足许多个人电脑的需要。硬件性能不是瓶颈，Python又容易使用，所以许多人开始转向Python。Guido维护了一个maillist，Python用户就通过邮件进行交流。Python用户来自许多领域，有不同的背景，对Python也有不同的需求。Python相当的开放，又容易拓展，所以当用户不满足于现有功能，很容易对Python进行拓展或改造。随后，这些用户将改动发给Guido，并由Guido决定是否将新的特征加入到Python或者标准库中。如果代码能被纳入Python自身或者标准库，这将极大的荣誉。由于Guido至高无上的决定权，他因此被称为“终身的仁慈独裁者”。</p></li><li><p>Python被称为“Battery Included”，是说它以及其标准库的功能强大。这些是整个社区的贡献。Python的开发者来自不同领域，他们将不同领域的优点带给Python。比如Python标准库中的正则表达是参考Perl，而lambda, map, filter, reduce等函数参考了Lisp。Python本身的一些功能以及大部分的标准库来自于社区。Python的社 区不断扩大，进而拥有了自己的newsgroup，网站，以及基金。从Python 2.0开始，Python也从maillist的开发方式，转为完全开源的开发方式。社区气氛已经形成，工作被整个社区分担，Python也获得了更加高速的发展。</p></li><li><p>到今天，Python的框架已经确立。Python语言以对象为核心组织代码，支持多种编程范式，采用动态类型，自动进行内存回收。Python支持解释运行，并能调用C库进行拓展。Python有强大的标准库。由于标准库的体系已经稳定，所以Python的生态系统开始拓展到第三方包。这些包，如Django、web.py、wxpython、numpy、matplotlib、PIL，将Python升级成了物种丰富的热带雨林。</p></li><li><p>Python崇尚优美、清晰、简单，是一个优秀并广泛使用的语言。Python在TIOBE排行榜中排行第八，它是Google的第三大开发语言，Dropbox的基础语言，豆瓣的服务器语言。Python的发展史可以作为一个代表，带给我许多启示。</p></li><li><p>在Python的开发过程中，社区起到了重要的作用。Guido自认为自己不是全能型的程序员，所以他只负责制订框架。如果问题太复杂，他会选择绕过去，也就是cut the corner。这些问题最终由社区中的其他人解决。社区中的人才是异常丰富的，就连创建网站，筹集基金这样与开发稍远的事情，也有人乐意于处理。如今的项目开发越来越复杂，越来越庞大，合作以及开放的心态成为项目最终成功的关键。</p></li><li><p>Python从其他语言中学到了很多，无论是已经进入历史的ABC，还是依然在使用的C和Perl，以及许多没有列出的其他 语言。可以说，Python的成功代表了它所有借鉴的语言的成功。同样，Ruby借鉴了Python，它的成功也代表了Python某些方面的成功。每个语言都是混合体，都有它优秀的地方，但也有各种各样的缺陷。同时，一个语言“好与不好”的评 判，往往受制于平台、硬件、时代等等外部原因。程序员经历过许多语言之争。其实，以开放的心态来接受各个语言，说不定哪一天，程序员也可以如Guido那样，混合出自己的语言。</p></li></ul><h4 id="关键点常识"><a href="#关键点常识" class="headerlink" title="关键点常识"></a>关键点常识</h4><ul><li>Python的发音与拼写</li><li>Python的作者是Guido van Rossum（龟叔）</li><li>Python正式诞生于1991年</li><li>Python的解释器如今有多个语言实现，我们常用的是CPython（官方版本的C语言实现），其他还有Jython（可以运行在Java平台）、IronPython（可以运行在.NET和Mono平台）、PyPy（Python实现的，支持JIT即时编译）</li><li><p>Python目前有两个版本，Python2和Python3，最新版分别为2.7.14和3.6.4</p></li><li><p>2018年1月份 编程语言流行排行榜</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/3365001-cee017a6aa9e6af4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TIOBE-201801.png"></p><h2 id="2-Python-优缺点"><a href="#2-Python-优缺点" class="headerlink" title="2. Python 优缺点"></a>2. Python 优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>简单————Python是一种代表简单主义思想的语言。阅读一个良好的Python程序就感觉像是在读英语一样，尽管这个英语的要求非常严格！Python的这种伪代码本质是它最大的优点之一。它使你能够专注于解决问题而不是去搞明白语言本身。</p></li><li><p>易学————就如同你即将看到的一样，Python极其容易上手。前面已经提到了，Python有极其简单的语法。</p></li><li><p>免费、开源————Python是FLOSS（自由/开放源码软件）之一。简单地说，你可以自由地发布这个软件的拷贝、阅读它的源代码、对它做改动、把它的一部分用于新的自由软件中。FLOSS是基于一个团体分享知识的概念。这是为什么Python如此优秀的原因之一——它是由一群希望看到一个更加优秀的Python的人创造并经常改进着的。</p></li><li><p>高层语言————当你用Python语言编写程序的时候，你无需考虑诸如如何管理你的程序使用的内存一类的底层细节。</p></li><li><p>可移植性————由于它的开源本质，Python已经被移植在许多平台上（经过改动使它能够工作在不同平台上）。如果你小心地避免使用依赖于系统的特性，那么你的所有Python程序无需修改就可以在下述任何平台上面运行。这些平台包括Linux、Windows、FreeBSD、Macintosh、Solaris、OS/2、Amiga、AROS、AS/400、BeOS、OS/390、z/OS、Palm OS、QNX、VMS、Psion、Acom RISC OS、VxWorks、PlayStation、Sharp Zaurus、Windows CE甚至还有PocketPC、Symbian以及Google基于linux开发的Android平台！</p></li><li><p>解释性————这一点需要一些解释。一个用编译性语言比如C或C++写的程序可以从源文件（即C或C++语言）转换到一个你的计算机使用的语言（二进制代码，即0和1）。这个过程通过编译器和不同的标记、选项完成。当你运行你的程序的时候，连接/转载器软件把你的程序从硬盘复制到内存中并且运行。而Python语言写的程序不需要编译成二进制代码。你可以直接从源代码运行程序。在计算机内部，Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。事实上，由于你不再需要担心如何编译程序，如何确保连接转载正确的库等等，所有这一切使得使用Python更加简单。由于你只需要把你的Python程序拷贝到另外一台计算机上，它就可以工作了，这也使得你的Python程序更加易于移植。</p></li><li><p>面向对象————Python既支持面向过程的编程也支持面向对象的编程。在“面向过程”的语言中，程序是由过程或仅仅是可重用代码的函数构建起来的。在“面向对象”的语言中，程序是由数据和功能组合而成的对象构建起来的。与其他主要的语言如C++和Java相比，Python以一种非常强大又简单的方式实现面向对象编程。</p></li><li><p>可扩展性————如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们。</p></li><li><p>丰富的库————Python标准库确实很庞大。它可以帮助你处理各种工作，包括正则表达式、文档生成、单元测试、线程、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、WAV文件、密码系统、GUI（图形用户界面）、Tk和其他与系统有关的操作。记住，只要安装了Python，所有这些功能都是可用的。这被称作Python的“功能齐全”理念。除了标准库以外，还有许多其他高质量的库，如wxPython、Twisted和Python图像库等等。</p></li><li><p>规范的代码————Python采用强制缩进的方式使得代码具有极佳的可读性。</p></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>运行速度，有速度要求的话，用C++改写关键部分吧。</li><li>国内市场较小（国内以python来做主要开发的，目前只有一些web2.0公司）。但时间推移，目前很多国内软件公司，尤其是游戏公司，也开始规模使用他。</li><li>中文资料匮乏（好的python中文资料屈指可数）。托社区的福，有几本优秀的教材已经被翻译了，但入门级教材多，高级内容还是只能看英语版。</li><li>构架选择太多（没有像C#这样的官方.net构架，也没有像ruby由于历史较短，构架开发的相对集中。Ruby on Rails 构架开发中小型web程序天下无敌）。不过这也从另一个侧面说明，python比较优秀，吸引的人才多，项目也多。</li></ol><h2 id="3-Python-应用场景"><a href="#3-Python-应用场景" class="headerlink" title="3. Python 应用场景"></a>3. Python 应用场景</h2><ul><li><p><strong>Web应用开发</strong></p><p>Python经常被用于Web开发。比如，通过mod_wsgi模块，Apache可以运行用Python编写的Web程序。Python定义了WSGI标准应用接口来协调Http服务器与基于Python的Web程序之间的通信。一些Web框架，如Django,TurboGears,web2py,Zope等，可以让程序员轻松地开发和管理复杂的Web程序。</p></li><li><p><strong>操作系统管理、服务器运维的自动化脚本</strong></p><p>在很多操作系统里，Python是标准的系统组件。 大多数Linux发行版以及NetBSD、OpenBSD和Mac OS X都集成了Python，可以在终端下直接运行Python。有一些Linux发行版的安装器使用Python语言编写，比如Ubuntu的Ubiquity安装器,Red Hat Linux和Fedora的Anaconda安装器。Gentoo Linux使用Python来编写它的Portage包管理系统。Python标准库包含了多个调用操作系统功能的库。通过pywin32这个第三方软件 包，Python能够访问Windows的COM服务及其它Windows API。使用IronPython，Python程序能够直接调用.Net Framework。一般说来，Python编写的系统管理脚本在可读性、性能、代码重用度、扩展性几方面都优于普通的shell脚本。</p></li><li><p><strong>科学计算</strong></p><p>NumPy,SciPy,Matplotlib可以让Python程序员编写科学计算程序。</p></li><li><p><strong>桌面软件</strong></p><p>PyQt、PySide、wxPython、PyGTK是Python快速开发桌面应用程序的利器。</p></li><li><p><strong>服务器软件（网络软件）</strong></p><p>Python对于各种网络协议的支持很完善，因此经常被用于编写服务器软件、网络爬虫。第三方库Twisted支持异步网络编程和多数标准的网络协议(包含客户端和服务器)，并且提供了多种工具，被广泛用于编写高性能的服务器软件。</p></li><li><p><strong>游戏</strong></p><p>很多游戏使用C++编写图形显示等高性能模块，而使用Python或者Lua编写游戏的逻辑、服务器。相较于Python，Lua的功能更简单、体积更小；而Python则支持更多的特性和数据类型。</p></li><li><p><strong>构思实现，产品早期原型和迭代</strong></p><p>YouTube、Google、Yahoo!、NASA都在内部大量地使用Python。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Python-的起源&quot;&gt;&lt;a href=&quot;#1-Python-的起源&quot; class=&quot;headerlink&quot; title=&quot;1. Python 的起源&quot;&gt;&lt;/a&gt;1. Python 的起源&lt;/h2&gt;&lt;p&gt;人生苦短，我用 Python&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Python 的创始人为吉多·范罗苏姆（Guido van Rossum）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python基础" scheme="http://jovelin.cn/categories/Python%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Python基础" scheme="http://jovelin.cn/tags/Python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理</title>
    <link href="http://jovelin.cn/2017/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <id>http://jovelin.cn/2017/06/22/计算机组成原理/</id>
    <published>2017-06-22T01:47:06.000Z</published>
    <updated>2018-06-22T01:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是计算机？"><a href="#什么是计算机？" class="headerlink" title="什么是计算机？"></a>什么是计算机？</h1><p>计算机（computer）俗称电脑，是现代一种用于高速计算的电子机器，可以进行数值计算，又可以进行逻辑判断，还具有存储记忆功能，且能够按照程序的运行，自动、高速处理数据。</p><blockquote><p>计算机是20世纪最先进的科学技术发明之一。</p></blockquote><a id="more"></a><h1 id="计算机是由什么组成的？"><a href="#计算机是由什么组成的？" class="headerlink" title="计算机是由什么组成的？"></a>计算机是由什么组成的？</h1><p><strong>一个完整的计算机系统，是由<code>硬件系统</code>和<code>软件系统</code>两大部分组成的。</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-8aefbecac43e38e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="computer.png"></p><h2 id="1-硬件系统"><a href="#1-硬件系统" class="headerlink" title="1. 硬件系统"></a>1. 硬件系统</h2><p>主要分为主机和外设两部分，是指那些构成计算机系统的物理实体，它们主要由各种各样的电子器件和机电装置组成。</p><p>从ENIAC(世界上第一台计算机)到当前最先进的计算机，硬件系统的设计采用的都是 冯·诺依曼体系结构。</p><p><img src="https://upload-images.jianshu.io/upload_images/3365001-5f9b4bea1ca081e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="冯诺依曼体系结构.png"></p><blockquote><p>运算器:　负责数据的算术运算和逻辑运算，即数据的加工处理。</p><p>控制器:　是整个计算机的中枢神经，分析程序规定的控制信息，并根据程序要求进行控制，协调计算机各部分组件工作及内存与外设的访问等。</p><p>运算器和控制器统称中央处理器（即CPU)</p><p>存储器:　实现记忆功能的部件，用来存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息。</p><p>输入设备:　实现将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机。</p><p>输出设备:　实现将计算机处理后生成的中间结果或最后结果（各种数据符号及文字或各种控制信号等信息）输出出来。</p></blockquote><h2 id="2-软件系统"><a href="#2-软件系统" class="headerlink" title="2. 软件系统"></a>2. 软件系统</h2><p>主要分为系统软件和应用软件，是指计算机证运行所需的各种各样的计算机程序。</p><p>系统软件的任务是既要保证计算机硬件的正常工作，又要使计算机硬件的性能得到充分发挥，并且为计算机用户提供一个比较直观、方便和友好的使用界面。</p><h3 id="2-1-操作系统（Operation-System，OS）"><a href="#2-1-操作系统（Operation-System，OS）" class="headerlink" title="2.1 操作系统（Operation System，OS）"></a>2.1 操作系统（Operation System，OS）</h3><ul><li>没有安装操作系统的计算机，通常被称为 <strong>裸机</strong></li><li>如果想在 <strong>裸机</strong> 上运行自己所编写的程序，就必须用机器语言书写程序</li></ul><blockquote><p>操作系统作为接口的示意图</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/3365001-724f676482e34f05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="001_OS作为接口的示意图.png"></p><h4 id="2-1-1-操作系统的作用："><a href="#2-1-1-操作系统的作用：" class="headerlink" title="2.1.1 操作系统的作用："></a>2.1.1 操作系统的作用：</h4><ul><li>是现代计算机系统中 <strong>最基本和最重要</strong> 的系统软件</li><li>主要作用是<strong>管理好硬件设备</strong>，并为用户和应用程序提供一个简单的接口，以便于使用</li><li>而其他的诸如驱动程序、编译程序、数据库管理系统，以及大量的应用软件，都直接依赖于操作系统的支持</li></ul><h3 id="2-2-其他系统程序"><a href="#2-2-其他系统程序" class="headerlink" title="2.2 其他系统程序"></a>2.2 其他系统程序</h3><ul><li><p><strong>驱动程序</strong>：真正管理和控制硬件的程序，往往操作系统会携带一些默认版本</p></li><li><p><strong>语言处理程序</strong>：也称为编译程序，作用是把程序员用某种编程语言(如Python)所编写的程序，翻译成计算机可执行的机器语言。机器语言也被称为机器码，是可以通过CPU进行分析和执行的指令集。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是计算机？&quot;&gt;&lt;a href=&quot;#什么是计算机？&quot; class=&quot;headerlink&quot; title=&quot;什么是计算机？&quot;&gt;&lt;/a&gt;什么是计算机？&lt;/h1&gt;&lt;p&gt;计算机（computer）俗称电脑，是现代一种用于高速计算的电子机器，可以进行数值计算，又可以进行逻辑判断，还具有存储记忆功能，且能够按照程序的运行，自动、高速处理数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;计算机是20世纪最先进的科学技术发明之一。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python基础" scheme="http://jovelin.cn/categories/Python%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机" scheme="http://jovelin.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Python基础学习大纲</title>
    <link href="http://jovelin.cn/2017/06/21/Python%20%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2/"/>
    <id>http://jovelin.cn/2017/06/21/Python 基础学习大纲/</id>
    <published>2017-06-21T12:34:44.000Z</published>
    <updated>2018-07-06T02:24:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><p>1.掌握 Python 基础语法, 具备基础的编程能力；</p><p>2.建立起编程思维以及面向对象程序设计思想。</p><p>3.能够熟练使用 Python 技术完成较小程序的开发以及简单小游戏程序的开发。</p><a id="more"></a><hr><h3 id="学习知识点"><a href="#学习知识点" class="headerlink" title="学习知识点"></a>学习知识点</h3><h4 id="1-计算机组成原理"><a href="#1-计算机组成原理" class="headerlink" title="1.计算机组成原理"></a><a href="http://jovelin.cn/2017/06/22/计算机组成原理/">1.计算机组成原理</a></h4><p>认识操作系统以及操作系统的作用</p><h4 id="2-认识-Python"><a href="#2-认识-Python" class="headerlink" title="2.认识 Python"></a>2.认识 Python</h4><p>认识 Python 及了解 Python 发展历史</p><h4 id="3-Python-开发环境"><a href="#3-Python-开发环境" class="headerlink" title="3.Python 开发环境"></a>3.Python 开发环境</h4><p>Python 开发环境的搭建、Sublime 使用、Python 交互式终端使用、IPython 交互式终端使用、Pycharm 使用</p><h4 id="4-Python-基础变量"><a href="#4-Python-基础变量" class="headerlink" title="4.Python 基础变量"></a>4.Python 基础变量</h4><p>变量以及变量的类型、标识符和关键字、变量名命名方式、算数运算符、变量数据类型转换、输入和输出、注释 </p><h4 id="5-逻辑控制语句"><a href="#5-逻辑控制语句" class="headerlink" title="5.逻辑控制语句"></a>5.逻辑控制语句</h4><p>if语句基本格式、if…else…语句、if…elif..else语句、逻辑运算符、比较关系运算符、运算符优先级、while循环语法格式、while嵌套应用、break的用法、continue的用法 </p><h4 id="6-高级变量类型"><a href="#6-高级变量类型" class="headerlink" title="6.高级变量类型"></a>6.高级变量类型</h4><p>列表概念及操作、元组概念及操作、字典概念及操作、字符串概念及操作、集合概念及操作、for循环及for…else用法 </p><h4 id="7-函数应用"><a href="#7-函数应用" class="headerlink" title="7.函数应用"></a>7.函数应用</h4><p>函数的基本语法、函数执行流程、文档注释、带参数的函数、带返回值的函数、函数的嵌套调用、匿名函数、递归函数、局部变量和全局变量、引用 </p><h4 id="8-文件操作"><a href="#8-文件操作" class="headerlink" title="8.文件操作"></a>8.文件操作</h4><p>文件的概念、文件的打开与关闭、文件读写, 以及文件定位读写、文件、目录相关操作 </p><h4 id="9-面向对象"><a href="#9-面向对象" class="headerlink" title="9.面向对象"></a>9.面向对象</h4><p>面向对象介绍、类和对象的概念、魔术方法的意义及作用、对象成员的访问控制权限、继承的概念及意义、继承、多层继承和多继承、多态的概念以及应用、类属性和实例属性、实例方法、类方法、静态方法、设计模式: 单例模式</p><h4 id="10-异常处理"><a href="#10-异常处理" class="headerlink" title="10.异常处理"></a>10.异常处理</h4><p>理解异常的作用、捕获异常、异常的传递规则、自定义异常 </p><h4 id="11-模块和包"><a href="#11-模块和包" class="headerlink" title="11.模块和包"></a>11.模块和包</h4><p>模块和包的概念、<strong>all</strong>的用法、import语句用法、from…import…用法、from…import * 用法</p><hr><h3 id="项目演练"><a href="#项目演练" class="headerlink" title="项目演练"></a>项目演练</h3><h4 id="飞机大战"><a href="#飞机大战" class="headerlink" title="飞机大战"></a>飞机大战</h4><p>pygame介绍、界面搭建、键盘事件检测、显示飞机、<br>控制飞机、飞机发射子弹、显示敌机、敌机移动规则、敌机发射子弹、碰撞检测、面向对象完成代码封装</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h3&gt;&lt;p&gt;1.掌握 Python 基础语法, 具备基础的编程能力；&lt;/p&gt;
&lt;p&gt;2.建立起编程思维以及面向对象程序设计思想。&lt;/p&gt;
&lt;p&gt;3.能够熟练使用 Python 技术完成较小程序的开发以及简单小游戏程序的开发。&lt;/p&gt;
    
    </summary>
    
      <category term="Python基础" scheme="http://jovelin.cn/categories/Python%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Python基础" scheme="http://jovelin.cn/tags/Python%E5%9F%BA%E7%A1%80/"/>
    
      <category term="学习大纲" scheme="http://jovelin.cn/tags/%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2/"/>
    
  </entry>
  
  <entry>
    <title>Pycharm for Mac 快捷键</title>
    <link href="http://jovelin.cn/2017/06/20/Pycharm%20for%20Mac%20%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://jovelin.cn/2017/06/20/Pycharm for Mac 快捷键/</id>
    <published>2017-06-20T01:27:58.000Z</published>
    <updated>2018-06-20T02:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Pycharm-for-Mac-快捷键"><a href="#Pycharm-for-Mac-快捷键" class="headerlink" title="Pycharm for Mac 快捷键"></a>Pycharm for Mac 快捷键</h3><p>ctrl + r                            运行</p><p>ctrl + d                           调试</p><p>ctrl + shift + r                 从编辑器运行上下文环境配置</p><p>ctrl + shift + d                从编辑器调试上下文环境配置</p><a id="more"></a><p>ctrl + opt + r                   弹出 Run 的可选菜单</p><p>ctrl + opt + d                  弹出 Debug 的可选菜单</p><p>fn + f8                            单步调试，跳过函数</p><p>fn + f7                            单步调试，会进入函数内部</p><p>cmd + 1                         展开收缩左边文件栏</p><p>cmd + /                          注释/取消注释一行</p><p>fn + ctrl + space            基本代码补全（补全任何类、方法、<br>变量）</p><p>cmd + shift + -/+           收缩/展开代码块</p><p>cmd + opt + l                 格式化代码</p><p>fn + cmd + f2                 退出运行</p><p>cmd + shift + 上/下        移动代码块</p><p>cmd + z                          撤回</p><p>cmd + shift + z               取消撤回</p><p>cmd + opt + r                 跳到下一个断点</p><p>fn + cmd + shift + f8      查看所有断点</p><p>ctrl + j                             查看函数文档注释</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Pycharm-for-Mac-快捷键&quot;&gt;&lt;a href=&quot;#Pycharm-for-Mac-快捷键&quot; class=&quot;headerlink&quot; title=&quot;Pycharm for Mac 快捷键&quot;&gt;&lt;/a&gt;Pycharm for Mac 快捷键&lt;/h3&gt;&lt;p&gt;ctrl + r                            运行&lt;/p&gt;
&lt;p&gt;ctrl + d                           调试&lt;/p&gt;
&lt;p&gt;ctrl + shift + r                 从编辑器运行上下文环境配置&lt;/p&gt;
&lt;p&gt;ctrl + shift + d                从编辑器调试上下文环境配置&lt;/p&gt;
    
    </summary>
    
      <category term="Pycharm" scheme="http://jovelin.cn/categories/Pycharm/"/>
    
    
      <category term="Pycharm" scheme="http://jovelin.cn/tags/Pycharm/"/>
    
      <category term="快捷键" scheme="http://jovelin.cn/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>写作都需要的中文排版指南</title>
    <link href="http://jovelin.cn/2017/01/20/%E5%86%99%E4%BD%9C%E9%83%BD%E9%9C%80%E8%A6%81%E7%9A%84%E4%B8%AD%E6%96%87%E6%8E%92%E7%89%88%E6%8C%87%E5%8D%97/"/>
    <id>http://jovelin.cn/2017/01/20/写作都需要的中文排版指南/</id>
    <published>2017-01-20T02:33:10.000Z</published>
    <updated>2018-06-21T13:47:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文适用于所有编辑、作家、撰稿人、公众号作者、博主等，甚至适合所有人，因为人的一生难免避免不了写作。</p><a id="more"></a><h3 id="1-空格"><a href="#1-空格" class="headerlink" title="1. 空格"></a>1. 空格</h3><p>我每次看到网页上的中文字和英文、数字、符号挤在一起，就会坐立不安，忍不住想在他们之间加个空格。</p><p>「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在34岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。」</p><p><strong>中英文之间需要加空格</strong></p><p>eg. 大家可以在 GitHub 上搜索 jovelin 找到我。</p><p><strong>中文与数字之间需要加空格</strong></p><p>eg. 不知不觉，我已经工作 2 年了。</p><p><strong>数字与单位之间需要加空格</strong></p><p>eg. 我有一个 2 TB 的网盘，貌似还是不够用。</p><p><strong>完整的英文整句时标点与单词之间需要加空格</strong></p><p>eg. Don’t tangle, not hesitant.</p><p>But，也有一些例外：</p><p><strong>度的标志、百分号不加空格</strong></p><p>eg. 今天气温有 32° 的高温。</p><p><strong>全角标点与其他字符之间不加空格</strong></p><p>eg. 大家好，我是 jovelin，请多多关照。</p><h3 id="2-标点"><a href="#2-标点" class="headerlink" title="2. 标点"></a>2. 标点</h3><p>说到标点，不得不说下全角和半角，很多人可能不了解全角和半角的概念，这里顺便介绍下。</p><p>全角和半角是英文和中文的编码规范不同遗留下的问题，简单来说，全角占两个字节，半角占一个字节，你可以理解成中文汉字是全角，英文字母是半角，不过半角全角主要是针对标点符号来说的，中文标点占两个字节，英文标点占一个字节。体现在排版上的差异就是，全角字符屏幕打印宽度是两个，而半角字符屏幕打印宽度是一个，如中文逗号和英文逗号他们的显示分别是「，」和「,」。</p><p><strong>使用全角中文标点</strong></p><p>中文排版中所有的标点都应该使用中文全角中文标点</p><p>eg. 大家好，我是 jovelin。</p><p><strong>遇到英文整句、特殊名词时使用半角标点</strong></p><p>eg. 乔布斯说过：「Stay hungry, stay foolish.」</p><p>eg. Facebook, Inc.</p><p><strong>使用直角引号</strong></p><p>我国国家标准要求弯引号，但是个人建议在新媒体排版时使用直角引号。</p><p>eg. 你竟然不知道「MacBook Pro」？</p><p><strong>如果引号中使用引号使用直角双引号</strong></p><p>eg. 我质问他，「你难道忘记『乔布斯』了么？」</p><h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h3><p>除以上之外，还有一些其他标准推荐大家使用的。</p><p><strong>英文名词首字母尽量大写</strong></p><p>eg. Google、Android、Facebook。</p><p><strong>专有名词使用正确的大小写</strong></p><p>eg. GitHub、Python、iOS、iPhone X、MacBook Pro。</p><p><strong>首行不要缩进</strong></p><p>这点可能有人不同意，但是我要在这里解释下，在说明之前我们必须弄明白「首行缩进」的目的是什么。</p><p>「每段之前空两格」是我们从小学写作文就养成的习惯，也是正式文体的格式要求，其目的是为了区分自然段。</p><p>但是像我们现在接触的阅读，都是没有固定的格式要求的，如微信公众号、电子文档等，所以大家一般都采用「空出一行」进行自然段与自然段之间的区分，这种写作方式非常省事，而且很整齐。</p><p>所以，我认为这种应该是最科学的方式，只要没有明确的格式要求，写作的排版无须首行缩进。</p><p><strong>适当的间距、空行</strong></p><p>如果段落太长，可以使用适当的空行分段，比如这篇文章，这样不会给读者造成阅读压力，提升阅读体验。</p><p>最后，你可能会问，以上这些原则是业界标准么？我不敢保证，但是你不妨看下 「Apple 中国官网」、「Microsoft 中国官网」、公众号「小道消息」、「MacTalk」、「可能吧」等的排版，基本都是使用以上排版标准。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/25797162" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25797162</a></p><p><a href="https://zhuanlan.zhihu.com/p/20506092" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20506092</a></p><p><a href="https://github.com/mzlogin/chinese-copywriting-guidelines" target="_blank" rel="noopener">mzlogin/chinese-copywriting-guidelines</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文适用于所有编辑、作家、撰稿人、公众号作者、博主等，甚至适合所有人，因为人的一生难免避免不了写作。&lt;/p&gt;
    
    </summary>
    
      <category term="写作排版" scheme="http://jovelin.cn/categories/%E5%86%99%E4%BD%9C%E6%8E%92%E7%89%88/"/>
    
    
      <category term="写作排版" scheme="http://jovelin.cn/tags/%E5%86%99%E4%BD%9C%E6%8E%92%E7%89%88/"/>
    
  </entry>
  
  <entry>
    <title>简书的 Markdown 编辑器</title>
    <link href="http://jovelin.cn/2017/01/15/%E7%AE%80%E4%B9%A6%E7%9A%84%20Markdown%20%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://jovelin.cn/2017/01/15/简书的 Markdown 编辑器/</id>
    <published>2017-01-15T02:27:38.000Z</published>
    <updated>2018-06-20T02:31:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在简书的设置中，根据路径 <strong>基础设置 -&gt; 常用编辑器 -&gt; 点选Markdown </strong>即可启用markdown编辑器。<br>然后在创作文章的管理界面，点击切换到预览模式按钮，即可出现实时预览的创作界面。我们在左侧输入文字，在右侧会自动显示预览。</p></blockquote><a id="more"></a><h4 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h4><p><img src="http://upload-images.jianshu.io/upload_images/3365001-7607b3cb9f492354.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标题"></p><p>将1~6个#井号放在标题内容的前面，就能够轻松的表示不同字号的标题。</p><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"># 一级标题 字号最大</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题 字号最小</span><br></pre></td></tr></table></figure><p>预览效果在上图中已经清晰的展示出来，大家也可以立刻启用简书的markdown工具，跟着文章开始动手尝试。</p><blockquote><p>为了规范使用习惯，建议大家在字符与文字之间留一个空格，在后面的许多语法也是同样的建议。</p></blockquote><h4 id="二、分割线"><a href="#二、分割线" class="headerlink" title="二、分割线"></a>二、分割线</h4><p><img src="http://upload-images.jianshu.io/upload_images/3365001-4c84abae30469393.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多个横杠和等号可以用表表示一级标题和二级标题以及分割线"></p><p>使用3个以上的任意数量的-_*符号，即可输出一条分割线。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">// 以下几种情况都能够输出分割线</span><br><span class="line"><span class="strong">*****</span><span class="emphasis">***</span></span><br><span class="line">----------</span><br><span class="line"><span class="strong">_____</span>_</span><br></pre></td></tr></table></figure><p>我们可以看到，图中还可以使用文字加上等号与减号分别表示一级标题与二级标题。</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大于两个任意数量的等号</span></span><br><span class="line">一级标题</span><br><span class="line">======</span><br><span class="line"><span class="comment">// 大于两个任意属相的减号</span></span><br><span class="line">二级标题</span><br><span class="line">----</span><br></pre></td></tr></table></figure><h4 id="三、段落引用-Blockquotes"><a href="#三、段落引用-Blockquotes" class="headerlink" title="三、段落引用 Blockquotes"></a>三、段落引用 Blockquotes</h4><p><img src="http://upload-images.jianshu.io/upload_images/3365001-2bd1d495e1c43a23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="段落引用"></p><blockquote><p>在普通段落前面加上一个 &gt; 符号，即可将该段落标记为引用。在引用中，能够与其他任意语法组合。</p></blockquote><p>输入一个空行，可结束一段引用。 </p><h4 id="四、无序列表"><a href="#四、无序列表" class="headerlink" title="四、无序列表"></a>四、无序列表</h4><p><img src="http://upload-images.jianshu.io/upload_images/3365001-4fa700b7ce018f4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="无序列表"></p><ul><li>加号+空格 ‘+ ‘</li></ul><ul><li>减号+空格 ‘- ‘</li></ul><ul><li>星号+空格 ‘* ‘</li></ul><p>+-*任意一种字符与空格组合，能将一个段落标记为无序列表。无序列表中也可以与其他语法组合使用。</p><p>输入一个空行，可结束一个无序列表。</p><h4 id="五、有序列表"><a href="#五、有序列表" class="headerlink" title="五、有序列表"></a>五、有序列表</h4><p><img src="http://upload-images.jianshu.io/upload_images/3365001-89b2566a7c842eda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="有序列表"></p><ol start="0"><li><strong>任意数字与空格组合，可以开始一个有序列表。</strong>即使每一列的数字并不是按顺序来，输出结果也会智能的从1开始依次排序。</li><li><strong>数字+点+空格</strong> 开始一个有序列表</li><li>后面的只要都是数字，无论是多少</li><li>都会自动按顺序识别。</li></ol><ol><li>使用两行空格或者其他诸如图片这样的格式，能够终止一个有序列表。</li></ol><h4 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h4><p><img src="http://upload-images.jianshu.io/upload_images/3365001-dbc786df222a3baa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="超链接"></p><p><a href="http://www.jianshu.com/u/149c3a6ceb25" target="_blank" rel="noopener">我的簡書</a> <a href="https://github.com/jovelin" target="_blank" rel="noopener">github</a></p><p><em>[]()</em> 可以输出一个超链接。其中中括号中填写文字信息，小括号中填写链接地址信息。简书可以保留复制格式，也就是说，如果你从其他地方复制一个带超链接的文字过来，超链接会自动保留。</p><h4 id="七、图片"><a href="#七、图片" class="headerlink" title="七、图片"></a>七、图片</h4><p><img src="http://upload-images.jianshu.io/upload_images/3365001-aab9682ae3425bd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p><p><img src="http://upload.jianshu.io/users/upload_avatars/3365001/e1eae8fc5f67.png?imageMogr2/auto-orient/strip|imageView2/1/w/240/h/240" alt="头像"></p><p><em>![]()</em> 可以输出一张图片的显示。其中中括号中填写图片的描述信息，描述信息最终会在图片下方的横线中显示。小括号中填写图片的地址。</p><p>而在图片的处理上，简书的markdown做到了最人性化的体验。我们可以使用剪切工具比如QQ或者微信的剪切工具在电脑上任意剪切一张图，然后就可以直接复制在简书里。如下图所示。这一点，极大的便利了我们对图片的处理。我们不用将图片保存起来，然后拖入简书。本文中所有的图片都是剪切后直接复制进来的，简单快捷方便。大爱这个特性。</p><p><img src="http://upload-images.jianshu.io/upload_images/3365001-580a8c35a74ef48f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="直接将复制在剪切板的图片粘贴进来即可，简书的markdown工具会自动上传到cdn服务器"></p><h4 id="八、强调"><a href="#八、强调" class="headerlink" title="八、强调"></a>八、强调</h4><p><img src="http://upload-images.jianshu.io/upload_images/3365001-334388a61e3e19d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="强调"></p><p>*_ 可以设置文字为加粗或者斜体。具体使用情况见图。</p><h4 id="九、代码块"><a href="#九、代码块" class="headerlink" title="九、代码块"></a>九、代码块</h4><p><img src="http://upload-images.jianshu.io/upload_images/3365001-241af0b59a0a47d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码块"></p><p>这是程序员大爱的语法。<br>在 <strong><code></code></strong> 符号中输入文字或者代码片段，输入的文字将会被标注起来。<br>例如 <code>这是一段被标注的文字</code>。<br>代码块效果如下:<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里面支持代码高亮。</span></span><br><span class="line"><span class="comment">// 所以我们程序员写博客，会经常将我们的代码放在这个语法中。</span></span><br><span class="line"><span class="comment">// 不同的功能会显示出不同的颜色。</span></span><br><span class="line"><span class="comment">// 例如注释</span></span><br><span class="line"><span class="keyword">var</span> $element = <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">'#container'</span>);</span><br></pre></td></tr></table></figure></p><h4 id="十、表格"><a href="#十、表格" class="headerlink" title="十、表格"></a>十、表格</h4><p><img src="http://upload-images.jianshu.io/upload_images/3365001-0f93642e1981a639.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表格"></p><table><thead><tr><th style="text-align:center">姓名</th><th style="text-align:center">性别</th><th style="text-align:center">年龄</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">jovelin</td><td style="text-align:center">男</td><td style="text-align:center">20</td><td style="text-align:center">简书</td></tr></tbody></table><p>在我们写文章的时候，虽然表格被用到的时候并不多，但是这确实是一个功能强大的语法，能在我们需要时轻松帮助我们解决困难。</p><p>语法的中间部分|:—:|:—:|:—:|是整个表格的关键。该部分的上方表示为标题，下方为表格的每一项。都使用竖线|隔开。</p><p>我们可以通过修改中间部分，来修改表格文案的对齐方式。</p><pre><code>|:---|:---|:---|       左对齐|:---:|:---:|:---:|    居中对齐|---:|---:|---:|       右对齐</code></pre><h4 id="十一、反斜杠"><a href="#十一、反斜杠" class="headerlink" title="十一、反斜杠"></a>十一、反斜杠</h4><p><img src="http://upload-images.jianshu.io/upload_images/3365001-9a0abbdcbae8d0a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="反斜杠"></p><p>这一条其实应该不算什么语法了，只是为我们在markdown语法中输入这些符号提供了一个方式。防止这些符号被认为是语法。</p><p>花10来分钟熟练上面这十条语句，就能够轻松的使用markdown进行文学创作了。赶紧在简书web版里动手试试吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在简书的设置中，根据路径 &lt;strong&gt;基础设置 -&amp;gt; 常用编辑器 -&amp;gt; 点选Markdown &lt;/strong&gt;即可启用markdown编辑器。&lt;br&gt;然后在创作文章的管理界面，点击切换到预览模式按钮，即可出现实时预览的创作界面。我们在左侧输入文字，在右侧会自动显示预览。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Markdown" scheme="http://jovelin.cn/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="http://jovelin.cn/tags/Markdown/"/>
    
  </entry>
  
</feed>
